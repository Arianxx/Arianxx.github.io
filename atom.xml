<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arian.X</title>
  
  <subtitle>独立技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arianx.me/"/>
  <updated>2018-08-18T13:57:40.503Z</updated>
  <id>https://arianx.me/</id>
  
  <author>
    <name>Arian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用位运算实现加减乘除</title>
    <link href="https://arianx.me/2018/08/17/Use-bit-arithmetic-to-implement-addition-subtraction-multiplication-and-division/"/>
    <id>https://arianx.me/2018/08/17/Use-bit-arithmetic-to-implement-addition-subtraction-multiplication-and-division/</id>
    <published>2018-08-17T12:47:59.000Z</published>
    <updated>2018-08-18T13:57:40.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>加法可以拆分成几个步骤，首先是每位上的数对应相加，将结果与对应的基数取模，设置为当前位，然后处理相加之后产生进位的位，给它们的上一个拥有更大权值的位加上一，如果又产生进位，就如此循环，直到没有进位为止。<br><a id="more"></a></p><p>对于二进制来说，第一步相加取模是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 + 1 = 0</span><br><span class="line">1 + 0 = 1</span><br><span class="line">0 + 0 = 0</span><br></pre></td></tr></table></figure></p><p>可以看到，只有两位数不一样的情况下，值才为1。这正和<code>异或运算</code>的结果相同。</p><p>而在二进制中，只有1+1才有可能产生进位，也就是说，我们需要找出两个数中都为1的位，这一点可以使用<code>与运算</code>实现。然后，将与运算的结果左移一位，与第一步的结果相加，就能得到最终的结果。</p><p>可以注意到最后又产生了一次加法，这里可以使用递归的思想来处理。不断递归，直到第二步的结果为0，也就是说，没有在需要进位的位，就意味着计算完毕。</p><p>于是，加法可以使用异或和与运算实现。递归的C语言实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> add_xor = a ^b;</span><br><span class="line">    <span class="keyword">int</span> add_carry = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> add(add_xor, add_carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尾递归也可以很容易优化为迭代形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_by_loop</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add_xor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        add_xor = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = add_xor;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>实现了加法，接可以直接将减法视为加上它的逆元。对于以补码形式表示的有符号数来说，一个数x的逆元为<code>~x+1</code>。这是因为，对于一个w位的数x来说，x + ~x = 2^(w) - 1。所以 x + ~x + 1 = 2^(w) = 0（截断)。所以 ~x + 1为 x的逆元。</p><p>因此，减法可以如下实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, add(~b, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>abc * def 这种形式的乘法，实际上可以转化为加法和移位的结合。因为对于abc * def，实际上对于def中的每一位（例如e），都有对应个（e个）的abc相加，然后将结果提升当前位的权值（假如是十进制，对于e，提升10^1）。这样每一位运算的结果加起来，就是最终的结果。</p><p>二进制比十进制更简单，因为其每一位只可能为0或1，要么不加，要么加一次。</p><p>因此，乘法可以如下实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">            result = add_by_loop(result, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>除法则可以视为乘法的逆运算。对于二进制来说，从高到低的每一位，将除数提升到当前位的权值（即，乘以2^k，等同于左移k位），如果此时被除数扔大于除数，就说明结果在这个位上商1。然后从被除数减掉除数提升后的值。遍历每一位，即为最终的结果。</p><p>因此，除法可以这样实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a);</span><br><span class="line">    <span class="keyword">bool</span> flag = (a &lt; b)||(b &lt; <span class="number">0</span>);</span><br><span class="line">    a = (a &lt; <span class="number">0</span>)? -a:a;</span><br><span class="line">    b = (b &lt; <span class="number">0</span>)? -b:b;</span><br><span class="line">    <span class="comment">// 避开正负数表示形式不同这一点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sub(mul(length, <span class="number">8</span>), <span class="number">1</span>); i &gt;= <span class="number">0</span>; i = sub(i, <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>((a &gt;&gt; i) &gt;= b)&#123;</span><br><span class="line">        <span class="comment">// 这个地方使用 a 右移来比较，而不是将 b 左移的原因是因为:</span></span><br><span class="line">        <span class="comment">// 有符号数在机器中以补码的形式表示，首位为1的字将被诠释为负数，导致结果错误</span></span><br><span class="line">        <span class="comment">// 右移则可以回避这一点</span></span><br><span class="line">            result = add(result, <span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            a = sub(a, b &lt;&lt; i);</span><br><span class="line">            <span class="comment">// (a &gt;&gt; i) &gt;= b，意味着 b &lt;&lt; i 不会导致首位为1，所以可以直接运算</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag?-result:result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做除法，得到的不是精确结果，而是将真正值进行向下舍入的结果。这是因为，对于 p/q，我们的运算会产生一个结果a，和直到最后都没能减尽的b。p除以q等于a余b，即p=q*a+b，p/q=a+b/q，b &lt; q。即为a加一个小数，我们丢掉了这个小数，即向下舍入。（对于，负数结果来说，就成了向上舍入）。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>需要注意的是，减法只适用于数是用定长方法表示时的情况。因为求逆元用到了两个数相加后溢出截断的原理。因此，对于不定长表示的数，例如Python中的整数表示，无法得到正确的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加法&quot;&gt;&lt;a href=&quot;#加法&quot; class=&quot;headerlink&quot; title=&quot;加法&quot;&gt;&lt;/a&gt;加法&lt;/h2&gt;&lt;p&gt;加法可以拆分成几个步骤，首先是每位上的数对应相加，将结果与对应的基数取模，设置为当前位，然后处理相加之后产生进位的位，给它们的上一个拥有更大权值的位加上一，如果又产生进位，就如此循环，直到没有进位为止。&lt;br&gt;
    
    </summary>
    
    
      <category term="位运算" scheme="https://arianx.me/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>在python中延迟执行函数</title>
    <link href="https://arianx.me/2018/06/27/Simple-time-event-loop-in-python/"/>
    <id>https://arianx.me/2018/06/27/Simple-time-event-loop-in-python/</id>
    <published>2018-06-26T23:10:21.000Z</published>
    <updated>2018-06-27T00:40:29.268Z</updated>
    
    <content type="html"><![CDATA[<p>js有一个常用的函数叫做setTimeout，可以延迟函数的执行而又不阻塞当前上下文。这是一个奇特的行为，因为js本身运行在单线程中。因此，在某些时候，可以发现，js上下文中的函数会影响setTimeout排定函数的运行。例如，如果此时有一个while true的函数阻塞，传递给setTimeout的函数也永远不会执行。</p><p>在python中，也可以实现类似js 中setTimeout的行为。主要发现了以下几种方法：<br><a id="more"></a></p><h2 id="使用time-sleep函数"><a href="#使用time-sleep函数" class="headerlink" title="使用time.sleep函数"></a>使用time.sleep函数</h2><p>可以使用time.sleep沉睡一段时间，然后再调用函数。但这样同时也会阻塞当前上下文。可以考虑使用多线程封装time.sleep函数，让函数在多线程中执行，从而达到不阻塞上下文，又延迟执行的目的。</p><h2 id="使用threading-Timer函数"><a href="#使用threading-Timer函数" class="headerlink" title="使用threading.Timer函数"></a>使用threading.Timer函数</h2><p>threading.Timer函数可以指定一个延迟时间，传入的函数会在新线程指定的时间后运行。</p><p>给人的感觉就像是上面封装了time.sleep一样。可以这样用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SetTimeout</span><span class="params">(func, time, *args, **kwargs)</span>:</span></span><br><span class="line">    task = Timer(time, func, args=args, kwargs=kwargs)</span><br><span class="line">    task.start()</span><br><span class="line">    <span class="keyword">return</span> task</span><br></pre></td></tr></table></figure></p><h2 id="根据延迟时间轮询任务"><a href="#根据延迟时间轮询任务" class="headerlink" title="根据延迟时间轮询任务"></a>根据延迟时间轮询任务</h2><p>可能在多数情况下，我们的需求不只是让一个函数在给定的时间后延迟执行，并且还想同时排定多个任务，让它们按照给定的优先级（时间），依次执行。这种情况下，可以使用<code>优先队列</code>，不断轮询时间以查看是否有可以执行的任务。</p><p>想要阻塞当前上下文，让所有任务执行完毕后才开始继续执行接下来的任务，可以就在本线程轮询；想要不阻塞，就可以放在多线程中轮询，并且，因为多线程共享资源，所以还可以在轮询开始后继续添加新任务。</p><p>可以这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeEvent</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, plan_time, *args, **kwargs)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.plan_time = plan_time</span><br><span class="line">        self.args = args</span><br><span class="line">        self.kwargs = kwargs</span><br><span class="line">        self.result = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="comment"># For heap sort.</span></span><br><span class="line">        <span class="keyword">return</span> self.plan_time &lt; other.plan_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.alive = <span class="keyword">True</span></span><br><span class="line">        self.result = self.func(*self.args, **self.kwargs)</span><br><span class="line">        self.alive = <span class="keyword">False</span></span><br><span class="line">        self.over = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeEventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.events = []</span><br><span class="line">        self.alive = <span class="keyword">False</span></span><br><span class="line">        self.end = <span class="keyword">False</span></span><br><span class="line">        self.thread = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_event</span><span class="params">(self, func, time, *args, absolute=False, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> absolute:</span><br><span class="line">            plan_time = datetime.now() + timedelta(<span class="number">0</span>, time)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plan_time = time</span><br><span class="line">        event = TimeEvent(func, plan_time, *args, **kwargs)</span><br><span class="line">        heapq.heappush(self.events, event)</span><br><span class="line">        <span class="keyword">return</span> event</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        event = heapq.heappop(self.evnets) <span class="keyword">if</span> self.events <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> event <span class="keyword">and</span> event.plan_time &lt; datetime.now():</span><br><span class="line">            event.execute()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                event = heapq.heappop(self.events)</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> event:</span><br><span class="line">            heapq.heappush(self.events, event)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_take_loop</span><span class="params">(self, timeout)</span>:</span></span><br><span class="line">        self.alive = <span class="keyword">True</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.end:</span><br><span class="line">            self._loop()</span><br><span class="line">            <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> \</span><br><span class="line">                    <span class="keyword">and</span> time.time() - start_time &gt; timeout:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">        self.end = <span class="keyword">False</span></span><br><span class="line">        self.alive = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(self, timeout=None, in_thread=True)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> in_thread:</span><br><span class="line">            self.thread = Thread(target=self._take_loop, args=[timeout])</span><br><span class="line">            self.thread.start()</span><br><span class="line">            <span class="keyword">return</span> self.thread</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._take_loop(timeout)</span><br></pre></td></tr></table></figure></p><p>它和js 的setTimeout类似，如果前面有函数耽搁了时间，那后面的函数的执行时间也会被推迟。但是，能够保证在给定时间之前的所有函数都会被运行。</p><h2 id="使用异步"><a href="#使用异步" class="headerlink" title="使用异步"></a>使用异步</h2><p>使用python中的异步，也就是协程，也可以完成我们的需求。嗯……然而目前对这方面并不太熟悉_(:з)∠)_</p><p>或许可以这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'call &#123;&#125;'</span>.format(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(loop, callbacks)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> callback <span class="keyword">in</span> callbacks:</span><br><span class="line">        loop.call_later(<span class="number">0.2</span>, callback, <span class="number">1</span>)</span><br><span class="line">        loop.call_later(<span class="number">0.1</span>, callback, <span class="number">2</span>)</span><br><span class="line">        loop.call_soon(callback, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    event_loop = asyncio.get_event_loop()</span><br><span class="line">    event_loop.run_until_complete(main(event_loop, [hello]))</span><br><span class="line">    event_loop.close()</span><br></pre></td></tr></table></figure></p><p>会输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call <span class="number">3</span></span><br><span class="line">call <span class="number">2</span></span><br><span class="line">call <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="使用信号"><a href="#使用信号" class="headerlink" title="使用信号"></a>使用信号</h2><p>使用Signal信号模块，也可以完成类似行为。然而比协程更不熟悉……</p><p>看了相关内容后再来补充一波吧w</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>先就这样吧，也欢迎提供其它想法~</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/10154568/postpone-code-for-later-execution-in-python-like-settimeout-in-javascript" target="_blank" rel="noopener">stackoverflow 上的相关回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js有一个常用的函数叫做setTimeout，可以延迟函数的执行而又不阻塞当前上下文。这是一个奇特的行为，因为js本身运行在单线程中。因此，在某些时候，可以发现，js上下文中的函数会影响setTimeout排定函数的运行。例如，如果此时有一个while true的函数阻塞，传递给setTimeout的函数也永远不会执行。&lt;/p&gt;
&lt;p&gt;在python中，也可以实现类似js 中setTimeout的行为。主要发现了以下几种方法：&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://arianx.me/categories/python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LZ77编码简介</title>
    <link href="https://arianx.me/2018/06/26/LZ77-coding/"/>
    <id>https://arianx.me/2018/06/26/LZ77-coding/</id>
    <published>2018-06-26T07:56:46.000Z</published>
    <updated>2018-06-27T00:38:12.608Z</updated>
    
    <content type="html"><![CDATA[<p>LZ77是一个由Abraham Lempel于1977年发表的无损压缩算法，其思想与霍夫曼编码有很大差别。霍夫曼编码主要是用较短的编码代替出现频率较高的字符，用较长的编码代替出现频率较低的字符；LZ77编码的核心思想则是将重复出现的较长字符串（短语），使用较短的、指向前面第一次出现的字符串的标记来代替。标记与原序列之间是一种映射，因此，LZ77算法可以说成是基于字典的算法。<br><a id="more"></a></p><p>由于Python之中的位操作比较难弄，本文只实现了LZ77的编码解码部分，没有实现将编码内容写入文件、或者解码文件的部分。<del>日后用C实现一遍吧</del></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>LZ77算法的编码阶段将原序列分成几个部分。</p><p>第一个部分是<code>前向缓冲区(look ahead buffer)</code>。它是一个固定大小的普通数组。在序列编码的过程中，会将缓冲区最前面与后面将要提到的<code>滑动窗口(sliding window)</code>里相同的子序列弹出，进入滑动窗口，输出相应的编码，从源序列中读入后继的内容填充数组直到源序列读尽。</p><p>第二个部分是<code>滑动窗口(sliding window)</code>。也是一个固定大小的数组，不过其大小一般比前向缓冲区大很多。滑动窗口接受从前向缓冲区弹出的内容，并试图找到与缓冲区最前面的字串相同的<code>最长字串</code>。如果找到了，就会用指向窗口里子串的标记代替源来的字串。</p><p>第三个部分是编码部分。它根据前向缓冲区和滑动窗口运行的结果来生成。</p><p>LZ77编码的详细步骤如下。</p><ol><li>首先，将序列读入前向缓冲区。</li><li><p>指针指向第一个字符，查看是否与前向缓冲区内的第一个字符匹配。如果匹配：<br><br>- 设滑动窗口中的这个字符位于D，从这个字符开始，一一对比接下来滑动窗口中的字符与前向缓冲区的字符是否匹配，直到出现不匹配的字符为止。设匹配的字串长度为L，此时前向缓冲区匹配子串的后一个字符是c。<br><br>- 指针指向第二个字符，重复搜索，直到窗口尽头。<br><br>- 取最终L最大的那次为最终结果。如果始终没有找到匹配，D、L为0，c为缓冲区第一个字符。</p></li><li><p>返回（D, L, c)作为匹配序列的编码。然后从滑动窗口尾部删除L个字符，将前向缓冲区中的这L个匹配字符弹出，推入滑动窗口。</p></li><li>从源序列读入数据填充前向缓冲区，重复2，直到读尽数据。</li><li>将编码通过位操作的方式写入文件流。</li></ol><p>纯文字比较难以理解，看图可能更直观：</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-6-26/29889505.jpg" alt=""></p><p>由于会不断在前向缓冲区中搜索匹配的字串，所有编码过程比霍夫曼算法慢</p><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>解码过程是编码过程的逆向：</p><ol><li>将数据读入缓冲区。</li><li>如果缓冲区头部是普通字符，放入窗口；否则在窗口中搜寻对应字串后，将对应字串放入窗口。返回这个普通字符或字串作为一部分结果。</li><li>从缓冲区移除相应标记。继续读入。重复第二部直到结束。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a href="https://gist.github.com/Arianxx/d7b4640fe53f4798a4ef1b954c9f28b9" target="_blank" rel="noopener">https://gist.github.com/Arianxx/d7b4640fe53f4798a4ef1b954c9f28b9</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LZ77Coding</span>:</span></span><br><span class="line">    SLIDING_WINDOW_SIZE = <span class="number">4096</span></span><br><span class="line">    LOOKHEAD_BUFFER_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_longest_match</span><span class="params">(self, data, cursor)</span>:</span></span><br><span class="line">        best_position, best_length, next_char = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        search_index = max(cursor - self.SLIDING_WINDOW_SIZE, <span class="number">0</span>)</span><br><span class="line">        end_buffer_index = min(len(data) - <span class="number">1</span>,</span><br><span class="line">                               cursor + self.LOOKHEAD_BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> search_index &lt; cursor:</span><br><span class="line">            <span class="keyword">if</span> data[search_index] == data[cursor]:</span><br><span class="line">                length = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> (search_index + length) &lt; cursor \</span><br><span class="line">                        <span class="keyword">and</span> (cursor + length) &lt; end_buffer_index:</span><br><span class="line">                    <span class="keyword">if</span> data[search_index + length] == data[cursor + length]:</span><br><span class="line">                        length += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> length &gt; best_length:</span><br><span class="line">                    best_position = search_index</span><br><span class="line">                    best_length = length</span><br><span class="line">                    next_char = data[cursor + length]</span><br><span class="line"></span><br><span class="line">            search_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> best_length:</span><br><span class="line">            next_char = data[cursor]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best_position, best_length, next_char</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encoding</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cursor &lt; len(data):</span><br><span class="line">            match = self.search_longest_match(data, cursor)</span><br><span class="line">            result.append(match)</span><br><span class="line">            cursor += max(match[<span class="number">1</span>] + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decoding</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pair[<span class="number">1</span>]:</span><br><span class="line">                result.append(pair[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                chars = result[pair[<span class="number">0</span>]:pair[<span class="number">0</span>] + pair[<span class="number">1</span>]]</span><br><span class="line">                result.extend(chars)</span><br><span class="line">                result.append(pair[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(result)</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77" target="_blank" rel="noopener">维基百科</a></p><p><a href="https://github.com/LLcoolNJ/LZ77/blob/master/src/lz77.py" target="_blank" rel="noopener">python2 bitarray实现</a></p><p><a href="https://github.com/manassra/LZ77-Compressor/blob/master/src/" target="_blank" rel="noopener">另一个实现</a></p><p><a href="http://www.stringology.org/DataCompression/lz77/index_en.html" target="_blank" rel="noopener">过程讲解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LZ77是一个由Abraham Lempel于1977年发表的无损压缩算法，其思想与霍夫曼编码有很大差别。霍夫曼编码主要是用较短的编码代替出现频率较高的字符，用较长的编码代替出现频率较低的字符；LZ77编码的核心思想则是将重复出现的较长字符串（短语），使用较短的、指向前面第一次出现的字符串的标记来代替。标记与原序列之间是一种映射，因此，LZ77算法可以说成是基于字典的算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编码" scheme="https://arianx.me/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>实现霍夫曼编码</title>
    <link href="https://arianx.me/2018/06/24/Python-Huffman-Tree/"/>
    <id>https://arianx.me/2018/06/24/Python-Huffman-Tree/</id>
    <published>2018-06-24T07:44:23.000Z</published>
    <updated>2018-06-26T12:59:57.951Z</updated>
    
    <content type="html"><![CDATA[<p>霍夫曼编码是一种使用变长编码表编码源符号的无损压缩算法。它的核心思想是计算各个符号的权重，出现次数较多的符号拥有较大的权重，出现次数较少的符号拥有较小的权重。然后对符号进行前缀编码，用较短的编码表示拥有较长权重的符号，用较长的编码表示拥有较短权重的符号。这样，总体来说，对于符号出现次数不均衡的序列，霍夫曼编码就能够拥有较好的表现。</p><a id="more"></a><h2 id="压缩过程"><a href="#压缩过程" class="headerlink" title="压缩过程"></a>压缩过程</h2><p>霍夫曼编码的压缩阶段主要有以下几个步骤：</p><ol><li>读入符号，计算各个符号的权重。</li><li>根据符号的权重建立霍夫曼树。</li><li>依据霍夫曼树建立编码表。</li><li>压缩</li></ol><h3 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h3><p>计算权重很容易理解。遍历符号，计算各个符号出现的次数。把出现的次数当作权重即可。实际实现中，如果以字节为单位压缩，考虑到一个字节有8位，最大能表示255。为了操作方便，可以将出现的次数除以最大的出现次数，再乘以256当作权重。这样，所有权重就刚分布在一个字节的表示范围以内。</p><p>同时，考虑到一个字节的编码刚好是0~255，可以建立一个数组，这个数组的下标表示对应的符号，这个数组的值表示符号的权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_minimize_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 缩小字频使其在一个字节范围以内</span></span><br><span class="line">        max_freq = max(self.freqs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> symbol, freq <span class="keyword">in</span> enumerate(self.freqs):</span><br><span class="line">            scale_freq = int(self.BYTE_MAX_NUM * (freq / max_freq))</span><br><span class="line">            scale_freq = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> scale_freq <span class="keyword">and</span> freq <span class="keyword">else</span> scale_freq</span><br><span class="line"></span><br><span class="line">            self.freqs[symbol] = scale_freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_symbol_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> self.origin:</span><br><span class="line">            self.freqs[symbol] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self._minimize_frequencies()</span><br></pre></td></tr></table></figure><p>计算了各个符号的权重之后，就可以根据这些权重建立霍夫曼树。从霍夫曼树中，我们可以得到符号的前缀码表。</p><h3 id="建立霍夫曼树"><a href="#建立霍夫曼树" class="headerlink" title="建立霍夫曼树"></a>建立霍夫曼树</h3><p>霍夫曼树是一颗二叉树，其每个节点至少有四个值——符号，权重，左树指针，右树指针。建立霍夫曼树主要有两种方式。第一种是使用一个优先队列（堆）。首先，为所有的符号创造一个节点，储存进这个符号本身和它的权重。然后将所有的节点压入优先队列，拥有最低权重的节点拥有最高的优先级（即，低权重的节点会先被弹出。）然后执行以下步骤：</p><ol><li>如果优先队列中的元素大于一，弹出两个节点。以这两个节点为左右指针创建一颗新的霍夫曼树，其权重为作为节点之和。将这个新树压入优先队列。重复本步骤。</li><li>否则，弹出剩下的元素作为最终的霍夫曼树。</li></ol><p>除了优先队列外，还可以使用两个队列来建立霍夫曼树。首先，像前面那样创建节点，按照权重排序所有节点。然后创建两个队列，将节点按照权重从低到高的顺序依次入其中一个队列1。然后执行以下步骤：</p><ol><li>如果一个队列为空，从另一个队列中弹出两个元素；否则，比较两个队列首元素的权重，弹出权重最小的两个元素。用这两个元素作为子树建立一个新的霍夫曼树，其权重为两元素权重之和。将这颗新树压入队列2。重复本步骤，直到队列只剩下一个元素。</li><li>弹出这个元素作为最终的霍夫曼树。</li></ol><p>使用优先队列的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_initial_node_heap</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._heap = []</span><br><span class="line">        <span class="keyword">for</span> symbol, freq <span class="keyword">in</span> enumerate(self.freqs):</span><br><span class="line">            node = HuffmanNode(symbol, freq)</span><br><span class="line">            heapq.heappush(self._heap, node)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_huffman_tree</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._initial_node_heap()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(self._heap) &gt; <span class="number">1</span>:</span><br><span class="line">        node1 = heapq.heappop(self._heap)</span><br><span class="line">        node2 = heapq.heappop(self._heap)</span><br><span class="line"></span><br><span class="line">        new_node = HuffmanNode(symbol=<span class="keyword">None</span>, freq=node1.freq + node2.freq)</span><br><span class="line">        new_node.left, new_node.right = node1, node2</span><br><span class="line">        node1.parent, node2.parent = new_node, new_node</span><br><span class="line">        heapq.heappush(self._heap, new_node)</span><br><span class="line"></span><br><span class="line">    self.huffman_tree = heapq.heappop(self._heap)</span><br><span class="line">    <span class="keyword">del</span> self._heap</span><br><span class="line">    <span class="keyword">return</span> self.huffman_tree</span><br></pre></td></tr></table></figure></p><h3 id="建立编码表"><a href="#建立编码表" class="headerlink" title="建立编码表"></a>建立编码表</h3><p>根据得到的霍夫曼树，我们可以为符号建立一组前缀码。</p><p>如果一组编码，其中任意一个编码都不为另一个编码的前缀，那么我们就称这组编码为一组前缀码。将符号使用前缀码编码是极有意义的。这意味着，对于一组编码，我们可以不借助任何分割符解码其中的每一个符号。即，此时，这组编码是唯一可解的。</p><p>前面说过，霍夫曼树是一颗二叉树。因此，这颗二叉树的所有叶子节点的路径组成的编码即为一组前缀码。把左子树编码为0，将右子树编码为1。可以递归求出符号的编码表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_coding_table</span><span class="params">(self, node, code_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.symbol <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.coding_table[node.symbol] = code_str</span><br><span class="line">            self.reverse_table[code_str] = node.symbol</span><br><span class="line"></span><br><span class="line">        self._build_coding_table(node.left, code_str + <span class="string">'0'</span>)</span><br><span class="line">        self._build_coding_table(node.right, code_str + <span class="string">'1'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>把符号按照编码表替换为相应为即可。</p><p>如果用C语言实现，可以方便地直接对内存进行位操作。而Python的位操作比较麻烦。因此，可以先将所有二进制编码先视为字符串，然后每8位字符串转换为一个16进制数，转换为python中的bytes类型，直接写入文件即可。</p><p>将符号频率同编码一同写入文件，就可以在之后通过读取频率来解压。</p><p>替换过程核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_build_codeing_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> self.origin:</span><br><span class="line">            temp.append(self.coding_table[symbol])</span><br><span class="line">        self.coding_str = <span class="string">''</span>.join(temp)</span><br><span class="line"></span><br><span class="line">        self._pading_coding_str()</span><br><span class="line">        self._prefix_coding_freqs()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.coding_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span>(len(self.coding_str) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        b = bytearray()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.coding_str), <span class="number">8</span>):</span><br><span class="line">            code_num = int(self.coding_str[index:index + <span class="number">8</span>], <span class="number">2</span>)</span><br><span class="line">            b.append(code_num)</span><br><span class="line"></span><br><span class="line">        self.compressed = bytes(b)</span><br><span class="line">        <span class="keyword">return</span> self.compressed</span><br></pre></td></tr></table></figure></p><h2 id="解压过程"><a href="#解压过程" class="headerlink" title="解压过程"></a>解压过程</h2><p>解压过程较简单，是前面压缩过程的逆操作。</p><p>首先读取符号频率，根据符号频率建立霍夫曼树，然后再根据霍夫曼树解压编码即可。</p><p>核心解压代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_decode_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        real_coding_str = self._get_real_coding_from_compressed()</span><br><span class="line">        decode_content = []</span><br><span class="line"></span><br><span class="line">        node = self.huffman_tree</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> real_coding_str:</span><br><span class="line">            <span class="keyword">if</span> state == <span class="string">'0'</span>:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> state == <span class="string">'1'</span>:</span><br><span class="line">                node = node.right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.symbol <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">assert</span>(<span class="number">0</span> &lt;= node.symbol &lt;= self.BYTE_MAX_NUM)</span><br><span class="line">                hex_str = hex(node.symbol)[<span class="number">2</span>:]</span><br><span class="line">                <span class="comment"># fromhex方法将两个字符识别为一个16进制数</span></span><br><span class="line">                <span class="comment"># 所以单个数需要补零</span></span><br><span class="line">                hex_str = <span class="string">'0'</span> + hex_str <span class="keyword">if</span> len(hex_str) == <span class="number">1</span> <span class="keyword">else</span> hex_str</span><br><span class="line">                decode_content.append(hex_str)</span><br><span class="line">                node = self.huffman_tree</span><br><span class="line"></span><br><span class="line">        decode_content = <span class="string">''</span>.join(decode_content)</span><br><span class="line">        <span class="keyword">return</span> bytes.fromhex(decode_content)</span><br></pre></td></tr></table></figure></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>txt文本文件：</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-6-24/78951981.jpg" alt=""></p><p>mp3文件：</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-6-24/28880208.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Huffman_coding" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Huffman_coding</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://gist.github.com/Arianxx/603dc688a4b68f207ada2c4534758637" target="_blank" rel="noopener">https://gist.github.com/Arianxx/603dc688a4b68f207ada2c4534758637</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, symbol=None, freq=None)</span>:</span></span><br><span class="line">        self.symbol = symbol</span><br><span class="line">        self.freq = freq</span><br><span class="line">        self.parent = <span class="keyword">None</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.freq &lt; other.freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.left <span class="keyword">and</span> <span class="keyword">not</span> self.right</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_code</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 调试用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_laef():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Not a leaf node."</span>)</span><br><span class="line"></span><br><span class="line">        code = <span class="string">''</span></span><br><span class="line">        node = self</span><br><span class="line">        <span class="keyword">while</span> node.parent:</span><br><span class="line">            <span class="keyword">if</span> node.parent.left == node:</span><br><span class="line">                code = <span class="string">'0'</span> + code</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                code = <span class="string">'1'</span> + code</span><br><span class="line">            code = code.parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huffman</span>:</span></span><br><span class="line">    BYTE_MAX_NUM = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.origin = <span class="keyword">None</span></span><br><span class="line">        self.compressed = <span class="keyword">None</span></span><br><span class="line">        self.huffman_tree = <span class="keyword">None</span></span><br><span class="line">        self.freqs = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.BYTE_MAX_NUM + <span class="number">1</span>)]</span><br><span class="line">        self.coding_table = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.BYTE_MAX_NUM + <span class="number">1</span>)]</span><br><span class="line">        self.reverse_table = &#123;&#125;</span><br><span class="line">        self.coding_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_minimize_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 缩小字频使其在一个字节范围以内</span></span><br><span class="line">        max_freq = max(self.freqs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> symbol, freq <span class="keyword">in</span> enumerate(self.freqs):</span><br><span class="line">            scale_freq = int(self.BYTE_MAX_NUM * (freq / max_freq))</span><br><span class="line">            scale_freq = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> scale_freq <span class="keyword">and</span> freq <span class="keyword">else</span> scale_freq</span><br><span class="line"></span><br><span class="line">            self.freqs[symbol] = scale_freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_symbol_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> self.origin:</span><br><span class="line">            self.freqs[symbol] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self._minimize_frequencies()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initial_node_heap</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._heap = []</span><br><span class="line">        <span class="keyword">for</span> symbol, freq <span class="keyword">in</span> enumerate(self.freqs):</span><br><span class="line">            node = HuffmanNode(symbol, freq)</span><br><span class="line">            heapq.heappush(self._heap, node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_huffman_tree</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._initial_node_heap()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(self._heap) &gt; <span class="number">1</span>:</span><br><span class="line">            node1 = heapq.heappop(self._heap)</span><br><span class="line">            node2 = heapq.heappop(self._heap)</span><br><span class="line"></span><br><span class="line">            new_node = HuffmanNode(symbol=<span class="keyword">None</span>, freq=node1.freq + node2.freq)</span><br><span class="line">            new_node.left, new_node.right = node1, node2</span><br><span class="line">            node1.parent, node2.parent = new_node, new_node</span><br><span class="line">            heapq.heappush(self._heap, new_node)</span><br><span class="line"></span><br><span class="line">        self.huffman_tree = heapq.heappop(self._heap)</span><br><span class="line">        <span class="keyword">del</span> self._heap</span><br><span class="line">        <span class="keyword">return</span> self.huffman_tree</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_coding_table</span><span class="params">(self, node, code_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.symbol <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.coding_table[node.symbol] = code_str</span><br><span class="line">            self.reverse_table[code_str] = node.symbol</span><br><span class="line"></span><br><span class="line">        self._build_coding_table(node.left, code_str + <span class="string">'0'</span>)</span><br><span class="line">        self._build_coding_table(node.right, code_str + <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_pading_coding_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        pading_count = <span class="number">8</span> - len(self.coding_str) % <span class="number">8</span></span><br><span class="line">        self.coding_str += <span class="string">'0'</span> * pading_count</span><br><span class="line">        state_str = <span class="string">'&#123;:08b&#125;'</span>.format(pading_count)</span><br><span class="line">        self.coding_str = state_str + self.coding_str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prefix_coding_freqs</span><span class="params">(self)</span>:</span></span><br><span class="line">        coding_freqs = []</span><br><span class="line">        <span class="keyword">for</span> freq <span class="keyword">in</span> self.freqs:</span><br><span class="line">            coding_freqs.append(<span class="string">'&#123;:08b&#125;'</span>.format(freq))</span><br><span class="line">        coding_freqs = <span class="string">''</span>.join(coding_freqs)</span><br><span class="line">        self.coding_str = coding_freqs + self.coding_str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_codeing_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> self.origin:</span><br><span class="line">            temp.append(self.coding_table[symbol])</span><br><span class="line">        self.coding_str = <span class="string">''</span>.join(temp)</span><br><span class="line"></span><br><span class="line">        self._pading_coding_str()</span><br><span class="line">        self._prefix_coding_freqs()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.coding_str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span>(len(self.coding_str) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        b = bytearray()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>, len(self.coding_str), <span class="number">8</span>):</span><br><span class="line">            code_num = int(self.coding_str[index:index + <span class="number">8</span>], <span class="number">2</span>)</span><br><span class="line">            b.append(code_num)</span><br><span class="line"></span><br><span class="line">        self.compressed = bytes(b)</span><br><span class="line">        <span class="keyword">return</span> self.compressed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_read_frequencies_from_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        coding_freqs = self.compressed[:self.BYTE_MAX_NUM + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> index, freq <span class="keyword">in</span> enumerate(coding_freqs):</span><br><span class="line">            self.freqs[index] = freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_real_coding_from_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        pading_count = self.compressed[self.BYTE_MAX_NUM + <span class="number">1</span>]</span><br><span class="line">        byte_coding_str = self.compressed[self.BYTE_MAX_NUM + <span class="number">2</span>:]</span><br><span class="line">        coding_str = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> byte_coding_str:</span><br><span class="line">            temp = bin(num)[<span class="number">2</span>:]</span><br><span class="line">            <span class="comment"># 补足省略掉的前导零</span></span><br><span class="line">            temp = <span class="string">'0'</span> * (<span class="number">8</span> - len(temp)) + temp</span><br><span class="line">            <span class="keyword">assert</span>(len(temp) == <span class="number">8</span>)</span><br><span class="line">            coding_str.append(temp)</span><br><span class="line">        coding_str = <span class="string">''</span>.join(coding_str)</span><br><span class="line">        <span class="keyword">assert</span>(len(coding_str) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">        real_coding_str = coding_str[:-pading_count]</span><br><span class="line">        <span class="keyword">return</span> real_coding_str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_decode_compressed</span><span class="params">(self)</span>:</span></span><br><span class="line">        real_coding_str = self._get_real_coding_from_compressed()</span><br><span class="line">        decode_content = []</span><br><span class="line"></span><br><span class="line">        node = self.huffman_tree</span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> real_coding_str:</span><br><span class="line">            <span class="keyword">if</span> state == <span class="string">'0'</span>:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> state == <span class="string">'1'</span>:</span><br><span class="line">                node = node.right</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.symbol <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">assert</span>(<span class="number">0</span> &lt;= node.symbol &lt;= self.BYTE_MAX_NUM)</span><br><span class="line">                hex_str = hex(node.symbol)[<span class="number">2</span>:]</span><br><span class="line">                <span class="comment"># fromhex方法将两个字符识别为一个16进制数</span></span><br><span class="line">                <span class="comment"># 所以单个数需要补零</span></span><br><span class="line">                hex_str = <span class="string">'0'</span> + hex_str <span class="keyword">if</span> len(hex_str) == <span class="number">1</span> <span class="keyword">else</span> hex_str</span><br><span class="line">                decode_content.append(hex_str)</span><br><span class="line">                node = self.huffman_tree</span><br><span class="line"></span><br><span class="line">        decode_content = <span class="string">''</span>.join(decode_content)</span><br><span class="line">        <span class="keyword">return</span> bytes.fromhex(decode_content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, origin)</span>:</span></span><br><span class="line">        self.clear()</span><br><span class="line">        self.origin = origin</span><br><span class="line">        self._get_symbol_frequencies()</span><br><span class="line">        self._build_huffman_tree()</span><br><span class="line">        self._build_coding_table(self.huffman_tree)</span><br><span class="line">        self._build_codeing_str()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._get_compressed()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compresse</span><span class="params">(self, filename, output_filename=None)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            origin = file.read()</span><br><span class="line"></span><br><span class="line">        compressed_content = self.encode(origin)</span><br><span class="line">        <span class="keyword">if</span> output_filename <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            output_filename = filename + <span class="string">'.hfm'</span></span><br><span class="line">        <span class="keyword">with</span> open(output_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(compressed_content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self, compressed)</span>:</span></span><br><span class="line">        self.clear()</span><br><span class="line">        self.compressed = compressed</span><br><span class="line">        self._read_frequencies_from_compressed()</span><br><span class="line">        self._build_huffman_tree()</span><br><span class="line">        <span class="keyword">return</span> self._decode_compressed()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncompresse</span><span class="params">(self, filename, output_filename=None)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(filename, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            compressed = file.read()</span><br><span class="line"></span><br><span class="line">        decode_content = self.decode(compressed)</span><br><span class="line">        <span class="keyword">if</span> output_filename <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">'.hfm'</span>):</span><br><span class="line">                output_filename = filename[:<span class="number">-4</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output_filename = filename + <span class="string">'.dhfm'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(output_filename, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(decode_content)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;霍夫曼编码是一种使用变长编码表编码源符号的无损压缩算法。它的核心思想是计算各个符号的权重，出现次数较多的符号拥有较大的权重，出现次数较少的符号拥有较小的权重。然后对符号进行前缀编码，用较短的编码表示拥有较长权重的符号，用较长的编码表示拥有较短权重的符号。这样，总体来说，对于符号出现次数不均衡的序列，霍夫曼编码就能够拥有较好的表现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="编码" scheme="https://arianx.me/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>十种常见的排序方法</title>
    <link href="https://arianx.me/2018/06/22/Common-sort-algorithm/"/>
    <id>https://arianx.me/2018/06/22/Common-sort-algorithm/</id>
    <published>2018-06-22T11:48:09.000Z</published>
    <updated>2018-07-02T14:52:59.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍了十种常见简单排序算法的python实现。</p><p>将要介绍的这十种排序算法分别是——冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序、计数排序、基数排序、桶排序<br><a id="more"></a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>一遍遍遍历元素，两两交换其中不符合顺序的元素，将最大（或最小的）那个元素提取到最边缘的位置，直到不再有需要交换的元素为止。冒泡排序时常是排序算法中比较简单，也比较低效的一种排序方式。其时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[j], data[j + <span class="number">1</span>]):</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每一次遍历元素，都选择其余元素中最小或最大的那个元素，每一次都缩小遍历范围直到遍历完成。选择排序的时间复杂度仍然为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。即使如此，选择排序的性能要略优于冒泡排序。</p><p>实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[index], data[j]):</span><br><span class="line">                index = j</span><br><span class="line">        data[index], data[i] = data[i], data[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本思想是将一个数插入一个已经排好序的序列中，并且在插入后仍然保持有序。实现上将每个序列最开始的部分视为有序，然后依次将后面的元素插入前面的有序列表。直到遍历所有元素，即得到一个全部有序的列表。插入排序的时间复杂度仍为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。然而在数据量或数据基本有序时，插入排序将会拥有比冒泡和选择排序稍优异的性能。因此，经常将插入排序用作某些复合排序方法中的一部分。</p><p>实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ins_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(data):</span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[index - <span class="number">1</span>], data[index]):</span><br><span class="line">                data[index], data[index - <span class="number">1</span>] = data[index - <span class="number">1</span>], data[index]</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序基于插入排序。与插入排序每次比较交换最近的元素，依次向后遍历不同，希尔排序将序列分成几组，对这几组分别进行插入排序。然后缩小分组的间隔后再次分组，执行插入排序，直到分组间隔为1。可以看出，每一次分组，序列都将越来越有序，从而执行插入排序比较、交换的次数就会越来越少。因此，希尔排序的速度要优于O(n^2)，平均为O(nlog^2n)，最好为O(nlogn)。</p><p>从另一个方面看，排序的实质实际上是消除序列中的逆序数。冒泡、选择、插入等一次交换仅消除一个逆序数，而希尔排序一次交换会消除多个逆序数。因此希尔排序比普通插入排序更快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    gap = length // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length, gap):</span><br><span class="line">            current = data[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> i &gt;= gap <span class="keyword">and</span> <span class="keyword">not</span> compare(data[i - gap], current):</span><br><span class="line">                data[i] = data[i - gap]</span><br><span class="line">                i -= gap</span><br><span class="line"></span><br><span class="line">            data[i] = current</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是分治法的体现。每次排序都选择一个基准元素，将序列分成独立的两部分，一部分中的所有元素始终小于基准元素，另一部分中的所有元素始终大于基准元素。对这两部分序列分别进行快速排序，直到序列不可再分。此时序列即是有序的。快速排序的平均时间复杂度为<code>O(nlogn)</code>，最坏情况为<code>O(n^2)</code>，空间复杂度为<code>O(logn)</code>（递归）。</p><p>两种实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(data, begin=None, end=None, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">    begin = begin <span class="keyword">if</span> begin <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    end = end <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> (len(data) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> begin &gt;= end:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    key = randint(begin, end)</span><br><span class="line">    data[begin], data[key] = data[key], data[begin]</span><br><span class="line">    left = begin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(begin + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> compare(data[index], data[begin]):</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            data[left], data[index] = data[index], data[left]</span><br><span class="line">    data[left], data[begin] = data[begin], data[left]</span><br><span class="line"></span><br><span class="line">    quick_sort1(data, begin, left - <span class="number">1</span>)</span><br><span class="line">    quick_sort1(data, left + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序2</span></span><br><span class="line">quick_sort2 = <span class="keyword">lambda</span> data, compare=<span class="keyword">lambda</span> x, y: x &lt; y: \</span><br><span class="line">    data <span class="keyword">if</span> len(data) &lt; <span class="number">2</span> <span class="keyword">else</span> \</span><br><span class="line">    quick_sort2([a <span class="keyword">for</span> a <span class="keyword">in</span> data <span class="keyword">if</span> compare(a, data[<span class="number">0</span>])]) + \</span><br><span class="line">    [data[<span class="number">0</span>] * data.count(data[<span class="number">0</span>])] + \</span><br><span class="line">    quick_sort2([b <span class="keyword">for</span> b <span class="keyword">in</span> data <span class="keyword">if</span> compare(data[<span class="number">0</span>], b)])</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序同运用了分治法的思想。归并排序将数据分为两部分，对每部分序列一次运用归并排序，直到不可再分，然后将各部分有序序列组合起来。最终返回的即为有序序列。归并排序的时间复杂度是<code>O(nlogn)</code>。</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(data, i, j, k, compare)</span>:</span></span><br><span class="line">    new_data = []</span><br><span class="line">    data1, data2 = data[i:j + <span class="number">1</span>], data[j + <span class="number">1</span>:k + <span class="number">1</span>]</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; len(data1) <span class="keyword">and</span> b &lt; len(data2):</span><br><span class="line">        <span class="keyword">if</span> compare(data1[a], data2[b]):</span><br><span class="line">            new_data.append(data1[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_data.append(data2[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">    new_data.extend(data1[a:])</span><br><span class="line">    new_data.extend(data2[b:])</span><br><span class="line">    data[i:k + <span class="number">1</span>] = new_data</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(data, begin=None, end=None, compare=lambda x, y: x &lt; y)</span>:</span></span><br><span class="line">    begin = begin <span class="keyword">if</span> begin <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    end = end <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> (len(data) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> begin &lt; end:</span><br><span class="line">        mid = (begin + end) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        merge_sort(data, begin, mid, compare)</span><br><span class="line"></span><br><span class="line">        merge_sort(data, mid + <span class="number">1</span>, end, compare)</span><br><span class="line"></span><br><span class="line">        merge(data, begin, mid, end, compare)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>参见上一篇文章</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非比较的，稳定的线性时间排序算法。它将序列中的元素与一个数组中的位置对应。这个数组的下标是元素的值，这个位置储存的值是元素在新序列里所处于的位置。由n个元素组成，最大值为k的序列，首先构建一个长度为k的数组，遍历序列将它映射到数组之中，最后根据数组生成新的有序序列。因此，计数排序的时间复杂度与空间复杂度均为<code>O(n + k)</code>。</p><p>计数排序适用于容易将序列的值映射为整数，且跨度不太大的情况下。并且，序列排序经常被用于更复杂的排序（如基数排序）的基本排序方法。</p><p>实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(data, max_value=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param data: 要排序的可迭代对象</span></span><br><span class="line"><span class="string">    @param max: data里的最大值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_value = max_value <span class="keyword">if</span> max_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> max(data)</span><br><span class="line"></span><br><span class="line">    result = [<span class="keyword">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(data))]</span><br><span class="line">    position = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        position[value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, max_value + <span class="number">1</span>):</span><br><span class="line">        position[index] += position[index - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    n = len(data) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        value = data[n]</span><br><span class="line">        result[position[value] - <span class="number">1</span>] = value</span><br><span class="line">        position[value] -= <span class="number">1</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><!--MORE--><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序根据给定的基数，对序列元素的每一位依次进行计数排序。因为基数排序对p位元素的每一位都执行了计数排序，因此其时间复杂度为计数排序的p倍，即<code>O(p * (n + k))</code>。</p><p>与计数排序不同，只要可以将元素分成整形数字组成的几部分（如：字符串），就可以使用基数排序。</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(data, exp=<span class="number">10</span>, digit=<span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> pow</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param data: 待排序的可迭代对象</span></span><br><span class="line"><span class="string">    @param exp: 排序的基数</span></span><br><span class="line"><span class="string">    @param digit: 数据的最大位数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(digit):</span><br><span class="line">        result = [<span class="keyword">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(data))]</span><br><span class="line">        now_exp = pow(exp, e)</span><br><span class="line">        position = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(exp)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">            bit = int(value / now_exp) % exp</span><br><span class="line">            position[bit] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, exp):</span><br><span class="line">            position[index] += position[index - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        n = len(data) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            bit = int(data[n] / now_exp) % exp</span><br><span class="line">            result[position[bit] - <span class="number">1</span>] = data[n]</span><br><span class="line">            position[bit] -= <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        data = result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序将序列分到有限个数量的桶里，每个桶中的元素均处于某一个区间，对每个桶里的元素分别进行排序，最后再将每个桶组合起来。在序列中的值均匀分配的情况下，有n个元素，分到k个桶里，桶排序的时间复杂度为<code>O(n + k)</code>，空间复杂度为<code>O(n * k)</code>。</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(data, bucket_size=<span class="number">1</span>, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    min_value, max_value = int(min(data)), int(max(data))</span><br><span class="line">    bucket_count = (max_value - min_value) // bucket_size + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucket_count)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        buckets[(value - min_value) // bucket_size].append(value)</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        ins_sort(bucket, compare)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> bucket:</span><br><span class="line">            data[index] = value</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p><h2 id="各个排序算法的运行时间比较"><a href="#各个排序算法的运行时间比较" class="headerlink" title="各个排序算法的运行时间比较"></a>各个排序算法的运行时间比较</h2><p>分别测试了2000个元素和20000个随机元素下，各排序算法花费的时间：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(FAKE_COUNT=<span class="number">5000</span>, FAKE_RANGE=<span class="number">10000</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">    fake_data = [random.randint(<span class="number">0</span>, FAKE_RANGE) <span class="keyword">for</span> _ <span class="keyword">in</span> range(FAKE_COUNT)]</span><br><span class="line">    times = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    sort_methods = [bubble_sort, selection_sort, ins_sort, shell_sort,</span><br><span class="line">                    quick_sort1, quick_sort2, merge_sort, counting_sort,</span><br><span class="line">                    radix_sort, bucket_sort]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> method <span class="keyword">in</span> sort_methods:</span><br><span class="line"></span><br><span class="line">        start = time.time()</span><br><span class="line">        method(list(fake_data))</span><br><span class="line">        end = time.time()</span><br><span class="line"></span><br><span class="line">        times[method.__name__] = end - start</span><br><span class="line"></span><br><span class="line">    sorted_time = sorted(times, key=<span class="keyword">lambda</span> x: times[x])</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> sorted_time:</span><br><span class="line">        print(<span class="string">"&#123;key:&lt;15&#125;:&#123;time:&lt;20&#125;"</span>.format(key=key, time=times[key]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'COUNT:2000\tSIZE:2000'</span>)</span><br><span class="line">    compare(<span class="number">2000</span>, <span class="number">2000</span>)</span><br><span class="line">    print(<span class="string">'COUNT:20000\tSIZE:20000'</span>)</span><br><span class="line">    compare(<span class="number">20000</span>, <span class="number">20000</span>)</span><br></pre></td></tr></table></figure></p><p>结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">COUNT:2000      SIZE:2000</span><br><span class="line">counting_sort  :0.002000093460083008</span><br><span class="line">bucket_sort    :0.0020058155059814453</span><br><span class="line">&lt;lambda&gt;       :0.009976387023925781</span><br><span class="line">radix_sort     :0.014000892639160156</span><br><span class="line">quick_sort1    :0.017019033432006836</span><br><span class="line">merge_sort     :0.026001930236816406</span><br><span class="line">shell_sort     :0.32696533203125</span><br><span class="line">selection_sort :0.45195460319519043</span><br><span class="line">ins_sort       :0.9020371437072754</span><br><span class="line">bubble_sort    :1.868042230606079</span><br><span class="line"></span><br><span class="line">COUNT:20000     SIZE:20000</span><br><span class="line">counting_sort  :0.01299905776977539</span><br><span class="line">bucket_sort    :0.025992870330810547</span><br><span class="line">radix_sort     :0.08400774002075195</span><br><span class="line">&lt;lambda&gt;       :0.12100505828857422</span><br><span class="line">quick_sort1    :0.13498902320861816</span><br><span class="line">merge_sort     :0.1459970474243164</span><br><span class="line">shell_sort     :25.587008714675903</span><br><span class="line">selection_sort :43.999064207077026</span><br><span class="line">ins_sort       :70.03945851325989</span><br><span class="line">bubble_sort    :84.87412595748901</span><br></pre></td></tr></table></figure></p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>诶，六月炎炎近酷暑，吹着空调写代码╮（╯＿╰）╭</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文介绍了十种常见简单排序算法的python实现。&lt;/p&gt;
&lt;p&gt;将要介绍的这十种排序算法分别是——冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序、计数排序、基数排序、桶排序&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://arianx.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序简述</title>
    <link href="https://arianx.me/2018/06/17/Heap-in-python/"/>
    <id>https://arianx.me/2018/06/17/Heap-in-python/</id>
    <published>2018-06-17T14:28:59.000Z</published>
    <updated>2018-06-26T23:53:45.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种基于树的数据结构，其父节点总是大于（最大堆）或小于（最小堆）其子节点，并且其根节点总是树中最小（或最大）的那个节点。</p><p>堆排序常被用来实现<code>优先队列</code>，用于按给定的因子排定元素的优先级。而其本身最常采用的实现方式是扁平储存的二叉树。在二叉树实现的堆中，一个节点的兄弟节点并无特定的关系。唯一的关系存在于父节点和子结点中。<br><a id="more"></a></p><p>由于堆的二叉树总会是一个完全二叉树，且是用列表的方式扁平储存二叉树以实现堆，所以，在堆的列表中，序号为 n 的节点有以下几个特征：</p><ol><li>其父节点为 <code>(n - 1) // 2</code> （取整）。</li><li>其左子节点为 <code>n * 2 + 1</code>。</li><li>其右子节点为 <code>n * 2 + 2</code>。</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对堆执行插入操作，只需将其推入列表尾部，然后逐一与其父节点进行比较，如果逆序就交换。直到不再交换，则节点已经在正确为止。</p><p>关键代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_up</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        parent = self.parent(index)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.compare(self._heap[parent], self._heap[index]):</span><br><span class="line">                self._heap[parent], self._heap[index] = \</span><br><span class="line">                    self._heap[index], self._heap[parent]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            index = parent</span><br><span class="line">            parent = self.parent(index)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index == parent:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._heap.append(node)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        self.heap_up(self.size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><p>提取堆中最大的一个元素，只需提取第一个元素，然后用最后一个元素覆盖第一个元素。再逐一将这个元素与和这个元素差距最大的子元素比较，如果逆序就交换。直到不再交换为止，删除最后一个元素，返回提取出来的第一个元素。操作完毕。</p><p>关键代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">heap_down</span><span class="params">(self, index=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            child = self.max_child(index)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> child:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.compare(self._heap[child], self._heap[index]):</span><br><span class="line">                    self._heap[child], self._heap[index] = \</span><br><span class="line">                        self._heap[index], self._heap[child]</span><br><span class="line">                    index = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        top = self._heap[<span class="number">0</span>]</span><br><span class="line">        self._heap[<span class="number">0</span>] = self._heap[self.size - <span class="number">1</span>]</span><br><span class="line">        self.heap_down()</span><br><span class="line">        self._heap.pop()</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> top</span><br></pre></td></tr></table></figure></p><!--MORE--><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《算法精解-C语言描述》</p><p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heap_(data_structure</a>)</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>托管在gist上：</p><p><a href="https://gist.github.com/Arianxx/17d97f0bad4512aae483395bba46a5f9" target="_blank" rel="noopener">https://gist.github.com/Arianxx/17d97f0bad4512aae483395bba46a5f9</a></p><script src="https://gist.github.com/Arianxx/17d97f0bad4512aae483395bba46a5f9.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;堆是一种基于树的数据结构，其父节点总是大于（最大堆）或小于（最小堆）其子节点，并且其根节点总是树中最小（或最大）的那个节点。&lt;/p&gt;
&lt;p&gt;堆排序常被用来实现&lt;code&gt;优先队列&lt;/code&gt;，用于按给定的因子排定元素的优先级。而其本身最常采用的实现方式是扁平储存的二叉树。在二叉树实现的堆中，一个节点的兄弟节点并无特定的关系。唯一的关系存在于父节点和子结点中。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://arianx.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python中的AVL树</title>
    <link href="https://arianx.me/2018/06/17/python-avl-binary-tree/"/>
    <id>https://arianx.me/2018/06/17/python-avl-binary-tree/</id>
    <published>2018-06-16T23:17:17.000Z</published>
    <updated>2018-06-26T23:54:08.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今宵は雪月花</p></blockquote><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>将普通二叉树直接用于查找，平均情况下，仅需要查找一个分支，其时间复杂度为O(log n)。想要使查找时间尽可能短，就要使树的高度经可能短，使二叉树保持平衡状态。如果一个二叉树变得越来越不平衡，最后，其时间复杂度就变成了O(n)，相当于从头到尾遍历所有节点。<br><a id="more"></a></p><p>AVL是最先发明的一种自平衡二叉查找树，像普通二叉树一样组织数据。所不同的是，AVL的每一个节点都附带了一个<code>平衡因子</code>，其值代表了左子树和右子树的高度之差。对于每一次改变其平衡性的操作，AVL树都通过执行一次<code>旋转</code>操作来使其重新平衡。每一次插入和删除操作最多可能有<code>log n</code>个节点被旋转。因此，AVL树的插入、删除、查找操作的时间复杂度都在O(log n)。</p><p>下面使用python来实现AVL树。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>由普通二叉树的节点继承而来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvlNode</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The binary searching tree. Inherit from theo `Node` class.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        super().__init__(key)</span><br><span class="line">        self.height = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'AvlNode(key=&#123;key&#125;)'</span>.format(key=self.key)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_child_height</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The leaf node's height is 0. So the null node's height is -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> max(self.left.height <span class="keyword">if</span> self.left <span class="keyword">else</span> <span class="number">-1</span>,</span><br><span class="line">                   self.right.height <span class="keyword">if</span> self.right <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_height</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Search from this node to its ancestor node</span></span><br><span class="line"><span class="string">        until the height doesn't change.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        old_height = self.height</span><br><span class="line">        self.height = self.max_child_height + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.height != old_height <span class="keyword">and</span> self.parent:</span><br><span class="line">            self.parent.adjust_height()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The null node's height is deemed as -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.left.height <span class="keyword">if</span> self.left <span class="keyword">else</span> <span class="number">-1</span>) \</span><br><span class="line">            - (self.right.height <span class="keyword">if</span> self.right <span class="keyword">else</span> <span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p><p>普通二叉树的节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Pure binary tree's node.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Build the node instance.</span></span><br><span class="line"><span class="string">        @param key: The object that implements the __lt__ and __gt__ method.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.count = <span class="number">1</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.parent = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;key&#125;)'</span>.format(key=self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is the root node.(have not parent node)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.parent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is a leaf node.(have not any left or right point)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.left) <span class="keyword">and</span> <span class="keyword">not</span> bool(self.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_branch</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is a branch node.(have the left point or right point)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.left) ^ bool(self.right)</span><br></pre></td></tr></table></figure></p><p>与普通二叉树节点不同，AVL树的节点附带了树的高度信息，以此来判断这个节点是否处于平衡状态。如果这个节点的左子树与右子树高度差的绝对值大于1，就视这个节点为不平衡的，应该在稍后执行旋转操作。</p><p>并且AVL树的节点还又一个adjust_height方法，用于在进行一个会改变树高的操作后，重新计算这个节点所属的整个子树的高度，直到高度不再变化，代表调整完毕。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>AVL树的插入操作和普通二叉树类似。只不过在每一次插入后，需要重新计算子树高度（调用插入节点的adjust_height方法）。如果这次插入操作改变了树的平衡性，就需要旋转节点以使树重新平衡。</p><p>插入操作的关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, key, node=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Insert the key to the tree.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_node = super().insert(key, node=node)</span><br><span class="line">        <span class="keyword">if</span> new_node:</span><br><span class="line">            parent = new_node.parent</span><br><span class="line">            <span class="keyword">while</span> parent:</span><br><span class="line">                <span class="comment"># It has no effect on the node itself</span></span><br><span class="line">                <span class="comment"># but may change its parents' blance.</span></span><br><span class="line">                <span class="keyword">assert</span>(<span class="keyword">not</span> parent.is_leaf())</span><br><span class="line">                parent.height = parent.max_child_height + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> parent.balance <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                    self.rebalance(parent)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                parent = parent.parent</span><br></pre></td></tr></table></figure><p>这是AvlBiTree类的一个方法，用于为AVL数插入节点。它继承自代表普通二叉树的BiTree类。因此，这里的插入方法覆盖了BiTree的插入方法。在其中调用了父类的insert方法来普通插入节点。之后，再调整树的高度。并且逐一遍历其父节点查看平衡性是否受到破坏。如果平衡新被破坏，就调用rebalance方法旋转节点，使树重新平衡。</p><p>如果进行了一次rebalance旋转操作，代表已经消除了这次插入操作的副作用使树重新平衡。那么，其上所有祖先节点的平衡性都不受这次插入操作的影响。因此，break结束对祖先节点的遍历。代表本次插入操作完成。</p><h2 id="旋转结点使树重新平衡"><a href="#旋转结点使树重新平衡" class="headerlink" title="旋转结点使树重新平衡"></a>旋转结点使树重新平衡</h2><p>关键代表如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebalance</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Rotate the appointed node if the balance had been breaked.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node.balance == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> node.left.balance == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># LL rotate</span></span><br><span class="line">                self.__ll_rotate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(node.left.balance == <span class="number">-1</span>)</span><br><span class="line">                <span class="comment"># LR rotate</span></span><br><span class="line">                self.__lr_rotate(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span>(node.balance == <span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right.balance == <span class="number">-1</span>:</span><br><span class="line">                <span class="comment"># RR rotate</span></span><br><span class="line">                self.__rr_rotate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(node.right.balance == <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># RL rotate</span></span><br><span class="line">                self.__rl_rotate(node)</span><br></pre></td></tr></table></figure><p>可见，这实际上接近于一个调度方法，根据平衡性的情况，执行不同的旋转操作。</p><h2 id="具体旋转操作："><a href="#具体旋转操作：" class="headerlink" title="具体旋转操作："></a>具体旋转操作：</h2><!--MORE--><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><h4 id="ll"><a href="#ll" class="headerlink" title="ll"></a>ll</h4><p>如果插入一个节点后使得父节点（平衡性受到破坏的节点）的左节点的平衡性为 1（左子树高度大于右子树），需要对左子树进行一次旋转操作。</p><p>令父节点为A，左子节点为B，旋转步骤为：</p><ol><li>将A的左子树替换为B的右子树。</li><li>将B的右子树替换为A。</li><li>将指向A的节点执行B。</li></ol><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ll_rotate</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        SHOULDN'T be directly invoked by user in any cases.</span></span><br><span class="line"><span class="string">        It will lead to the breakings of the balance if pass a error node</span></span><br><span class="line"><span class="string">        which shouldn't be rotated.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        parent = node.parent</span><br><span class="line">        left = node.left</span><br><span class="line">        left_right = left.right</span><br><span class="line"></span><br><span class="line">        left.right = node</span><br><span class="line">        node.parent = left</span><br><span class="line"></span><br><span class="line">        node.left = left_right</span><br><span class="line">        <span class="keyword">if</span> left_right:</span><br><span class="line">            left_right.parent = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> parent:</span><br><span class="line">            self.root = left</span><br><span class="line">            left.parent = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> parent.left == node:</span><br><span class="line">                parent.left = left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(parent.right == node)</span><br><span class="line">                parent.right = left</span><br><span class="line">            left.parent = parent</span><br><span class="line"></span><br><span class="line">        node.adjust_height()</span><br><span class="line">        left.adjust_height()</span><br></pre></td></tr></table></figure></p><h4 id="lr"><a href="#lr" class="headerlink" title="lr"></a>lr</h4><p>如果插入一个节点后，使得父节点的左子树的平衡性为-1，那么，在左旋一次后，树依然是不平衡的，需要再进行一次左旋操作。</p><p>令父节点为A，A的左节点为B，B的右节点为C。<br>总体的步骤如下：</p><ol><li>将B的右节点替换为C的左节点。</li><li>将A的左节点替换为C的右节点。</li><li>将C的左节点替换为B。</li><li>将C的右节点替换为A。</li><li>将指向A的节点指向C。</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lr_rotate</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        parent = node.parent</span><br><span class="line">        left = node.left</span><br><span class="line">        left_right = left.right</span><br><span class="line"></span><br><span class="line">        left.right = left_right.left</span><br><span class="line">        <span class="keyword">if</span> left_right.left:</span><br><span class="line">            left_right.left.parent = left</span><br><span class="line"></span><br><span class="line">        left_right.left = left</span><br><span class="line">        left.parent = left_right</span><br><span class="line"></span><br><span class="line">        node.left = left_right.right</span><br><span class="line">        <span class="keyword">if</span> left_right.right:</span><br><span class="line">            left_right.right.parent = node</span><br><span class="line"></span><br><span class="line">        left_right.right = node</span><br><span class="line">        node.parent = left_right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> parent:</span><br><span class="line">            self.root = left_right</span><br><span class="line">            left_right.parent = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> parent.left == node:</span><br><span class="line">                parent.left = left_right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(parent.right == node)</span><br><span class="line">                parent.right = left_right</span><br><span class="line">            left_right.parent = parent</span><br><span class="line"></span><br><span class="line">        node.adjust_height()</span><br><span class="line">        left.adjust_height()</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><h4 id="rr"><a href="#rr" class="headerlink" title="rr"></a>rr</h4><p>如左旋的ll，只不过方向相反。</p><h4 id="rl"><a href="#rl" class="headerlink" title="rl"></a>rl</h4><p>如左旋的lr，只不过方向相反。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>和普通的二叉树相比，AVL树的删除操作稍显复杂，因为涉及到调整平衡性的问题。</p><p>不妨考虑以下四种情况</p><ul><li>如果删除的是叶子节点。<ul><li>如果删除的是叶子节点（没有左右子节点），直接删除。这个节点（None)的平衡性不受影响。</li></ul></li><li>如果删除的是分支节点。<ul><li>如果删除的是分支上的节点（有左右子节点中的一个），将其替换为它的那个子节点。这个节点（子节点）的平衡性不受影响。</li></ul></li><li>如果删除的节点有两个子节点<ul><li>如果删除的节点有两个子节点。如果其左子树的高度大于右子树，取其左子树上最大的那个节点；如果其右子树的高度大于左子树，取其右子树上最小的那个节点。然后用取的节点替换当前节点。最后，再删除取的那个节点。这样，这个节点（取的节点）的平衡性不受影响。</li></ul></li><li>如果要删除的不是本节点<ul><li>如果要删除的节点不是本节点，而是本节点的子节点。那么，本节点的平衡性可能回受影响，在删除操作完毕后，需要对其进行重新平衡（旋转）操作。</li></ul></li></ul><p>可以看出，实际上，可以用类似递归的方法处理删除操作。关键代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Directly remove the node no matter how many counts in the node.</span></span><br><span class="line"><span class="string">        @param node: the node in this tree which will be removed later.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        parent = node.parent</span><br><span class="line">        <span class="keyword">if</span> node.is_leaf():</span><br><span class="line">            self.__remove_leaf(node)</span><br><span class="line">        <span class="keyword">elif</span> node.is_branch():</span><br><span class="line">            self.__remove_branch(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span>(node.left <span class="keyword">and</span> node.right)</span><br><span class="line">            self.__remove_node(node)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> parent:</span><br><span class="line">                <span class="comment"># Remove the node will lead the breakings of</span></span><br><span class="line">                <span class="comment"># the balance on its parent node.</span></span><br><span class="line">                <span class="comment"># So reset the balance then remove it.</span></span><br><span class="line">            parent.height = parent.height - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> parent.balance <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                self.rebalance(parent)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            parent = parent.parent</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《算法精解-C语言描述》</p><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/AVL%E6%A0%91</a></p><p><a href="http://www.cnblogs.com/linxiyue/p/3659448.html" target="_blank" rel="noopener">http://www.cnblogs.com/linxiyue/p/3659448.html</a></p><p><a href="https://segmentfault.com/a/1190000007054898" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007054898</a></p><h2 id="AVL树python实现的完整代码"><a href="#AVL树python实现的完整代码" class="headerlink" title="AVL树python实现的完整代码"></a>AVL树python实现的完整代码</h2><p>放在了github gist里，可能需要vpn:</p><p><a href="https://gist.github.com/Arianxx/5226596ee425a6ee0b1be074a7f85d13" target="_blank" rel="noopener">https://gist.github.com/Arianxx/5226596ee425a6ee0b1be074a7f85d13</a></p><script src="https://gist.github.com/Arianxx/5226596ee425a6ee0b1be074a7f85d13.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今宵は雪月花&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;p&gt;将普通二叉树直接用于查找，平均情况下，仅需要查找一个分支，其时间复杂度为O(log n)。想要使查找时间尽可能短，就要使树的高度经可能短，使二叉树保持平衡状态。如果一个二叉树变得越来越不平衡，最后，其时间复杂度就变成了O(n)，相当于从头到尾遍历所有节点。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://arianx.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python在异常捕获里抛出异常</title>
    <link href="https://arianx.me/2018/06/07/The-usage-of-the-raise-from-in-python/"/>
    <id>https://arianx.me/2018/06/07/The-usage-of-the-raise-from-in-python/</id>
    <published>2018-06-07T14:50:17.000Z</published>
    <updated>2018-06-26T13:00:50.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python2异常对象"><a href="#python2异常对象" class="headerlink" title="python2异常对象"></a>python2异常对象</h2><p>有时，我们需要在捕获一个异常之后，在捕获的语句里面抛出另外一个异常。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError(e)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: division by zero</span><br></pre></td></tr></table></figure></p><p>上面在捕获除零异常后，重新在处理语句里抛出了ValueError，并将除零异常的信息传给了ValueError。同时，可以发现抛出的信息还附带了追踪信息，可以看到异常的抛出顺序。</p><p>然而，在python2里，从一个异常捕获中直接抛出另一个异常，并不会附带追踪信息：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p><p>python2异常抛出语句的语法是：raise exc, value, traceback。第一个参数是Exception的子类或子类的实例，第二个参数是初始化异常的信息，第三个参数是traceback对象。</p><p>python2中，可以通过这种方式看到traceback：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            foo()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            foo()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> RuntimeError(e), <span class="keyword">None</span>, sys.exc_info()[<span class="number">2</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> bar</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</span><br><span class="line">RuntimeError: integer division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure></p><p>python3简化了异常抛出语句的语法，不再支持python2抛出三元素元组的方式，而是简化为了一个exception参数。例如，在python2中原来有多个语句实现同一个异常抛出效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise RuntimeError, ValueError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: &lt;type &apos;exceptions.ValueError&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; raise RuntimeError(ValueError)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: &lt;type &apos;exceptions.ValueError&apos;&gt;</span><br></pre></td></tr></table></figure><p>这显然违背了python之禅里”There should be one– and preferably only one –obvious way to do it”的理念。</p><h2 id="python3异常对象"><a href="#python3异常对象" class="headerlink" title="python3异常对象"></a>python3异常对象</h2><p>所以，在python3中，不再支持元组的形式的异常抛出，只支持抛出Exception的子类或实例。如果是子类，就无参数调用得到实例再抛出；如果是实例则直接抛出。并且，python3为异常对象新增加了几种特殊方法。例如，增加了<code>__context__</code>方法，用于在多重异常抛出中保留以前异常的抛出信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    print(e.__context__)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    a = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            a[<span class="number">1</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            print(e.__context__)</span><br><span class="line">...</span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure></p><p>python3的异常对象还增加了<code>__traceback__</code>信息，用于在多重异常抛出中记录以前的抛出信息，从而简化了多重异常抛出的操作。在python3中，可以通过使用raise…from…语法快速指定traceback对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError <span class="keyword">from</span> e</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p><p>可以看到不单附带了跟踪信息，还有“The above exception was the direct cause of the following exception”这句指明了异常之间的关系。</p><p>并且，在python3中，即使不使用raise … from …语法，默认也附带了追踪信息，保存在<code>__context__</code>中，以”during handling another exception happened”的形式展现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p><p>还可以通过异常对象的with_traceback方法指定traceback对象，这种方法的提示语句如上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError.with_traceback(e)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: division by zero</span><br></pre></td></tr></table></figure></p><h2 id="cause-属性"><a href="#cause-属性" class="headerlink" title="__cause__属性"></a><code>__cause__</code>属性</h2><p>实际上，在使用 raise … from … 语法时，一个名为 <code>__cause__</code>的属性就被赋给异常对象，这个属性直接指明了异常发生的原因。当<code>__cause__</code>被设置的时候，<code>__suppress_context__</code>方法也会被同时设置为True。如果<code>__suppress_context__</code>被设置为True，在打印traceback信息时，<code>__context__</code>就会被忽略。</p><p>所以，如果在某些时候，想要忽略多重异常抛出中的上层的异常信息，可以使用 raise … from None来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p><p>可以发现上层的ZeroDivisionError被忽略了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有一种常见的python编程风格，叫做<code>EAFP(easier to ask for forgiveness than permissino，取得原谅比获得许可容易)</code>。先假定方法存在直接调用，如果不存在就捕获异常。这种方法简明轻快，体现出了python的鸭子类型和松散协议。</p><p>这种方法的特点就是代码块中有较多的try和except关键字。灵活运用异常，能够更得心应手的使用这种风格编程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/24752395/python-raise-from-usage" target="_blank" rel="noopener">https://stackoverflow.com/questions/24752395/python-raise-from-usage</a></p><p><a href="https://mozillazg.com/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html#hidid1" target="_blank" rel="noopener">https://mozillazg.com/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html#hidid1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python2异常对象&quot;&gt;&lt;a href=&quot;#python2异常对象&quot; class=&quot;headerlink&quot; title=&quot;python2异常对象&quot;&gt;&lt;/a&gt;python2异常对象&lt;/h2&gt;&lt;p&gt;有时，我们需要在捕获一个异常之后，在捕获的语句里面抛出另外一个异常。例如：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;except&lt;/span&gt; ZeroDivisionError &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; e:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; ValueError(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ZeroDivisionError: division by zero&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;During handling of the above exception, another exception occurred:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ValueError: division by zero&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面在捕获除零异常后，重新在处理语句里抛出了ValueError，并将除零异常的信息传给了ValueError。同时，可以发现抛出的信息还附带了追踪信息，可以看到异常的抛出顺序。&lt;/p&gt;
&lt;p&gt;然而，在python2里，从一个异常捕获中直接抛出另一个异常，并不会附带追踪信息：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://arianx.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>内省python元类执行流程</title>
    <link href="https://arianx.me/2018/05/31/meta-programming-explore/"/>
    <id>https://arianx.me/2018/05/31/meta-programming-explore/</id>
    <published>2018-05-31T12:44:06.000Z</published>
    <updated>2018-06-26T13:01:23.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一篇文章里面曾简短提到了在python中使用type类可以实现元编程。实际上，在python，存在几种类型的元编程，包括使用装饰器动态修改类或函数的功能、使用魔术方法重写python内置操作符的行为等，还有使用元类在运行时动态的创建和修改类。本文主要探讨python中使用元类进行元编程时，其中类方法的调用顺序和流程的问题。我想理解了这一点就会对使用元类有更深一点的认知。<br><a id="more"></a></p><h2 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h2><p>然而，究竟什么是<code>元类</code>？要理解这一点，就需要理解python独特的动态语言特性。在python中，一切都被视为对象。对象的一大特性就是可以在程序运行时，根据不同的上下文而创建。那么，依照这种思想，类也应该是一种对象。把类视为一种对象，在程序运行时，像对象那样动态创建或修改，这种行为就是元编程的一种。能够在程序运行时动态<code>创建或修改类的类</code>就被称为<code>元类</code>。</p><p>所有的对象都由某个类构造而来，那么对于元类，因该由哪种类构造而来呢？在python中，这个类就是type。所有的类都是type的实例，这实际上蕴含了一个思想，所有类都可以<code>看作</code>(只是看作)由type类创建而来的。type是一个类，这个类在运行时构造了另外的类。type类是python内置的一个元类。所以，藉继承type类，我们就可以创建出自己的元类。</p><p>一个简单的示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 在声明中使用metaclass指定元类，就会用指定的元类来构建类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(metaclass=MetaClass)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SubClass.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MetaClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">MetaClass</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个简单的元类示例什么都没有做，但它体现出了python元编程的一些特性。SubClass的<code>__class__</code>属性变为了MetaClass，表明这个类是由MetaClass类，而不是通常的type类所构造的。同时，可以看到我们自定义的元类是type的子类。</p><h2 id="一些与元类编程相关的特殊方法"><a href="#一些与元类编程相关的特殊方法" class="headerlink" title="一些与元类编程相关的特殊方法"></a>一些与元类编程相关的特殊方法</h2><p>在了解真正使用元类编程的方法之前，需要预备一些知识——一些与构造类有关的特殊方法。</p><h3 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__方法"></a><code>__new__</code>方法</h3><p><code>__new__</code>方法是一个静态方法。当调用类构造一个实例时，这个实例就是由<code>__new__</code>方法产生。<code>__new__</code>方法的第一个参数是调用的类本身。</p><h3 id="init-方法："><a href="#init-方法：" class="headerlink" title="__init__方法："></a><code>__init__</code>方法：</h3><p><code>__init__</code>方法修饰将要构造的实例。在返回实例之前做一些初始化工作。</p><h3 id="call-方法："><a href="#call-方法：" class="headerlink" title="__call__方法："></a><code>__call__</code>方法：</h3><p>当调用一个实例时，会尝试调用它的构造类（及父类）的<code>__call__</code>方法。</p><h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">'Success'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetUp</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用超类中的__new__方法得到将要产生的子类对象。</span></span><br><span class="line">        sub_cls = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> sub_cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 根据外部信息修饰子类</span></span><br><span class="line">        self._info = info</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用子类产生实例，实际上是调用了元类中的__call__方法。这里使用这一点实现单例模式。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> getattr(cls, <span class="string">'_instance'</span>, <span class="keyword">None</span>):</span><br><span class="line">            cls._instance = cls.__new__(cls)</span><br><span class="line">            cls.__init__(cls._instance, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcuteClass</span><span class="params">(metaclass=SetUp)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 只会被打印一次。</span></span><br><span class="line">        print(<span class="string">'Info is: '</span>, self._info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">excute1 = ExcuteClass()</span><br><span class="line">excute2 = ExcuteClass()</span><br><span class="line">print(excute1 == excute2)</span><br></pre></td></tr></table></figure><p>执行结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Info <span class="keyword">is</span>:  Success</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>这个例子展示了元类的一些动态特性。在这里第一个<code>info = &#39;Success&#39;</code>可以看作随上下文不同而变化的信息，元类SetUp根据这个信息的不同将会创建蕴含不同信息的子类。同时，元类本身通过<code>__call__</code>方法干涉了子类实例的创建，实际上实现了<code>单例模式</code>。在这里，子类只会被初始化一次，只会产生一个实例。</p><h2 id="内省执行流程"><a href="#内省执行流程" class="headerlink" title="内省执行流程"></a>内省执行流程</h2><p>那么，使用元类时，详细的顺序究竟是怎么样的呢？先后调用了哪些方法？刚接触元类时，或许许多人都会有这些疑惑。幸亏得益于python强大的动态性，我们可以在运行时方便的内省程序的状况。</p><p>可以藉由下面的程序观察到元类的执行流程：<br><!--MORE--><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self_explain</span><span class="params">(ob)</span>:</span></span><br><span class="line">    <span class="comment"># 内省传入的对象</span></span><br><span class="line">    pre_space = <span class="string">' '</span> * <span class="number">3</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 内省类名。只有类才有 __name__ 属性。</span></span><br><span class="line">        print(pre_space, <span class="string">'Class named `&#123;ob.__name__&#125;`.'</span>.format(ob=ob))</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(pre_space, <span class="string">'Have not class name.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 内省基对象。只有类才有 __obses__ 属性。</span></span><br><span class="line">        print(pre_space, <span class="string">'Inherits from `&#123;&#125;`.'</span>.format(</span><br><span class="line">            [base.__name__ <span class="keyword">for</span> base <span class="keyword">in</span> ob.__bases__]</span><br><span class="line">        ))</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(pre_space, <span class="string">'Have not bases class.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 类和实例都有 __class__ 属性。</span></span><br><span class="line">        print(pre_space, <span class="string">'Instance of `&#123;ob.__class__&#125;`.'</span>.format(ob=ob))</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(pre_space, <span class="string">'Have not parent class.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后内省对象的 id。相同的对象具有相同的id。</span></span><br><span class="line">    print(pre_space, <span class="string">"My id is &#123;&#125;."</span>.format(id(ob)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">explain</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">internal_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 因为这里用第一个参数的 __class__ 属性来判断其执行在哪个类里。这种方式</span></span><br><span class="line">        <span class="comment"># 默认第一个参数是这个类的实例，然而在 __new__ 方法里，第一个</span></span><br><span class="line">        <span class="comment"># 参数是类本身，其 __class__ 属性是 type，无法反映流程情况。所以如果判断在 __new__ 方法里，</span></span><br><span class="line">        <span class="comment"># 就直接调用 __new__ 将第一个参数（类本身）实例化，访问其 __class__ 属性得到类名。</span></span><br><span class="line">        <span class="comment"># 使用这种方法而不访问 __new__ 里第一个参数的 __name__ 方法的原因是，这样做，</span></span><br><span class="line">        <span class="comment"># 之后就能像对待普通方法一样对待 __new__，内省程序的执行情况。</span></span><br><span class="line">        in_new = func.__name__ == <span class="string">'__new__'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> in_new:</span><br><span class="line">            self = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果在 __new__ 里，调用 __new__ 得到实例。</span></span><br><span class="line">            self = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'In &#123;func.__name__&#125; of &#123;self.__class__&#125;.'</span></span><br><span class="line">              .format(func=func, self=self))</span><br><span class="line">        print(<span class="string">'Inspect first argument:'</span>)</span><br><span class="line">        self_explain(args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> in_new:</span><br><span class="line">            <span class="comment"># 如果在 __new__ 方法里，因为之前已经构造过了，直接返回。</span></span><br><span class="line">            return_value = self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            return_value = func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Inspect return value:'</span>)</span><br><span class="line">        self_explain(return_value)</span><br><span class="line">        print(<span class="string">'_'</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> return_value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> internal_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootClass</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># __new__ 方法是静态方法。</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(RootClass, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super(RootClass, self).__call__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(metaclass=RootClass)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(SubClass, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @explain</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'You call the SubClass instance.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fmt_str = <span class="string">'\n&#123;:_^64&#125;\n'</span></span><br><span class="line"></span><br><span class="line">    print(fmt_str.format(<span class="string">'Start excution'</span>))</span><br><span class="line"></span><br><span class="line">    print(fmt_str.format(<span class="string">'Instantiate the SubClass.'</span>))</span><br><span class="line">    instance = SubClass()</span><br><span class="line"></span><br><span class="line">    print(fmt_str.format(<span class="string">'Invoke the instance.'</span>))</span><br><span class="line">    instance()</span><br></pre></td></tr></table></figure></p><p>这段简单的程序主要用一个装饰器来内省了元类与子类中的调用信息与参数、返回值状况。</p><p>其执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">In __new__ of &lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Class named `RootClass`.</span><br><span class="line">    Inherits <span class="keyword">from</span> `[<span class="string">'type'</span>]`.</span><br><span class="line">    Instance of `&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281002834456.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Class named `SubClass`.</span><br><span class="line">    Inherits <span class="keyword">from</span> `[<span class="string">'object'</span>]`.</span><br><span class="line">    Instance of `&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281002701784.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">__init__</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Class named `SubClass`.</span><br><span class="line">    Inherits <span class="keyword">from</span> `[<span class="string">'object'</span>]`.</span><br><span class="line">    Instance of `&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281002701784.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 1939641552.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">_________________________Start</span> <span class="title">excution_________________________</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">___________________Instantiate</span> <span class="title">the</span> <span class="title">SubClass</span>.<span class="title">____________________</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">__call__</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Class named `SubClass`.</span><br><span class="line">    Inherits <span class="keyword">from</span> `[<span class="string">'object'</span>]`.</span><br><span class="line">    Instance of `&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281002701784.</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">__new__</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Class named `SubClass`.</span><br><span class="line">    Inherits <span class="keyword">from</span> `[<span class="string">'object'</span>]`.</span><br><span class="line">    Instance of `&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">RootClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281002701784.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281036607104.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">__init__</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281036607104.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 1939641552.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281036607104.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">______________________Invoke</span> <span class="title">the</span> <span class="title">instance</span>.<span class="title">______________________</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">__call__</span> <span class="title">of</span> &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">first</span> <span class="title">argument</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">SubClass</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 2281036607104.</span></span><br><span class="line"><span class="class"><span class="title">You</span> <span class="title">call</span> <span class="title">the</span> <span class="title">SubClass</span> <span class="title">instance</span>.</span></span><br><span class="line"><span class="class"><span class="title">Inspect</span> <span class="title">return</span> <span class="title">value</span>:</span></span><br><span class="line">    Have <span class="keyword">not</span> <span class="class"><span class="keyword">class</span> <span class="title">name</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Have</span> <span class="title">not</span> <span class="title">bases</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class">    <span class="title">Instance</span> <span class="title">of</span> `&lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;`.</span></span><br><span class="line"><span class="class">    <span class="title">My</span> <span class="title">id</span> <span class="title">is</span> 1939641552.</span></span><br><span class="line"><span class="class"><span class="title">________________________________</span></span></span><br></pre></td></tr></table></figure></p><p>可以看出，在程序开始时，执行我们if后的语句前，先自动执行了创建子类的操作。</p><p>创建子类首先调用了元类 RootClass 的 <code>__new__</code>方法，其第一个参数是元类本身，然后返回了一个类，其 <code>__name__</code>属性为子类 SubClass，是 RootClass的实例。显然这个类就是我们需要的子类。创建子类后，调用了元类 RootClass的 <code>__init__</code>方法，其第一个参数是我们刚才创建出的子类，然后返回None（不返回值）。</p><p>接着，开始执行if后的语句，首先我们实例化了子类。</p><p>实例化子类时，首先调用了元类里的<code>__call__</code> 方法，其第一个参数是子类本身。然后，接着调用了子类的 <code>__new__</code> 和 <code>__init__</code> 方法，显然是在 <code>__call__</code> 方法里，使用传入的子类调用的。然后，返回了子类的实例。</p><p>最后，调用实例时，调用了子类里的 <code>__call__</code>方法，其第一个参数是实例，不返回值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，我们可以得出元类时，各方法的实行顺序如下：</p><ul><li>构建子类：<ul><li>元类:<ul><li><code>__new__</code>(元类， …)</li><li><code>__init__</code>(子类，…)</li></ul></li></ul></li><li>实例子类：<ul><li>元类：<ul><li><code>__call__</code>(子类，…)</li><li>子类：<ul><li><code>__new__</code>(子类，…)</li><li><code>__init__</code>(实例，…)</li></ul></li></ul></li></ul></li><li>调用实例：<ul><li>子类：<ul><li><code>__call__</code>(实例)</li></ul></li></ul></li></ul><p>最后，实际上，上面的装饰器根据并不知道将要接受什么样的对象，只是在调用了相应的接口，根据参数的不同自动执行了不同的动作。这在无意间利用了python推崇的<code>鸭子类型</code>这一点风格，也就是其它语言的<code>多态</code>。不需要有严格的继承机制，只要关注其实现的接口；不关注其类型本身，而关注其具体的使用方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;上一篇文章里面曾简短提到了在python中使用type类可以实现元编程。实际上，在python，存在几种类型的元编程，包括使用装饰器动态修改类或函数的功能、使用魔术方法重写python内置操作符的行为等，还有使用元类在运行时动态的创建和修改类。本文主要探讨python中使用元类进行元编程时，其中类方法的调用顺序和流程的问题。我想理解了这一点就会对使用元类有更深一点的认知。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://arianx.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python中type和object</title>
    <link href="https://arianx.me/2018/05/31/type-and-object-explore/"/>
    <id>https://arianx.me/2018/05/31/type-and-object-explore/</id>
    <published>2018-05-31T09:50:25.000Z</published>
    <updated>2018-06-26T13:01:50.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一生一代一双人</p></blockquote><h2 id="type和object"><a href="#type和object" class="headerlink" title="type和object"></a>type和object</h2><p>python中内置了两个类，type和object，用isinstance和issubclass测试这两个类会发现一些奇怪的特性，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object是自身的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object也是type的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type是自身的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type是object的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object是自身的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object不是type的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, type)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="comment"># type是自身的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type也是object的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>可以看到，在这里面，type和object互为实例和子类，只有一个例外。而平时，在我们编写程序的过程中，也时常会注意到我们自己的类会有一些属性指向type和object，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Foo</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">object</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><p>那么，type和object这两个类有怎样的区别和联系呢？本文将探讨一些这方面的内容。</p><h2 id="继承和实例化"><a href="#继承和实例化" class="headerlink" title="继承和实例化"></a>继承和实例化</h2><p>类的继承和实例化是编程语言的面向对象特性里面重要的两个方面，对于拥有一切皆是对象语言的python，自然也对其有良好的实现。并且得益于python动态语言的性质，我们可以在程序运行时方便的内省对象的各项属性，如上的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看到，对象的<code>__class__</code>属性实际上表明了这个对象有哪个类实例化而来。前面说到，在python中，一切皆是对象，类也是一种对象，那么，作为对象的类也拥有<code>__class__</code>属性。而作为对象的类，其<code>__class__</code>属性指向的 type，就表明，这些类是由 type这个元类构建而来。</p><p>而<code>__base__</code>属性的特性如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Bar.__base__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以看到<code>__base__</code>属性实际上指向一个类的父类。如果一个类继承了另一个类，那么这个类的 <code>__base__</code>属性就指向它继承的那个类。（如果是多重继承，这些类就在<code>__bases__</code>属性里面）</p><h2 id="作为继承关系顶点的object"><a href="#作为继承关系顶点的object" class="headerlink" title="作为继承关系顶点的object"></a>作为继承关系顶点的object</h2><p>一个类可以继承自其它类，被继承的那个类称为父类。在python中，如果没有显示指定一个类继承自哪个父类，那么这个类就继承自object类。这意味着，在python中，<strong>object实际是所有类的父类，是继承树的根节点，其内蕴含了一些类基本的共有方法。</strong></p><p>python还规定，object类没有父类。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__base__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">issubclass</span><span class="params">(Foo, object)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(f, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object没有父类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>object.__base__</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="作为对象的顶点的type"><a href="#作为对象的顶点的type" class="headerlink" title="作为对象的顶点的type"></a>作为对象的顶点的type</h2><p>前面说过，在python中，一切皆是对象，类也是对象。是对象就应该有其对应的构造类型。一般的对象由它们的类实例而来。那么作为类本身，它们应该由哪个类实例而来呢？在python中，这个类就是type，<strong>一切的类都是type类型的实例，type的构造类是其自身，type是自身的实例。</strong></p><p>因此，type代表了一切实例关系的顶点。可以通过如下的属性观察到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><!--MORE--><h2 id="type与object"><a href="#type与object" class="headerlink" title="type与object"></a>type与object</h2><p>于是，由前面的叙述，可以总结出，object是python里面向对象继承关系的体现，一切的类都是object的子类；type是python里“一切皆是对象”的动态特性的体现，一切的类都是type类型的实例，由type类型构造而来。并且，object类没有父类，type是其自身的实例。</p><p>现在，就可以解释开头的奇特特性了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这里体现出type是其自身的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>这里体现出object是python中一切类的父类，包括type，type也是object的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, type)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>体现出一切类都是type的实例，包括object。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>type也是object的实例。因为type是自身的实例，而type自身又是object的子类。如果一个对象是某个类的实例，那么这个对象也是那个类<code>__mro__</code>链上（父类）所有类的实例。因此type也是object的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>虽然object没有父类，但python规定用issubclass判断继承关系时，对自身返回True，因此这里返回True。可以看作，python中一切类也是自身的子类（父类）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, type)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>object是type的实例，但不是type的子类。object是一切类的父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>object是type的实例，type是object的子类，因此object是自身的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>一切类都是自身的子类。</p><h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>上面提到，一切类都是type的实例，这体现出python动态语言的特性。实际上，通过type，可以实现<code>元编程</code>，在运行时动态创建、修改类。这个话题就在另一篇文章里再说吧！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7454c02e86c4" target="_blank" rel="noopener">https://www.jianshu.com/p/7454c02e86c4</a></p><p><a href="http://www.cnblogs.com/busui/p/7283137.html" target="_blank" rel="noopener">http://www.cnblogs.com/busui/p/7283137.html</a></p><p><a href="https://www.zhihu.com/question/38791962" target="_blank" rel="noopener">https://www.zhihu.com/question/38791962</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一生一代一双人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;type和object&quot;&gt;&lt;a href=&quot;#type和object&quot; class=&quot;headerlink&quot; title=&quot;type和object&quot;&gt;&lt;/a&gt;type和object&lt;/h2&gt;&lt;p&gt;python中内置了两个类，type和object，用isinstance和issubclass测试这两个类会发现一些奇怪的特性，如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# object是自身的实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(object, object)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# object也是type的实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(object, type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# type是自身的实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(type, type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# type是object的实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(type, object)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# object是自身的子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;issubclass(object, object)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# object不是type的子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;issubclass(object, type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# type是自身的子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;issubclass(type, type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# type也是object的子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;issubclass(type, object)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://arianx.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>浅析python中super用法，兼及继承机制</title>
    <link href="https://arianx.me/2018/05/14/Explore-the-usage-of-super/"/>
    <id>https://arianx.me/2018/05/14/Explore-the-usage-of-super/</id>
    <published>2018-05-14T14:05:27.000Z</published>
    <updated>2018-06-26T13:10:56.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>远在天边，我们一无所见，即使近在眼前，也仅仅是连续不断而变幻不定的表象。 </p></blockquote><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在学习python的过程中，一直对super的用法感到稍许疑惑。虽然直到它的基本使用方法，却一直觉得模模糊糊。本文将根据实例简要探讨python3中super函数的行为，以加强对super函数的认知，兼及一些相关方面的内容。</p><p>本文将简要谈谈我对对象和继承机制的理解，最终探讨super的用法。<br><a id="more"></a></p><h2 id="Ⅰ-面向对象机制"><a href="#Ⅰ-面向对象机制" class="headerlink" title="Ⅰ.面向对象机制"></a>Ⅰ.面向对象机制</h2><p><code>面向对象(OOP, Object Oriented Programming）</code>是目前编程语言中一种主流的思想，python从设计初期就已经是一门面向对象的语言。python为面向对象编程提供了强大的语法支持。因此，在python中，使用面向对象的方式进行程序设计是十分自然并且容易的。</p><p>理所当然，一旦提到面向对象的编程思想，那么便会自然而然想到面向对象思想中的一些重要概念。比如说：<code>类（Class)</code>。类是一种数据结构，简单来说，可以理解为对某些拥有共同属性，或行为的对象的抽象。它可以视作这些拥有相同属性或行为的对象的蓝图，封装了这些对象的共同属性或行为，使得程序设计更模块化，提高了代码的可复用性——一个<code>对象（Object）</code>是它的类的实例，它能够访问它的构造类中的所有属性或方法。</p><p>可以将python中的类与对象类比到现实中。这样，对象就是现实世界中的客体，是一种具体的实体。现实世界中的所有事物都可以看作一个对象。例如，一个人。当我们谈到这个对象时，我们所想到的，是这个带有数量词的、具体的、实在的个体，是“这个人”而不是“那个人”。而现实世界里面存在许许多多的人。这些所有的人有某些共同的特征，我们将这些特征聚合起来，所形成的一个抽象的、宽泛的“人”的这个形式，就是所有作为人的对象的类。</p><p>每个具体的对象都有其独特的<code>标识</code>。例如，在现实中，每个人都会有一个名字。一般来说，在某个给定范围的命名空间中，这个标识是唯一的。我们可以说，某个具有独特标识符的对象属于什么类。例如，张三是人，就是说”张三”属于”人”这个类。这样，可以发现，一般情况下，凡是可以说成“某个东西是什么”这种句法的，都可以抽象出类与对象的关系。</p><p>类比到现实中，类与对象是一种所属关系，对象是一种客观存在的实体。而放到具体的程序设计中来说，类可以视作对某些具有共同特征或行为的数据的<code>抽象</code>。</p><h2 id="Ⅱ-类的继承机制"><a href="#Ⅱ-类的继承机制" class="headerlink" title="Ⅱ.类的继承机制"></a>Ⅱ.类的继承机制</h2><p>一个对象可以说成是某个类的实例，一般情况，就可以说成”对象是类”这种形式。然而，在许多情况下，在这样抽象之后，我们仍然可以发现，类也有其自身的所属。例如说，泰迪是一只熊，在这里，”泰迪”是具体的对象，”熊”是”泰迪”的类，而“熊”这个类，又由“哺乳动物”这个类细分而来。我们可以这样说，熊继承自哺乳动物，而泰迪既是一只熊，也是一只哺乳动物。这样，父类就可以理解为对类的基本属性的抽象，子类是对于父类的补充。</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-5-15/85242660.jpg" alt="补充"></p><p>简单来说，对象之于类，是“某个东西是什么”，而子类之于父类，是子类补充了父类。</p><p>在python中，如果一个子类继承了父类，就称这个父类为子类的<code>base class</code>，并且，这个子类的所有base class，都可以在<code>__bases__</code>属性中访问。这个子类的实例，也可以同时访问子类所有父类、以及后续的父类内的属性或方法（此处不考虑带前置双下划线的私有方法）。</p><p>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm an animal."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I can fly."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird = Bird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.skill()</span><br><span class="line">I can fly.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.kind()</span><br><span class="line">I<span class="string">'m an animal.</span></span><br></pre></td></tr></table></figure></p><p>可见，实例可访问它的构造类以及之后的父类中的方法。</p><p>同时，子类可以<code>覆盖</code>父类的方法。这样，访问实例中的这个方法时，就访问它的构造方法内重写的那个方法，而不向后追溯。</p><p>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm an animal."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm a bird."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird = Bird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.kind()</span><br><span class="line">I<span class="string">'m a bird.</span></span><br></pre></td></tr></table></figure></p><!--MORE--><p>python还支持<code>多重继承</code>。一个子类，可以同时拥有多个父类，同时继承这些父类的属性或方法。可以通过访问子类的<code>__bases__</code>属性获得它的父类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    eatable = <span class="keyword">True</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ice</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    cold = <span class="keyword">True</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span><span class="params">(Food, Ice)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>IceCream.__bases__</span><br><span class="line">(&lt;class '__main__.Food'&gt;, &lt;class '__main__.Ice'&gt;)</span><br></pre></td></tr></table></figure></p><p>实例可以访问这些父类的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>IceCream.eatable</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>IceCream.cold</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>但是，思考一下，如果子类继承了多个父类，同时这些父类拥有某些相同的属性或方法，实例该访问哪个方法呢？</p><p>这个问题的解决方案，就是依赖于特定的Method Resolution Order (MRO)。</p><h2 id="Ⅲ-MRO"><a href="#Ⅲ-MRO" class="headerlink" title="Ⅲ.MRO"></a>Ⅲ.MRO</h2><p>python利用MRO来决定多重继承中属性或方法的搜索顺序。如果一个类不止具有一个基类，那么，可以访问这个类的<code>__mro__</code>属性以获取其MRO链。在python3中，<a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener">C3算法</a>是唯一支持的MRO算法。</p><p>一般将C3算法理解为类似于广度优先搜索，但实际上它又与广度优先搜索有一定差别。</p><p>考虑下面的继承关系：</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-5-15/7957065.jpg" alt="继承"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    id = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span>    id = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">... </span>    id = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(C)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(D, E)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在这里，类F同时继承了类D和类E，而类D、E又分别继承了B、C，最终继承自类A。如果实例化一个类F，查看其id属性，最终结果会是哪一个？</p><p>实际为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=F()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.id</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>可以观察到，实际上访问了类B中的属性。</p><p>可以如前所述的访问类F的<code>__mro__</code>属性查看其MRO链：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>F.__mro__</span><br><span class="line">(&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure></p><p>访问顺序为：F &gt; D &gt; B &gt; E &gt; C &gt; A。可以看到C3算法与广度优先算法的区别。按照广度优先算法，应该是F &gt; D &gt; E &gt; B &gt; C &gt; A。然而这里先深度优先搜索到了与其它支链有交点的节点，然后返回去进行广度优先搜索。</p><p>实际上，在python3中的MRO算法为：对于一个有多重父类的子类，它的MRO链为其自身与其父类的merge()线性操作的结果。用表达式表示为：<code>L[C(B1...BN)] = C + merge(L(B1)+..L(BN)+B1+...BN)</code></p><p>其中，merge的规则为：</p><ol><li>递归展开其内的L为MRO列表。</li><li>取第一个列表中的第一个元素，如果这个元素不出现之后列表，或者不是其它列表除首元素之外的元素，就将它提取到merge外面，作为最终MRO链的一员，同时消去merge中的这个元素。</li><li>重复第二步直到遇到不可提取的元素，对下一个列表重复第二步。直到不存在元素，MRO链构建完成。</li><li>否则，这个继承不合法。</li></ol><p>例如，对于例子而言，其求MRO链的过程就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L(F(D, E)) = F + merge(L(D) + L(E) + D + E)</span><br><span class="line">           = F + merge([D, B, A] + [E, C, A] + D +E)</span><br><span class="line">           = F + D + merge([B, A] + [E, C, A] +E)</span><br><span class="line">           = F + D + B + merge(A + [E, C, A] + E)</span><br><span class="line">           = F + D + B + E + merge(A + [C, A])</span><br><span class="line">           = F + D + B + E + C + merge(A)</span><br><span class="line">           = F + D + B + E + C + A</span><br></pre></td></tr></table></figure></p><p>与由<code>__mro__</code>属性看到的MRO链一致。</p><p>那么，到现在为止，我们已经知道如何继承，如何多重继承，以及在多重继承中访问特性，python搜索的机制。同时，我们已经可以覆盖父类中的属性或方法。那么，还剩下最后一点，python继承方面的机制就完善了。那就是，如果我们继承父类后，又覆盖了父类中的特性，我们该如何才能访问到父类中的那个特性呢？</p><p>如果覆盖了方法，最直观的调用父类中方法的方式，是直接在那个方法中通过父类来调用方法，然后传入自身的实例。就像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm a food."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        Food.say(self)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"And I'm a ice cream."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream = IceCream()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream.say()</span><br><span class="line">I<span class="string">'m a food.</span></span><br><span class="line"><span class="string">And I'</span>m a ice cream.</span><br></pre></td></tr></table></figure></p><p>然而通过这种方式所产生的一个问题是，在如下这种情况下，通过这种方式所产生的调用会出现重复调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Food."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Water</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        Food.say(self)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Water."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ice</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        Food.say(self)</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Ice."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span><span class="params">(Water, Ice)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        Water.say(self)</span><br><span class="line"><span class="meta">... </span>        Ice.say(self)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream = IceCream()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream.say()</span><br><span class="line">I<span class="string">'m Food.</span></span><br><span class="line"><span class="string">I'</span>m Water.</span><br><span class="line">I<span class="string">'m a food.</span></span><br><span class="line"><span class="string">I'</span>m Ice.</span><br></pre></td></tr></table></figure></p><p>这样，Food中的say方法被无意间调用了两次。</p><p>解决这个办法，使得在继承关系中，能够正确调用父类方法的工具，就是使用python中的super对象。</p><h2 id="Ⅳ-super对象"><a href="#Ⅳ-super对象" class="headerlink" title="Ⅳ.super对象"></a>Ⅳ.super对象</h2><p>在python中，super对象用于构造访问给定子类的MRO链上，父类特性的代理。它接受两个参数，第一参数是要构造代理的对象，第二个参数是要绑定给父类参数的对象。它可以这样用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Food."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Water</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().say()</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Water."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ice</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().say()</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm Ice."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">IceCream</span><span class="params">(Water, Ice)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        super().say()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream = IceCream()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice_cream.say()</span><br><span class="line">I<span class="string">'m Food.</span></span><br><span class="line"><span class="string">I'</span>m Ice.</span><br><span class="line">I<span class="string">'m Water.</span></span><br></pre></td></tr></table></figure></p><p>可见，它给出了理想的结果，最高的父类Food仅被访问了一次，同时两个中间的父类都访问了一次。</p><p><strong>事实上，super搜寻特性的机制与使用getattr访问这个子类的机制相同（即，使用点运算符访问特性），都是根据<code>__mro__</code>属性中给出的链进行搜寻。经过super代理的访问，会转发给MRO链上的下一个类</strong>。如果最终super没有在链上的对象里找到想要访问的方法，最后又没有在super对象上自身找到，就会弹出AttributeError错误。</p><p>super不是一个函数，而是一个对象，返回一个代理对象。通过这个代理对象访问的所有方法或属性，都会沿给定类的MRO链查找。需要注意的是，<strong>如果父类中存在与super对象自身相同的特性，那个特性就会覆盖super本身的特性。</strong>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>food = Food()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(super(Food, food).__str__())</span><br><span class="line">&lt;__main__.Food object at <span class="number">0x0000020FE57D6C50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(getattr(super, <span class="string">'__str__'</span>)(super))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">super</span>'&gt;</span></span><br></pre></td></tr></table></figure></p><p>可见，通过点运算符访问的，被转发给了代理类的父类。通过getattr函数则可以得到正确的结果。</p><p>super的第一个参数是指定要在其上MRO链搜寻特性的类，第二个参数会被绑定给将要调用的方法。第二个参数允许两种类型：</p><ol><li>如果第二个参数是对象，那么这个对象必须是第一个参数的实例。也就是isinstance(arg1, arg2)返回True。</li><li>如果第二个参数是类（类型对象），那么这个类必需是第一个参数的子类。也就是issubclass(arg1, arg2)返回True。</li></ol><p>对于第一种情况，如果将要调用的是普通方法，这个对象会被绑定为其第一个参数；第二种情况，如果将要调用的是类方法，这个类将会被绑定为第二个参数。除此之外，不作绑定。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">normal</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'normal'</span>)</span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">cls</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'cls'</span>)</span><br><span class="line"><span class="meta">... </span>    @staticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'static'</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ice</span><span class="params">(Food)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ice = Ice()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(Ice, ice).normal()  <span class="comment"># 第二个参数是实例</span></span><br><span class="line">normal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(Ice, Ice).cls()  <span class="comment"># 第二个参数是类</span></span><br><span class="line">cls</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(Ice, ice).static()</span><br><span class="line">static</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>super(Ice, Ice).static()</span><br><span class="line">static</span><br></pre></td></tr></table></figure></p><p>在一般情况下，我们看到的调用super的方式直接是super()，而没有传递任何参数，这是针么回事？实际上，调用super()就等同于调用了super(type(self), self)，这种省略形式只能在类的方法中调用。</p><p>最后，有趣的一点是，在途中我打算查看super对象的源码时，通过pycharm，却只看到了带有“real signature unknown”注释的pass实现。这说明python是在c语言层面实现super对象的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/45619cf50aa7" target="_blank" rel="noopener">https://www.jianshu.com/p/45619cf50aa7</a></p><p><a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html#super</a></p><p><a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/C3_linearization</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;远在天边，我们一无所见，即使近在眼前，也仅仅是连续不断而变幻不定的表象。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;在学习python的过程中，一直对super的用法感到稍许疑惑。虽然直到它的基本使用方法，却一直觉得模模糊糊。本文将根据实例简要探讨python3中super函数的行为，以加强对super函数的认知，兼及一些相关方面的内容。&lt;/p&gt;
&lt;p&gt;本文将简要谈谈我对对象和继承机制的理解，最终探讨super的用法。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://arianx.me/categories/Python/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Flask常见扩展总结</title>
    <link href="https://arianx.me/2018/04/13/The-common-Flask-s-extensions/"/>
    <id>https://arianx.me/2018/04/13/The-common-Flask-s-extensions/</id>
    <published>2018-04-13T05:01:43.000Z</published>
    <updated>2018-06-26T13:00:26.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a>是一个用python编写的、基于<a href="http://werkzeug.pocoo.org/" target="_blank" rel="noopener">Werkzeug WSGI</a>和<a href="http://jinja.pocoo.org/docs/2.10/" target="_blank" rel="noopener">Jinja2</a>的轻量级Web应用框架。因为其相比于django等框架来说简洁的功能与架构，常常被称为”microframework”。然而，称Flask为微框架并不意味着它相比起其它框架来说功能更少——Flask拥有强大的可扩展性以及活跃的社区。开发者可以根据自身的需求，自由的选择扩展包来增强其功能。</p><p>合理的选择扩展包，将极大的减少开发时间，提高开发效率。下面，本文就将列举出Flask应用程序开发中的一些常用扩展，以便于参考和查询。</p><a id="more"></a><h2 id="Flask-WTF"><a href="#Flask-WTF" class="headerlink" title="Flask-WTF"></a>Flask-WTF</h2><p>Flask-WTF将Flask和<a href="https://wtforms.readthedocs.io/en/stable/" target="_blank" rel="noopener">WTForms</a>做了简单集成，包含<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">CSRF</a>，文件上传，验证码服务等。</p><p>特点：</p><ol><li>集成WTForms</li><li>使用CSRF token保证安全性</li><li>全局CSRF防御</li><li>支持验证码服务</li><li>配合<a href="https://pythonhosted.org/Flask-Uploads/" target="_blank" rel="noopener">Flask-Uploads</a>运作的文件上传服务</li><li>使用<a href="http://pythonhosted.org/Flask-Babel/" target="_blank" rel="noopener">Flask-Babel</a>支持国际化</li></ol><p>Flask-WTF集成了WTForms，使用它，可以以面向对象语言中类的形式构建表单，简化了处理、验证表单所需操作，使表单设计与Flask其它部分统一。</p><p>文档：<a href="https://flask-wtf.readthedocs.io/en/stable/" target="_blank" rel="noopener">Flask-WTF</a></p><h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>Flask-SQLAlchemy为使用Flask开发的应用程序提供了<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>的支持。它支持0.8及以上版本的SQLAlchemy，旨在通过提供有用的默认值和额外的帮助来简化Flask中SQLAlchemy的使用，使完成常见的任务变得更简单。</p><p>SQLAlchemy为python提供了<a href="https://en.wikipedia.org/wiki/Orm" target="_blank" rel="noopener">ORM</a>(对象关系映射)。简单地说，ORM就是为操作不同数据库提供了一个用面向对象思想设计的统一上层接口，隐藏了在具体语言中真实操作、连接数据库的底层实现，从而解耦了应用和数据库，使得方便的更换数据库成为可能。（但同样，正因如此，ORM往往不能覆盖各数据库的特有功能）。通过Flask-SQLAlchemy，可以方便的在Flask使用SQLAlchemy。</p><p>文档：<a href="http://www.pythondoc.com/flask-sqlalchemy/" target="_blank" rel="noopener">Flask-SQLAlchemy</a></p><h2 id="Flask-MongoEngine"><a href="#Flask-MongoEngine" class="headerlink" title="Flask-MongoEngine"></a>Flask-MongoEngine</h2><p>Flask-MongoEngine集成了<a href="http://mongoengine.org/" target="_blank" rel="noopener">MongoEngine</a>。</p><p>通过它能够方便的在Flask中使用MongoDB。</p><p>文档：<a href="http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/" target="_blank" rel="noopener">Flask-MongoEngine</a></p><h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>Flask-Login为Flask提供了用户会话管理。它能够处理如登陆、登出、持久记住用户会话等常见任务。</p><p>它将：</p><ol><li>将活动的用户ID储存在session中，让你能够方便的对他们进行登入登出操作。</li><li>让你能够限制视图只允许登入（或登出）用户访问。</li><li>处理常见的“记住我”功能。</li><li>保护你的用户会话以防被cookie小偷窃取。</li><li>之后可能会与Flask-Principal或其它验证扩展集成。</li></ol><p>然而，它不会：</p><ol><li>将特定的数据库或其它储存方法强加给你。用户如何载入，决定权完全在你的手中。</li><li>限制你使用如用户名和密码，OpenIDs，或其它验证方法。</li><li>处理超出“登入登出”之外的权限。</li><li>处理用户注册或账户重置。</li></ol><p>文档：<a href="https://flask-login.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Login</a></p><h2 id="Flask-Migrate"><a href="#Flask-Migrate" class="headerlink" title="Flask-Migrate"></a>Flask-Migrate</h2><p>Flask-Migrate是一个使用<a href="https://pypi.python.org/pypi/alembic" target="_blank" rel="noopener">Alembic</a>处理Flask应用程序中SQLAlchemy数据库迁移的扩展。数据库操作由Flask命令行接口或通过<a href="grate.readthedocs.io/en/latest/">Flask-Script</a>扩展而得到支持。</p><p>Flask中的SQLAlchemy只有在不存在这个表时才会按照程序中的定义新建一个表。然而，在开发过程中不免要更改表结构，此时就可以借助这个扩展来方便的更新数据库。</p><p>文档：<a href="https://flask-migrate.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a></p><h2 id="Flask-RESTful"><a href="#Flask-RESTful" class="headerlink" title="Flask-RESTful"></a>Flask-RESTful</h2><p>Flask-RESTful是一个为Flask增加了快速绑定REST风格API功能的扩展。它是一个与你已经存在的ORM/库之间协同工作的轻量级抽象。Flask-RESTful鼓励使用最少设置的最佳实践。</p><p>文档:<a href="https://flask-restful.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-RESTful</a></p><h2 id="Flask-Admin"><a href="#Flask-Admin" class="headerlink" title="Flask-Admin"></a>Flask-Admin</h2><p>Flask-Admin解决了在现有数据模型上构建管理界面的无聊问题。通过一定的努力，它能让你使用一个用户友好的界面管理web服务器数据。</p><p>文档：<a href="https://flask-admin.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Admin</a></p><h2 id="Flask-Bcrypt"><a href="#Flask-Bcrypt" class="headerlink" title="Flask-Bcrypt"></a>Flask-Bcrypt</h2><p>Flask-Bcrypt是一个为Flask应用程序提供了Bcrypt散列工具的Flask扩展。</p><p>Bcrypt是一种比MD5或SHA1稍慢，但更加安全、不易碰撞的散列算法。</p><p>文档：<a href="https://flask-bcrypt.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Bcrypt</a></p><h2 id="Flask-Cache"><a href="#Flask-Cache" class="headerlink" title="Flask-Cache"></a>Flask-Cache</h2><p>Flask-Cache用于缓存常用Web应用程序页面，从而在下一次请求时直接从缓存中返回而不用再查询、构建页面，从而极大的优化了Web应用程序的响应速度。</p><p>值得注意的是，不是每个页面都适合使用Flask-Cache缓存——数据经常变化的页面不适于被缓存。</p><p>文档：<a href="https://pythonhosted.org/Flask-Cache/" target="_blank" rel="noopener">Flask-Cache</a></p><h2 id="Flask-SSLify"><a href="#Flask-SSLify" class="headerlink" title="Flask-SSLify"></a>Flask-SSLify</h2><p>Flask-SSLify是一个简单扩展，能够将所有访问都重定向到https。</p><p>文档:<a href="https://pypi.python.org/pypi/Flask-SSLify" target="_blank" rel="noopener">Flask-SSLify</a></p><h2 id="Flask-Bootstrap"><a href="#Flask-Bootstrap" class="headerlink" title="Flask-Bootstrap"></a>Flask-Bootstrap</h2><p>Flask-Bootstrap为Flask应用程序提供了内建的Bootstrap支持，从而可以方便的在程序中集成Bootstrap，并且使用扩展提供的默认布局。</p><p>值得注意的是，到目前为止，Flask-Bootstrap似乎默认只支持Bootstrap2、3,不支持Bootstrap4。</p><p>文档：<a href="https://pythonhosted.org/Flask-Bootstrap/" target="_blank" rel="noopener">Flask-Bootstrap</a></p><h2 id="Flask-Principal"><a href="#Flask-Principal" class="headerlink" title="Flask-Principal"></a>Flask-Principal</h2><p>Flask-Principal为Flask提供了用户权限控制。它通过提供一个松散的框架，将位于Web应用程序中的不同部分的两种服务类型提供者（身份验证提供者、用户信息提供者）联系起来。</p><p>文档：<a href="http://pythonhosted.org/Flask-Principal/" target="_blank" rel="noopener">Flask-Principal</a></p><h2 id="Flask-DebugToolbar"><a href="#Flask-DebugToolbar" class="headerlink" title="Flask-DebugToolbar"></a>Flask-DebugToolbar</h2><p>Flask-DebugToolbar为应用程序添加了一个工具栏，包含许多对debugging有益的应用程序相关信息。</p><p>文档：<a href="https://flask-debugtoolbar.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-DebugToolbar</a></p><h2 id="Flask-Security"><a href="#Flask-Security" class="headerlink" title="Flask-Security"></a>Flask-Security</h2><p>Flask-Security支持为Flask应用程序快速添加常用的安全机制。</p><p>文档：<a href="https://pythonhosted.org/Flask-Security/index.html" target="_blank" rel="noopener">Flask-Security</a></p><h2 id="Flask-Paginate"><a href="#Flask-Paginate" class="headerlink" title="Flask-Paginate"></a>Flask-Paginate</h2><p>Flask-Paginate提供了分页工具，可以在模板中快速简洁的创建出分页样式。</p><p>文档：<a href="http://flask-paginate.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Paginate</a></p><h2 id="Flask-Mail"><a href="#Flask-Mail" class="headerlink" title="Flask-Mail"></a>Flask-Mail</h2><p>Flask-Mail为Flask集成了简单的SMTP邮件服务。使用它，可以方便的通过视图和脚本向用户、管理员发送邮件。</p><p>文档：<a href="https://pythonhosted.org/Flask-Mail/" target="_blank" rel="noopener">Flask-Mail</a></p><h2 id="Flask-BasicAuth"><a href="#Flask-BasicAuth" class="headerlink" title="Flask-BasicAuth"></a>Flask-BasicAuth</h2><p>Flask-BasicAuth使用HTTP基础访问验证功能为Flask应用提供了保护某些视图或整个应用的简洁方法。</p><p>Flask-BasicAuth常用于Flask应用程序中API的访问验证。</p><p>文档：<a href="https://flask-basicauth.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-BasicAuth</a></p><h2 id="Flask-Assets"><a href="#Flask-Assets" class="headerlink" title="Flask-Assets"></a>Flask-Assets</h2><p>Flask-Assets集成了webassets。使用它，可以方便的将不同的静态资源文件整合、压缩在一起，从而减少响应的大小，优化Web应用程序的访问速度。</p><p>文档：<a href="https://flask-assets.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Assets</a></p><h2 id="Flask-PageDown"><a href="#Flask-PageDown" class="headerlink" title="Flask-PageDown"></a>Flask-PageDown</h2><p>PageDown是使用JacaScript实现的客户端MarkDown到HTML的转换程序。而Flask-PageDown扩展则将PageDown集成到了Flask-WTF表单字段里。</p><p>文档：<a href="https://github.com/miguelgrinberg/Flask-PageDown" target="_blank" rel="noopener">Flask-PageDown</a></p><h2 id="Flask-HTTPAuth"><a href="#Flask-HTTPAuth" class="headerlink" title="Flask-HTTPAuth"></a>Flask-HTTPAuth</h2><p>Flask-HTTPAuth是一个支持为Flask路由应用一些http验证方法的简单扩展。<br>Flask-HTTPAuth支持HTTPBasicAuth、HTTPDigestAuth、HTTPTokenAuth和混合验证。</p><p>文档：<a href="http://flask-httpauth.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-HTTPAuth</a></p><h2 id="Flask-KVSession"><a href="#Flask-KVSession" class="headerlink" title="Flask-KVSession"></a>Flask-KVSession</h2><p>Flask-KVSessin重写了Flask基于客户端的session机制。不再客户端储存数据，只在客户端储存一个安全生成的ID，而实际数据则储存在服务器端。</p><p>提高了Flask Session机制的安全性。</p><p>文档：<a href="https://pythonhosted.org/Flask-KVSession/" target="_blank" rel="noopener">Flask-Session</a></p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-4-13/54750302.jpg" alt="youya"><br>╮(╯-╰)╭</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://flask.pocoo.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask&lt;/a&gt;是一个用python编写的、基于&lt;a href=&quot;http://werkzeug.pocoo.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Werkzeug WSGI&lt;/a&gt;和&lt;a href=&quot;http://jinja.pocoo.org/docs/2.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jinja2&lt;/a&gt;的轻量级Web应用框架。因为其相比于django等框架来说简洁的功能与架构，常常被称为”microframework”。然而，称Flask为微框架并不意味着它相比起其它框架来说功能更少——Flask拥有强大的可扩展性以及活跃的社区。开发者可以根据自身的需求，自由的选择扩展包来增强其功能。&lt;/p&gt;
&lt;p&gt;合理的选择扩展包，将极大的减少开发时间，提高开发效率。下面，本文就将列举出Flask应用程序开发中的一些常用扩展，以便于参考和查询。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://arianx.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="Flask" scheme="https://arianx.me/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>扔鸡蛋问题</title>
    <link href="https://arianx.me/2018/03/05/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/"/>
    <id>https://arianx.me/2018/03/05/扔鸡蛋问题/</id>
    <published>2018-03-05T14:34:51.000Z</published>
    <updated>2018-06-26T13:02:34.432Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-6/16293116.jpg" alt="sister"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逛知乎的时候偶然看到的一道算法问题，看了回答里大牛给的题解以后感觉解法十分巧妙，所以写一篇博客记载下来。<br>这个问题应该属于动态规划，但本人还没有怎么接触过算法这方面的知识，全属个人理解，所以文中可能有一些不标准的地方，还请见谅啦~，也欢迎指出来。<br><a id="more"></a></p><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>有一栋200层高的大楼，给你两个质地相同但软硬未知的鸡蛋。如果在第n层扔下鸡蛋，鸡蛋不碎，那么，从第n-1层以下扔鸡蛋都不碎。如果要想测试出最高从第几层扔下时鸡蛋不会碎，问，在最坏情况下，所扔次数最少为多少？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目要求测试的是最高第几层扔下时不会碎，也就是说，在这一层下，鸡蛋都不会碎，在这一层上，鸡蛋都会碎。并且注意到，题目并没有规定这个层数，而是说在<strong>最坏</strong>的情况下所扔次数<strong>最少</strong>的策略。这也意味着，对于每个策略，鸡蛋可能在不同层数碎，并且总是使当前策略所需测试次数最多的那个层数。而我们所求的，就是在所有策略的最坏情况中，最少的那个次数。</p><h2 id="解题策略"><a href="#解题策略" class="headerlink" title="解题策略"></a>解题策略</h2><p>考虑如果只有一颗鸡蛋，那么就需要从第一层开始，逐一往上测试，直到找到破碎的那一层，这种策略最坏情况下所需次数为100.</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>现在有两颗鸡蛋，那么就可以有一颗用来划定区间，另一颗用来测试鸡蛋将在这个区间的哪一层碎。比如，使用二分法，第一颗鸡蛋扔在50层。如果碎了，就用第二颗鸡蛋从第一层扔到第49层，直到在第49层破碎，那么一共测试了50次；如果鸡蛋不碎，就将第一颗鸡蛋扔在第75层，在根据碎不碎判断接下来的情况。</p><p>可以看出，使用二分法的情况下，最坏的次数需要50次。</p><h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p>不妨假设在这种情况下用两颗鸡蛋测试z层，最少需要x次，考虑选择怎样的策略，才能在最坏的情况下，用这x次测试出最多的层数。</p><p>考虑第一次尝试应该选择扔在哪层楼。假设扔在第y层楼。如果第一颗鸡蛋在第y层楼破碎，那么，接下来需要用剩下来的那颗鸡蛋，最多需要用<code>y-1</code>次尝试测试最终鸡蛋在哪层楼破碎。在这种情况下，根据总是考虑最坏情况这个条件，如果<code>y&gt;x</code>，那最终就无法测试出鸡蛋是哪一层楼（因为最坏情况下鸡蛋在第<code>y-1</code>层楼，而只剩下<code>x-1</code>次尝试的次数）。所以第一次应该扔在<strong>小于等于</strong>x的楼层数。</p><p>考虑<code>y&lt;x</code>的情况。如果鸡蛋在第y层破碎，那么就可以用不到<code>x-1</code>的尝试次数测试出最终楼层；如果鸡蛋在第y层不破碎，那么，问题就转换为怎样用两颗鸡蛋，在<code>x-1</code>次的步骤内测试出<code>z-y</code>层楼里鸡蛋破碎位置的<strong>子问题</strong>。而这个子问题也和先前测试第一次尝试一样，第一颗扔出的鸡蛋不能大于<code>x-1</code>层，如果大于，次数就不够，必需扔在小于<code>x-1</code>次的楼层数。</p><p>这样，每一次不破碎，都生成一个新的独立的子问题。直到最终一颗鸡蛋在某一次测试中破碎，就用剩下的一颗鸡蛋逐一测试最近一次扔鸡蛋和破碎层之间的区间，找出正确答案。因为每一次不破碎都生成的都是<strong>独立</strong>的子问题（当前第一颗鸡蛋选择扔的层数不影响下一个子问题的决策），所以将每一次能测试出的最大的不破碎区间组合起来，就是最终能测试的最多层数。</p><p>因为每一次扔鸡蛋的最远距离就是当前次数的剩余数，所以需要每次测试，都扔在比当前层数大剩余次数的楼层。那么，如果有两颗鸡蛋，用x次尝试次数能确定的鸡蛋不破碎的最多层数就为<code>x+(x-1)+(x-2)...+1</code>。</p><p>回到原题来。原题要求求出用两颗鸡蛋测试200层楼所需的最少次数，也就是说需要<code>x+(x-1)+(x-2)...+1&gt;200</code>，也就是<code>x(x+1)/2&gt;200</code>，解出来就是x取整最少需要20次。</p><h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>以上是从推理方面来考察，现在从程序逻辑的方面考虑。</p><p>有200层楼，用两颗鸡蛋去测试使鸡蛋不碎的最高层数，要求求出最坏情况下的最小尝试次数。也就是，设初始选择扔在第y层，f(y)为在这种策略下的所需要的最多的次数，我们所求的为所有策略中最小的次数。如果第一颗鸡蛋在y层就破碎，那么所需要的次数就为y次，如果第一颗鸡蛋在y层不破碎，那么问题就转换为一个求用两颗鸡蛋测试200-y层所需要的最坏情况下的最少次数的子问题。</p><p>所以，状态转移方程就为：f(x)=min(max(i, f(i-1)+1))，(0&lt; i&lt;= x)。退出条件为i==0时，需要0次。</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>使用了python实现，并且使用了functools库里面的lru_cache，这个装饰器会缓存函数结果，如果给函数传入了相同的参数，就直接返回缓存的结果。</p><p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    res = min([max(i, test(m-i)+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">200</span>))</span><br><span class="line"><span class="comment">#结果：14</span></span><br></pre></td></tr></table></figure></p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>同理，如果推广到更一般的情况下，用n颗鸡蛋取测试m层的大楼，求最坏情况下的最少次数。首先选定一个楼层y，扔出第一颗鸡蛋。如果这颗鸡蛋破碎了，问题就转化为用n-1颗鸡蛋去测试m-1层楼的子问题；如果没碎，问题就转化为用n颗鸡蛋去测试m-y的子问题。</p><p>于是，在这种情况下的状态转移方程就为：f(m,n)=min(max(f(m-1,n-1), f(m-y,n)))+1，(0&lt; y&lt; m+1)。退出条件为当m==0时，需要0次；当n==1时，需要m次。</p><h3 id="推广情况程序实现"><a href="#推广情况程序实现" class="headerlink" title="推广情况程序实现"></a>推广情况程序实现</h3><p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    res = min([max(test(n<span class="number">-1</span>, i<span class="number">-1</span>), test(n, m-i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">2</span>,<span class="number">36</span>))</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">https://www.zhihu.com/question/19690210/answer/18079633</a><br><a href="">http://www.raychase.net/1374</a><br><a href="">http://blog.csdn.net/baolinq/article/details/53047288</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-6/16293116.jpg&quot; alt=&quot;sister&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;逛知乎的时候偶然看到的一道算法问题，看了回答里大牛给的题解以后感觉解法十分巧妙，所以写一篇博客记载下来。&lt;br&gt;这个问题应该属于动态规划，但本人还没有怎么接触过算法这方面的知识，全属个人理解，所以文中可能有一些不标准的地方，还请见谅啦~，也欢迎指出来。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://arianx.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>新学期开始</title>
    <link href="https://arianx.me/2018/03/03/%E6%96%B0%E5%AD%A6%E6%9C%9F/"/>
    <id>https://arianx.me/2018/03/03/新学期/</id>
    <published>2018-03-03T05:17:24.000Z</published>
    <updated>2018-06-26T13:02:21.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你永远不会知道，为了对生活感兴趣，我们究竟付出了多少努力。</p></blockquote><p>寒假偶然遇到一首很喜欢的音乐——雨降りお月さん（雨中的月亮），歌手为堀江由衣，是在补番过程中遇到的一首插曲。这首优美、朦胧，具有淡淡哀愁意境的歌在当时带给我十分深刻的印象。<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29091584&auto=0&height=66"></iframe><blockquote><p>雨降りお月さん （雨中的月亮，1925年）<br>作詞：野口雨情 作曲：中山晋平<br>歌词整理编译：九日旭（Guanxu）<br><br>雨降あめふりお月つきさん　雲くもの蔭かげ          雨中的月亮 躲在云背后<br>お嫁よめにゆくときゃ　誰だれとゆく      出嫁的时候 要和谁一起去<br>一人ひとりで傘からかさ　さして行ゆく          独自一人 撑伞前行<br>からかさないときゃ　誰だれとゆく    没有伞的话 又和谁一起呢<br>シャラシャラ　シャンシャン      叮叮当当<br>鈴すずつけた          铃声响   <br><br>お馬うまにゆられて　濡ぬれてゆく      在马上摇摇晃晃，冒雨前行<br>急いそがにゃお馬うまよ　夜よが明あけよう    马儿啊快些走 就要天亮了<br>手綱たづなの下したから ちょいと見みたりゃ   马儿从缰绳下面 瞄一下我<br>お袖そででお顔かほを　隠かくしてる          我用衣袖轻遮颜面<br>お袖そでは濡ぬれても　干ほしゃ乾かわく      衣袖湿了 晾晾就干<br>雨降あめふりお月つきさん　雲くもの蔭かげ          雨中的月亮 躲在云背后<br>お馬うまにゆられて　濡ぬれてゆく      在马上摇摇晃晃，冒雨前行<br><br>歌曲由两段原独立的两段歌词组成。第一段由野口雨情创作于大正14年（1925年）的儿童绘画杂志《コドモノクニ》一月号，并且刊登有相应杂志。后由作曲家中山晋平的建议改为歌曲，并受到大人孩子们的欢迎。为此，野口雨情以同一主题创作了一个续篇，以标题”雲の蔭“刊登在同年儿童绘画杂志《コドモノクニ》三月号上，同样配有装帧画并附带乐谱。在发售唱片时，因为原曲太短，两段词合起来作为一首歌。<br><br>歌曲描述了一位新娘子在骑马到婆家的雨路上的历程。配词充满童趣，同时引人幻想。然而，就如这隐隐约约透漏着哀愁、彷徨的旋律一样，这首歌具有这样的“黑色”背景：野口雨情的两个女儿都在年幼时夭折，而根据当地有这样的传说，如果新娘子是已经死去的女儿，那么她就会一个人独自启程去天国，而云背后（雲の蔭)的月亮正是隐喻中的天国。也许，这首歌正是野口雨情对其女儿亡灵的祝福。<br><br>参考自<a href="">http://blog.sina.com.cn/s/blog_4a4b274c0102wjwf.html</a></p></blockquote><p>除此之外，回过头来，整个寒假实在没有什么值得大肆回忆的内容。除了断断续续完成假期伊始订下的一些计划的日常（尽管到最后这些计划也没有来得及全部完成），就是一些琐碎的，在各种彷徨之中逝去的时间。旧的自己已经看起来渐渐消失，然而，新的自己尚没有来临，就是在这样的迷茫之中逝去的时间。</p><p>而新学期又要来临了。大学的第一个学期就这样完整的过去。到这里，也不再是可以以“新手”、“不适应”这样的话语来为自己找借口的时候了吧。</p><p>“给我振作起来啊，混蛋!”。希望新学期能够努力一点。</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-3/20421160.jpg" alt="miku"><br>最后，为有miku的世界献上祝福。:p</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你永远不会知道，为了对生活感兴趣，我们究竟付出了多少努力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;寒假偶然遇到一首很喜欢的音乐——雨降りお月さん（雨中的月亮），歌手为堀江由衣，是在补番过程中遇到的一首插曲。这首优美、朦胧，具有淡淡哀愁意境的歌在当时带给我十分深刻的印象。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://arianx.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="https://arianx.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="https://arianx.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>南邮ctf训练平台Vigenere writeup</title>
    <link href="https://arianx.me/2018/02/04/%E5%8D%97%E9%82%AEctf%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0Vigenere%20writeup/"/>
    <id>https://arianx.me/2018/02/04/南邮ctf训练平台Vigenere writeup/</id>
    <published>2018-02-04T11:10:44.000Z</published>
    <updated>2018-06-26T13:01:14.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原题链接：<a href="">http://ctf.nuptsast.com/challenges#Vigenere</a></p></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目原文：</p><blockquote><p>It is said that Vigenere cipher does not achieve the perfect secrecy actually :-)<br>Tips:<br>1.The encode pragram is given;<br>2.Do u no index of coincidence ？<br>3.The key is last 6 words of the plain text(with “nctf{}” when submitted, also without any interpunction)</p></blockquote><p>加密代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> KEY_LENGTH 2 <span class="comment">// Can be anything from 1 to 13</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> ch;</span><br><span class="line">  FILE *fpIn, *fpOut;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> key[KEY_LENGTH] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  <span class="comment">/* of course, I did not use the all-0s key to encrypt */</span></span><br><span class="line"></span><br><span class="line">  fpIn = fopen(<span class="string">"ptext.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  fpOut = fopen(<span class="string">"ctext.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fpIn, <span class="string">"%c"</span>, &amp;ch) != EOF) &#123;</span><br><span class="line">    <span class="comment">/* avoid encrypting newline characters */</span>  </span><br><span class="line">    <span class="comment">/* In a "real-world" implementation of the Vigenere cipher, </span></span><br><span class="line"><span class="comment">       every ASCII character in the plaintext would be encrypted.</span></span><br><span class="line"><span class="comment">       However, I want to avoid encrypting newlines here because </span></span><br><span class="line"><span class="comment">       it makes recovering the plaintext slightly more difficult... */</span></span><br><span class="line">    <span class="comment">/* ...and my goal is not to create "production-quality" code =) */</span></span><br><span class="line">    <span class="keyword">if</span> (ch!=<span class="string">'\n'</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(fpOut, <span class="string">"%02X"</span>, ch ^ key[i % KEY_LENGTH]); <span class="comment">// ^ is logical XOR    </span></span><br><span class="line">      i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fclose(fpIn);</span><br><span class="line">  fclose(fpOut);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>密文：<a href="">http://ctf.nuptsast.com/static/uploads/9a27a6c8b9fb7b8d2a07ad94924c02e5/code.txt</a></p><hr><p>可以看出，这道题的加密方式是维吉尼亚密码的变体。</p><p>原先的维吉尼亚加密，是指定一个密钥，然后将密钥循环与原文中每一个字母对应，这个字母偏移密钥在字母表中的序号后的新字母即为最终结果。如图：<br><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-2-4/56426864.jpg" alt="维吉尼亚加密"></p><p>而这道题是用1到14个长度范围内，未知的密钥，一一，并且循环与明文异或，跳过换行符，将每一位异或的结果输出为两位16位数作为密文。与传统维吉尼亚偏移的加密方式相比，使用了异或的形式来加密原文。</p><h2 id="维吉尼亚密码回顾"><a href="#维吉尼亚密码回顾" class="headerlink" title="维吉尼亚密码回顾"></a>维吉尼亚密码回顾</h2><p>要解这道题，先回顾传统维吉尼亚密码的解密形式。</p><p>我们知道，与凯撒密码不同之处在于，维吉尼亚密码中，一个字母可能生成几个不同的密文，因此，不能像凯撒密码那样用轮转密文的方法来破解维吉尼亚密码。要破解维吉尼亚密码，首先要理解到，虽然维吉尼亚密码打乱了字母与密文一一对应的关系，但同一位密钥所对应的不同密文，却有着相同的偏移量。也就是说，如果知道了密钥的长度，那每一位密钥所加密的那一组密文就像是凯撒密码那样有<strong>相同的偏移量</strong>。</p><p>所以如果能找出密钥的长度，那我们就能将密文分隔成几组由不同偏移量凯撒加密所形成的密文。</p><p>又有，在自然英语中，各个字母的<strong>使用频率</strong>不同，即一些字母使用频率高些，另一些字母使用频率低些。比如说，字母e的使用频率最高，约0.12，字母z的使用频率最低，为0.00074。据此，就可以分别统计出前述几组密文中各字母的出现频率，在对比自然英语字母的使用频率，然后就能猜测每一位密文所对应的原文。根据一组密文拥有相同的偏移量这一点，就可猜测出最终的密钥。</p><p>因而，解密维吉尼亚密码的第一步在于找出密钥的长度。只要找出了密钥的长度，就可以统计字频猜测具体密钥。</p><p>怎样才能求出密钥的长度？这里引入十分重要的一点，也是求解维吉尼亚密码的关键，即<strong>重合指数</strong>（index of coincidence）。重合指数是指，在一串字母中，任意取出两个字母，这两个字母相同的概率。例如，随机给出一串混乱的字母，它的重合指数总会在0.45附近，而一串有意义的英语段落，因为字母使用频率的影响，重合指数总是会在0.65附近，并且段落越长越接近这两个值。</p><p>易见的是，给一串字母相同的偏移量，并不会改变这串字母的重合指数。因此，通过同一位密钥加密而成的那一组维吉尼亚密文，因为它是有意义的段落，它的重合指数应该接近于自然英语的重合指数0.68。根据这一点，就可以猜测密钥的长度，再计算各个长度下密钥的重合指数（每个长度下的几组可以取均值），结果最接近0.68的那个结果，就可以大胆猜测是密钥的长度。</p><p>求出了密钥的长度，就可以如上述那样通过字频统计求出每一位密钥进而解密出原文了。</p><h2 id="本题解法"><a href="#本题解法" class="headerlink" title="本题解法"></a>本题解法</h2><p>知道了传统维吉尼亚密码的解法，再看本题，也就不难了。虽然本题最终采用了异或的方式来加密原文，而不是传统维吉尼亚密码的偏移，但最终，只要能够求出密钥的长度，都可以使用字频分析的方法来计算出密钥来解密。</p><p>所以说，求解本题，主要也是首先确定密钥长度。</p><p>这里第一个思路就可以像以上求传统维吉尼亚密码那样通过计算重合指数来确定。然而有一点不可忽视的是，重合指数法只适合于给出的密文全部由字母加密而成的情况。传统维吉尼亚密码只能加密字母（偏移），这道题则通过异或的方法来加密，使得任意字符都可以生成对应的密文。因此，由于其它非字母字符的干扰，就无法求出准确的重合指数，也就难以通过重合指数法寻找出密钥长度。</p><p>注意到，本题使用的是异或形式来加密。是否还记得异或有几个独特性质：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a^a = 0         //一个数异或本身等于零</span><br><span class="line">a^0 = a         //一个数异或零等于本身</span><br><span class="line">(a^b)^c = a^(b^c)       //异或满足结合律</span><br><span class="line">a^b^b = a       //因此，一个数两次异或同一个数等于本身</span><br></pre></td></tr></table></figure></p><p>本题的密文是由明文与密钥异或而来的，因此 <code>明文^密钥 = 密文</code>，也就是<code>明文 = 密文^密钥</code>。关键点是，<strong>明文一定是由ascii字符组成的，并且密钥一定存在</strong>。如果假定出密钥的长度，那么可以将密文划分成相应的几组，密钥的取值范围又在一定的范围之内（unsigned char ，0~255）。因此，如果在假定的长度下，某一组密文在这个范围内找不到合理的密钥（使得与密文异或为ascii字符的密钥），那就说明密钥不可能是这个长度。</p><p>通过这种方式，就可以求得密钥可能的长度范围的取值，并且还可以求出这个长度下，各组密文对应密钥的可能值（使得这组密文全部能求得ascii范围内的明文的所有可能取值）。</p><p>求出了密钥的长度，以及每一位密钥的可能取值，再测试出每一位密钥可能取值解出原文对应的字频，取其中最符合自然英语的那一个，就可以猜测这是最终的密钥了。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先，求出1~14范围内密钥的取值，如果有空集就证明不能为这个长度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controlFlow</span><span class="params">()</span>:</span></span><br><span class="line">    keyLengthRange = range(<span class="number">1</span>,<span class="number">15</span>)</span><br><span class="line">    cipher = readCipher(<span class="string">'c.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> keyLengthRange:</span><br><span class="line">        keyGroup = getKeyRange(i, cipher)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> keyGroup:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == len(a):</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">#密钥每一位一定有值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#没有空集就通过字频求具体值</span></span><br><span class="line">            ......      <span class="comment">#省略的代码</span></span><br></pre></td></tr></table></figure></p><p>其中，getKeyRange求出每一位密钥的可能值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyRange</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    测试每一位密钥可能的取值，若生成范围之外的明文，就抛弃这个值</span></span><br><span class="line"><span class="string">    否则，就将这个值加入结果集之中</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    cipherGroup = getCipherGroup(keyLength, cipher)</span><br><span class="line">    keyGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perCipherGroup <span class="keyword">in</span> cipherGroup:</span><br><span class="line">        <span class="keyword">for</span> keyTest <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">            <span class="keyword">for</span> perCipher <span class="keyword">in</span> perCipherGroup:</span><br><span class="line">                plainChar = perCipher^keyTest</span><br><span class="line">                <span class="keyword">if</span> plainChar <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyGroup[count].append(keyTest)</span><br><span class="line">        count+=<span class="number">1</span>        <span class="comment">#下一组密文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyGroup</span><br></pre></td></tr></table></figure></p><p>求出密钥范围，就通过字频统计求出具体值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLetterFrequency</span><span class="params">(key, perCipher)</span>:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">求出综合字频</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    frequencies = &#123;<span class="string">"e"</span>: <span class="number">0.12702</span>, <span class="string">"t"</span>: <span class="number">0.09056</span>, <span class="string">"a"</span>: <span class="number">0.08167</span>, <span class="string">"o"</span>: <span class="number">0.07507</span>, <span class="string">"i"</span>: <span class="number">0.06966</span>,</span><br><span class="line">                   <span class="string">"n"</span>: <span class="number">0.06749</span>, <span class="string">"s"</span>: <span class="number">0.06327</span>, <span class="string">"h"</span>: <span class="number">0.06094</span>, <span class="string">"r"</span>: <span class="number">0.05987</span>, <span class="string">"d"</span>: <span class="number">0.04253</span>,</span><br><span class="line">                   <span class="string">"l"</span>: <span class="number">0.04025</span>, <span class="string">"c"</span>: <span class="number">0.02782</span>, <span class="string">"u"</span>: <span class="number">0.02758</span>, <span class="string">"m"</span>: <span class="number">0.02406</span>, <span class="string">"w"</span>: <span class="number">0.02360</span>,</span><br><span class="line">                   <span class="string">"f"</span>: <span class="number">0.02228</span>, <span class="string">"g"</span>: <span class="number">0.02015</span>, <span class="string">"y"</span>: <span class="number">0.01974</span>, <span class="string">"p"</span>: <span class="number">0.01929</span>, <span class="string">"b"</span>: <span class="number">0.01492</span>,</span><br><span class="line">                   <span class="string">"v"</span>: <span class="number">0.00978</span>, <span class="string">"k"</span>: <span class="number">0.00772</span>, <span class="string">"j"</span>: <span class="number">0.00153</span>, <span class="string">"x"</span>: <span class="number">0.00150</span>, <span class="string">"q"</span>: <span class="number">0.00095</span>,</span><br><span class="line">                   <span class="string">"z"</span>: <span class="number">0.00074</span>&#125;        <span class="comment">#各个字母的出现频率</span></span><br><span class="line"></span><br><span class="line">    count=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> perCipher:</span><br><span class="line">        plainChar = key^ch</span><br><span class="line">        <span class="keyword">if</span> plainChar <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>) <span class="keyword">or</span> plainChar <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>):         <span class="comment">#要排除非字母字符</span></span><br><span class="line">            char = chr(plainChar).lower()</span><br><span class="line">            count[char] = count.setdefault(char, <span class="number">0</span>)+<span class="number">1</span>         <span class="comment">#这个字母出现的次数</span></span><br><span class="line"></span><br><span class="line">    freq = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> count:</span><br><span class="line">        freq += frequencies[a]*count[a]/len(perCipher)          <span class="comment">#除以密文长度，以尽可能减小非字母字符对字频的影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyConfirmValue</span><span class="params">(keyGroup,cipher)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算假定某一位上的密钥是正确的情况下，用这个密钥解密密文所出来的明文段落中字母的综合使用频率，正确的密钥这个频率应该尽可能高</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    cipherGroup = getCipherGroup(len(keyGroup), cipher)</span><br><span class="line">    key = []</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perKey <span class="keyword">in</span> keyGroup:</span><br><span class="line">        maxFreq = <span class="number">0</span></span><br><span class="line">        tempKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> perKey:</span><br><span class="line">            freq = getLetterFrequency(a, cipherGroup[count])</span><br><span class="line">            <span class="keyword">if</span> freq&gt;maxFreq:            <span class="comment">#正确的密钥，算出来的综合字频应该尽可能大</span></span><br><span class="line">                maxFreq = freq</span><br><span class="line">                tempKey = a</span><br><span class="line">        key.append(tempKey)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure></p><p>最后解密出原文：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cipherDecrypt</span><span class="params">(key, cipher)</span>:</span></span><br><span class="line">    plainText = <span class="string">''</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> cipher:</span><br><span class="line">        plainText += chr(key[index%len(key)]^a)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> plainText</span><br></pre></td></tr></table></figure></p><p>最终得出的结果为：</p><blockquote><p>A possible key is: [186, 31, 145, 178, 83, 205, 62] </p><p>A possible plainText is: Cryptography is the practice and study of techniques for, among other things, secure communication in the presence of attackers. Cryptography has been used for hundreds, if not thousands, of years, but traditional cryptosystems were designed and evaluated in a fairly ad hoc manner. For example, the Vigenere encryption scheme was thought to be secure for decades after it was invented, but we now know, and this exercise demonstrates, that it can be broken very easily. </p></blockquote><p>题目中说falg是原文最后六个字母，没有标点，因此最终得到的falg为：</p><blockquote><p>nctf{it can be broken very easily}          </p></blockquote><p>对我一点也不简单就是了…</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>觉得很有意义的一道题，通过这道题学习了许多知识点，所以写成了博客。希望文中不对的地方能够被大家指正:)。</p><hr><p><em><del>看了两篇writeup才能做出来什么的…。</del></em></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">https://findneo.github.io/2017/10/nupt-vigenere/</a><br><a href="">http://blog.csdn.net/qq_31344951/article/details/77934717</a><br><a href="">https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81</a><br><a href="">https://www.zhihu.com/question/29515338</a><br><a href="">http://blog.csdn.net/limisky/article/details/16885959</a></p><!--MORE--><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readCipher</span><span class="params">(filename)</span>:</span></span><br><span class="line">    file = open(filename, <span class="string">'r'</span>)</span><br><span class="line">    strCipher = file.read()</span><br><span class="line">    cipher = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(strCipher):</span><br><span class="line">        cipher.append(int(strCipher[index:index+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">        index += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCipherGroup</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    cipherGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; len(cipher):</span><br><span class="line">        cipherGroup[(count) % keyLength] += [cipher[count]]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cipherGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyRange</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    cipherGroup = getCipherGroup(keyLength, cipher)</span><br><span class="line">    keyGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perCipherGroup <span class="keyword">in</span> cipherGroup:</span><br><span class="line">        <span class="keyword">for</span> keyTest <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">            <span class="keyword">for</span> perCipher <span class="keyword">in</span> perCipherGroup:</span><br><span class="line">                plainChar = perCipher^keyTest</span><br><span class="line">                <span class="keyword">if</span> plainChar <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyGroup[count].append(keyTest)</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLetterFrequency</span><span class="params">(key, perCipher)</span>:</span></span><br><span class="line">    frequencies = &#123;<span class="string">"e"</span>: <span class="number">0.12702</span>, <span class="string">"t"</span>: <span class="number">0.09056</span>, <span class="string">"a"</span>: <span class="number">0.08167</span>, <span class="string">"o"</span>: <span class="number">0.07507</span>, <span class="string">"i"</span>: <span class="number">0.06966</span>,</span><br><span class="line">                   <span class="string">"n"</span>: <span class="number">0.06749</span>, <span class="string">"s"</span>: <span class="number">0.06327</span>, <span class="string">"h"</span>: <span class="number">0.06094</span>, <span class="string">"r"</span>: <span class="number">0.05987</span>, <span class="string">"d"</span>: <span class="number">0.04253</span>,</span><br><span class="line">                   <span class="string">"l"</span>: <span class="number">0.04025</span>, <span class="string">"c"</span>: <span class="number">0.02782</span>, <span class="string">"u"</span>: <span class="number">0.02758</span>, <span class="string">"m"</span>: <span class="number">0.02406</span>, <span class="string">"w"</span>: <span class="number">0.02360</span>,</span><br><span class="line">                   <span class="string">"f"</span>: <span class="number">0.02228</span>, <span class="string">"g"</span>: <span class="number">0.02015</span>, <span class="string">"y"</span>: <span class="number">0.01974</span>, <span class="string">"p"</span>: <span class="number">0.01929</span>, <span class="string">"b"</span>: <span class="number">0.01492</span>,</span><br><span class="line">                   <span class="string">"v"</span>: <span class="number">0.00978</span>, <span class="string">"k"</span>: <span class="number">0.00772</span>, <span class="string">"j"</span>: <span class="number">0.00153</span>, <span class="string">"x"</span>: <span class="number">0.00150</span>, <span class="string">"q"</span>: <span class="number">0.00095</span>,</span><br><span class="line">                   <span class="string">"z"</span>: <span class="number">0.00074</span>&#125;</span><br><span class="line"></span><br><span class="line">    count=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> perCipher:</span><br><span class="line">        plainChar = key^ch</span><br><span class="line">        <span class="keyword">if</span> plainChar <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>) <span class="keyword">or</span> plainChar <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>):</span><br><span class="line">            char = chr(plainChar).lower()</span><br><span class="line">            count[char] = count.setdefault(char, <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    freq = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> count:</span><br><span class="line">        freq += frequencies[a]*count[a]/len(perCipher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyConfirmValue</span><span class="params">(keyGroup,cipher)</span>:</span></span><br><span class="line">    cipherGroup = getCipherGroup(len(keyGroup), cipher)</span><br><span class="line">    key = []</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perKey <span class="keyword">in</span> keyGroup:</span><br><span class="line">        maxFreq = <span class="number">0</span></span><br><span class="line">        tempKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> perKey:</span><br><span class="line">            freq = getLetterFrequency(a, cipherGroup[count])</span><br><span class="line">            <span class="keyword">if</span> freq&gt;maxFreq:</span><br><span class="line">                maxFreq = freq</span><br><span class="line">                tempKey = a</span><br><span class="line">        key.append(tempKey)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cipherDecrypt</span><span class="params">(key, cipher)</span>:</span></span><br><span class="line">    plainText = <span class="string">''</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> cipher:</span><br><span class="line">        plainText += chr(key[index%len(key)]^a)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> plainText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controlFlow</span><span class="params">()</span>:</span></span><br><span class="line">    keyLengthRange = range(<span class="number">1</span>,<span class="number">15</span>)</span><br><span class="line">    cipher = readCipher(<span class="string">'c.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> keyLengthRange:</span><br><span class="line">        keyGroup = getKeyRange(i, cipher)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> keyGroup:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == len(a):</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">else</span>:               </span><br><span class="line">            <span class="comment">#print('A possible key group is:', keyGroup,'\n')</span></span><br><span class="line">            key = getKeyConfirmValue(keyGroup, cipher)</span><br><span class="line">            print(<span class="string">'A possible key is:'</span>, key,<span class="string">'\n'</span>)</span><br><span class="line">            plainText = cipherDecrypt(key, cipher)</span><br><span class="line">            print(<span class="string">'A possible plainText is:'</span>, plainText,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    controlFlow()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原题链接：&lt;a href=&quot;&quot;&gt;http://ctf.nuptsast.com/challenges#Vigenere&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分析&lt;/h2&gt;&lt;p&gt;题目原文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is said that Vigenere cipher does not achieve the perfect secrecy actually :-)&lt;br&gt;Tips:&lt;br&gt;1.The encode pragram is given;&lt;br&gt;2.Do u no index of coincidence ？&lt;br&gt;3.The key is last 6 words of the plain text(with “nctf{}” when submitted, also without any interpunction)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加密代码：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; KEY_LENGTH 2 &lt;span class=&quot;comment&quot;&gt;// Can be anything from 1 to 13&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ch;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  FILE *fpIn, *fpOut;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; key[KEY_LENGTH] = &amp;#123;&lt;span class=&quot;number&quot;&gt;0x00&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0x00&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* of course, I did not use the all-0s key to encrypt */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fpIn = fopen(&lt;span class=&quot;string&quot;&gt;&quot;ptext.txt&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fpOut = fopen(&lt;span class=&quot;string&quot;&gt;&quot;ctext.txt&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;w&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;fscanf&lt;/span&gt;(fpIn, &lt;span class=&quot;string&quot;&gt;&quot;%c&quot;&lt;/span&gt;, &amp;amp;ch) != EOF) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* avoid encrypting newline characters */&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* In a &quot;real-world&quot; implementation of the Vigenere cipher, &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       every ASCII character in the plaintext would be encrypted.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       However, I want to avoid encrypting newlines here because &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;       it makes recovering the plaintext slightly more difficult... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* ...and my goal is not to create &quot;production-quality&quot; code =) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ch!=&lt;span class=&quot;string&quot;&gt;&#39;\n&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;fprintf&lt;/span&gt;(fpOut, &lt;span class=&quot;string&quot;&gt;&quot;%02X&quot;&lt;/span&gt;, ch ^ key[i % KEY_LENGTH]); &lt;span class=&quot;comment&quot;&gt;// ^ is logical XOR    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fclose(fpIn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fclose(fpOut);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ctf" scheme="https://arianx.me/categories/ctf/"/>
    
    
      <category term="Python" scheme="https://arianx.me/tags/Python/"/>
    
      <category term="ctf" scheme="https://arianx.me/tags/ctf/"/>
    
      <category term="writeup" scheme="https://arianx.me/tags/writeup/"/>
    
      <category term="密码学" scheme="https://arianx.me/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>
