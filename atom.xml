<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arian.X</title>
  
  <subtitle>独立技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arianx.me/"/>
  <updated>2018-05-14T16:57:14.740Z</updated>
  <id>https://arianx.me/</id>
  
  <author>
    <name>Arian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Explore type and object in python.</title>
    <link href="https://arianx.me/2018/05/14/Explore-the-usage-of-super/"/>
    <id>https://arianx.me/2018/05/14/Explore-the-usage-of-super/</id>
    <published>2018-05-14T14:05:27.000Z</published>
    <updated>2018-05-14T16:57:14.740Z</updated>
    
    <content type="html"><![CDATA[<p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;/p&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://arianx.me/categories/python/"/>
    
    
      <category term="python" scheme="https://arianx.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Flask常见扩展总结</title>
    <link href="https://arianx.me/2018/04/13/The-common-Flask-s-extensions/"/>
    <id>https://arianx.me/2018/04/13/The-common-Flask-s-extensions/</id>
    <published>2018-04-13T05:01:43.000Z</published>
    <updated>2018-04-23T00:43:33.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a>是一个用python编写的、基于<a href="http://werkzeug.pocoo.org/" target="_blank" rel="noopener">Werkzeug WSGI</a>和<a href="http://jinja.pocoo.org/docs/2.10/" target="_blank" rel="noopener">Jinja2</a>的轻量级Web应用框架。因为其相比于django等框架来说简洁的功能与架构，常常被称为”microframework”。然而，称Flask为微框架并不意味着它相比起其它框架来说功能更少——Flask拥有强大的可扩展性以及活跃的社区。开发者可以根据自身的需求，自由的选择扩展包来增强其功能。</p><p>合理的选择扩展包，将极大的减少开发时间，提高开发效率。下面，本文就将列举出Flask应用程序开发中的一些常用扩展，以便于参考和查询。</p><h2 id="Flask-WTF"><a href="#Flask-WTF" class="headerlink" title="Flask-WTF"></a>Flask-WTF</h2><p>Flask-WTF将Flask和<a href="https://wtforms.readthedocs.io/en/stable/" target="_blank" rel="noopener">WTForms</a>做了简单集成，包含<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">CSRF</a>，文件上传，验证码服务等。</p><p>特点：</p><ol><li>集成WTForms</li><li>使用CSRF token保证安全性</li><li>全局CSRF防御</li><li>支持验证码服务</li><li>配合<a href="https://pythonhosted.org/Flask-Uploads/" target="_blank" rel="noopener">Flask-Uploads</a>运作的文件上传服务</li><li>使用<a href="http://pythonhosted.org/Flask-Babel/" target="_blank" rel="noopener">Flask-Babel</a>支持国际化</li></ol><p>Flask-WTF集成了WTForms，使用它，可以以面向对象语言中类的形式构建表单，简化了处理、验证表单所需操作，使表单设计与Flask其它部分统一。</p><p>文档：<a href="https://flask-wtf.readthedocs.io/en/stable/" target="_blank" rel="noopener">Flask-WTF</a></p><h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>Flask-SQLAlchemy为使用Flask开发的应用程序提供了<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>的支持。它支持0.8及以上版本的SQLAlchemy，旨在通过提供有用的默认值和额外的帮助来简化Flask中SQLAlchemy的使用，使完成常见的任务变得更简单。</p><p>SQLAlchemy为python提供了<a href="https://en.wikipedia.org/wiki/Orm" target="_blank" rel="noopener">ORM</a>(对象关系映射)。简单地说，ORM就是为操作不同数据库提供了一个用面向对象思想设计的统一上层接口，隐藏了在具体语言中真实操作、连接数据库的底层实现，从而解耦了应用和数据库，使得方便的更换数据库成为可能。（但同样，正因如此，ORM往往不能覆盖各数据库的特有功能）。通过Flask-SQLAlchemy，可以方便的在Flask使用SQLAlchemy。</p><p>文档：<a href="http://www.pythondoc.com/flask-sqlalchemy/" target="_blank" rel="noopener">Flask-SQLAlchemy</a></p><h2 id="Flask-MongoEngine"><a href="#Flask-MongoEngine" class="headerlink" title="Flask-MongoEngine"></a>Flask-MongoEngine</h2><p>Flask-MongoEngine集成了<a href="http://mongoengine.org/" target="_blank" rel="noopener">MongoEngine</a>。</p><p>通过它能够方便的在Flask中使用MongoDB。</p><p>文档：<a href="http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/" target="_blank" rel="noopener">Flask-MongoEngine</a></p><h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>Flask-Login为Flask提供了用户会话管理。它能够处理如登陆、登出、持久记住用户会话等常见任务。</p><p>它将：</p><ol><li>将活动的用户ID储存在session中，让你能够方便的对他们进行登入登出操作。</li><li>让你能够限制视图只允许登入（或登出）用户访问。</li><li>处理常见的“记住我”功能。</li><li>保护你的用户会话以防被cookie小偷窃取。</li><li>之后可能会与Flask-Principal或其它验证扩展集成。</li></ol><p>然而，它不会：</p><ol><li>将特定的数据库或其它储存方法强加给你。用户如何载入，决定权完全在你的手中。</li><li>限制你使用如用户名和密码，OpenIDs，或其它验证方法。</li><li>处理超出“登入登出”之外的权限。</li><li>处理用户注册或账户重置。</li></ol><p>文档：<a href="https://flask-login.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Login</a></p><h2 id="Flask-Migrate"><a href="#Flask-Migrate" class="headerlink" title="Flask-Migrate"></a>Flask-Migrate</h2><p>Flask-Migrate是一个使用<a href="https://pypi.python.org/pypi/alembic" target="_blank" rel="noopener">Alembic</a>处理Flask应用程序中SQLAlchemy数据库迁移的扩展。数据库操作由Flask命令行接口或通过<a href="grate.readthedocs.io/en/latest/">Flask-Script</a>扩展而得到支持。</p><p>Flask中的SQLAlchemy只有在不存在这个表时才会按照程序中的定义新建一个表。然而，在开发过程中不免要更改表结构，此时就可以借助这个扩展来方便的更新数据库。</p><p>文档：<a href="https://flask-migrate.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a></p><h2 id="Flask-RESTful"><a href="#Flask-RESTful" class="headerlink" title="Flask-RESTful"></a>Flask-RESTful</h2><p>Flask-RESTful是一个为Flask增加了快速绑定REST风格API功能的扩展。它是一个与你已经存在的ORM/库之间协同工作的轻量级抽象。Flask-RESTful鼓励使用最少设置的最佳实践。</p><p>文档:<a href="https://flask-restful.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-RESTful</a></p><h2 id="Flask-Admin"><a href="#Flask-Admin" class="headerlink" title="Flask-Admin"></a>Flask-Admin</h2><p>Flask-Admin解决了在现有数据模型上构建管理界面的无聊问题。通过一定的努力，它能让你使用一个用户友好的界面管理web服务器数据。</p><p>文档：<a href="https://flask-admin.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Admin</a></p><h2 id="Flask-Bcrypt"><a href="#Flask-Bcrypt" class="headerlink" title="Flask-Bcrypt"></a>Flask-Bcrypt</h2><p>Flask-Bcrypt是一个为Flask应用程序提供了Bcrypt散列工具的Flask扩展。</p><p>Bcrypt是一种比MD5或SHA1稍慢，但更加安全、不易碰撞的散列算法。</p><p>文档：<a href="https://flask-bcrypt.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Bcrypt</a></p><a id="more"></a><h2 id="Flask-Cache"><a href="#Flask-Cache" class="headerlink" title="Flask-Cache"></a>Flask-Cache</h2><p>Flask-Cache用于缓存常用Web应用程序页面，从而在下一次请求时直接从缓存中返回而不用再查询、构建页面，从而极大的优化了Web应用程序的响应速度。</p><p>值得注意的是，不是每个页面都适合使用Flask-Cache缓存——数据经常变化的页面不适于被缓存。</p><p>文档：<a href="https://pythonhosted.org/Flask-Cache/" target="_blank" rel="noopener">Flask-Cache</a></p><h2 id="Flask-SSLify"><a href="#Flask-SSLify" class="headerlink" title="Flask-SSLify"></a>Flask-SSLify</h2><p>Flask-SSLify是一个简单扩展，能够将所有访问都重定向到https。</p><p>文档:<a href="https://pypi.python.org/pypi/Flask-SSLify" target="_blank" rel="noopener">Flask-SSLify</a></p><h2 id="Flask-Bootstrap"><a href="#Flask-Bootstrap" class="headerlink" title="Flask-Bootstrap"></a>Flask-Bootstrap</h2><p>Flask-Bootstrap为Flask应用程序提供了内建的Bootstrap支持，从而可以方便的在程序中集成Bootstrap，并且使用扩展提供的默认布局。</p><p>值得注意的是，到目前为止，Flask-Bootstrap似乎默认只支持Bootstrap2、3,不支持Bootstrap4。</p><p>文档：<a href="https://pythonhosted.org/Flask-Bootstrap/" target="_blank" rel="noopener">Flask-Bootstrap</a></p><h2 id="Flask-Principal"><a href="#Flask-Principal" class="headerlink" title="Flask-Principal"></a>Flask-Principal</h2><p>Flask-Principal为Flask提供了用户权限控制。它通过提供一个松散的框架，将位于Web应用程序中的不同部分的两种服务类型提供者（身份验证提供者、用户信息提供者）联系起来。</p><p>文档：<a href="http://pythonhosted.org/Flask-Principal/" target="_blank" rel="noopener">Flask-Principal</a></p><h2 id="Flask-DebugToolbar"><a href="#Flask-DebugToolbar" class="headerlink" title="Flask-DebugToolbar"></a>Flask-DebugToolbar</h2><p>Flask-DebugToolbar为应用程序添加了一个工具栏，包含许多对debugging有益的应用程序相关信息。</p><p>文档：<a href="https://flask-debugtoolbar.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-DebugToolbar</a></p><h2 id="Flask-Security"><a href="#Flask-Security" class="headerlink" title="Flask-Security"></a>Flask-Security</h2><p>Flask-Security支持为Flask应用程序快速添加常用的安全机制。</p><p>文档：<a href="https://pythonhosted.org/Flask-Security/index.html" target="_blank" rel="noopener">Flask-Security</a></p><h2 id="Flask-Paginate"><a href="#Flask-Paginate" class="headerlink" title="Flask-Paginate"></a>Flask-Paginate</h2><p>Flask-Paginate提供了分页工具，可以在模板中快速简洁的创建出分页样式。</p><p>文档：<a href="http://flask-paginate.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Paginate</a></p><h2 id="Flask-Mail"><a href="#Flask-Mail" class="headerlink" title="Flask-Mail"></a>Flask-Mail</h2><p>Flask-Mail为Flask集成了简单的SMTP邮件服务。使用它，可以方便的通过视图和脚本向用户、管理员发送邮件。</p><p>文档：<a href="https://pythonhosted.org/Flask-Mail/" target="_blank" rel="noopener">Flask-Mail</a></p><h2 id="Flask-BasicAuth"><a href="#Flask-BasicAuth" class="headerlink" title="Flask-BasicAuth"></a>Flask-BasicAuth</h2><p>Flask-BasicAuth使用HTTP基础访问验证功能为Flask应用提供了保护某些视图或整个应用的简洁方法。</p><p>Flask-BasicAuth常用于Flask应用程序中API的访问验证。</p><p>文档：<a href="https://flask-basicauth.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-BasicAuth</a></p><h2 id="Flask-Assets"><a href="#Flask-Assets" class="headerlink" title="Flask-Assets"></a>Flask-Assets</h2><p>Flask-Assets集成了webassets。使用它，可以方便的将不同的静态资源文件整合、压缩在一起，从而减少响应的大小，优化Web应用程序的访问速度。</p><p>文档：<a href="https://flask-assets.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Assets</a></p><h2 id="Flask-PageDown"><a href="#Flask-PageDown" class="headerlink" title="Flask-PageDown"></a>Flask-PageDown</h2><p>PageDown是使用JacaScript实现的客户端MarkDown到HTML的转换程序。而Flask-PageDown扩展则将PageDown集成到了Flask-WTF表单字段里。</p><p>文档：<a href="https://github.com/miguelgrinberg/Flask-PageDown" target="_blank" rel="noopener">Flask-PageDown</a></p><h2 id="Flask-HTTPAuth"><a href="#Flask-HTTPAuth" class="headerlink" title="Flask-HTTPAuth"></a>Flask-HTTPAuth</h2><p>Flask-HTTPAuth是一个支持为Flask路由应用一些http验证方法的简单扩展。<br>Flask-HTTPAuth支持HTTPBasicAuth、HTTPDigestAuth、HTTPTokenAuth和混合验证。</p><p>文档：<a href="http://flask-httpauth.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-HTTPAuth</a></p><h2 id="Flask-KVSession"><a href="#Flask-KVSession" class="headerlink" title="Flask-KVSession"></a>Flask-KVSession</h2><p>Flask-KVSessin重写了Flask基于客户端的session机制。不再客户端储存数据，只在客户端储存一个安全生成的ID，而实际数据则储存在服务器端。</p><p>提高了Flask Session机制的安全性。</p><p>文档：<a href="https://pythonhosted.org/Flask-KVSession/" target="_blank" rel="noopener">Flask-Session</a></p><h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-4-13/54750302.jpg" alt="youya"><br>╮(╯-╰)╭</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://flask.pocoo.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask&lt;/a&gt;是一个用python编写的、基于&lt;a href=&quot;http://werkzeug.pocoo.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Werkzeug WSGI&lt;/a&gt;和&lt;a href=&quot;http://jinja.pocoo.org/docs/2.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jinja2&lt;/a&gt;的轻量级Web应用框架。因为其相比于django等框架来说简洁的功能与架构，常常被称为”microframework”。然而，称Flask为微框架并不意味着它相比起其它框架来说功能更少——Flask拥有强大的可扩展性以及活跃的社区。开发者可以根据自身的需求，自由的选择扩展包来增强其功能。&lt;/p&gt;
&lt;p&gt;合理的选择扩展包，将极大的减少开发时间，提高开发效率。下面，本文就将列举出Flask应用程序开发中的一些常用扩展，以便于参考和查询。&lt;/p&gt;
&lt;h2 id=&quot;Flask-WTF&quot;&gt;&lt;a href=&quot;#Flask-WTF&quot; class=&quot;headerlink&quot; title=&quot;Flask-WTF&quot;&gt;&lt;/a&gt;Flask-WTF&lt;/h2&gt;&lt;p&gt;Flask-WTF将Flask和&lt;a href=&quot;https://wtforms.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WTForms&lt;/a&gt;做了简单集成，包含&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSRF&lt;/a&gt;，文件上传，验证码服务等。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集成WTForms&lt;/li&gt;
&lt;li&gt;使用CSRF token保证安全性&lt;/li&gt;
&lt;li&gt;全局CSRF防御&lt;/li&gt;
&lt;li&gt;支持验证码服务&lt;/li&gt;
&lt;li&gt;配合&lt;a href=&quot;https://pythonhosted.org/Flask-Uploads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Uploads&lt;/a&gt;运作的文件上传服务&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;http://pythonhosted.org/Flask-Babel/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Babel&lt;/a&gt;支持国际化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Flask-WTF集成了WTForms，使用它，可以以面向对象语言中类的形式构建表单，简化了处理、验证表单所需操作，使表单设计与Flask其它部分统一。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flask-wtf.readthedocs.io/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-WTF&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-SQLAlchemy&quot;&gt;&lt;a href=&quot;#Flask-SQLAlchemy&quot; class=&quot;headerlink&quot; title=&quot;Flask-SQLAlchemy&quot;&gt;&lt;/a&gt;Flask-SQLAlchemy&lt;/h2&gt;&lt;p&gt;Flask-SQLAlchemy为使用Flask开发的应用程序提供了&lt;a href=&quot;http://www.sqlalchemy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQLAlchemy&lt;/a&gt;的支持。它支持0.8及以上版本的SQLAlchemy，旨在通过提供有用的默认值和额外的帮助来简化Flask中SQLAlchemy的使用，使完成常见的任务变得更简单。&lt;/p&gt;
&lt;p&gt;SQLAlchemy为python提供了&lt;a href=&quot;https://en.wikipedia.org/wiki/Orm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ORM&lt;/a&gt;(对象关系映射)。简单地说，ORM就是为操作不同数据库提供了一个用面向对象思想设计的统一上层接口，隐藏了在具体语言中真实操作、连接数据库的底层实现，从而解耦了应用和数据库，使得方便的更换数据库成为可能。（但同样，正因如此，ORM往往不能覆盖各数据库的特有功能）。通过Flask-SQLAlchemy，可以方便的在Flask使用SQLAlchemy。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;http://www.pythondoc.com/flask-sqlalchemy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-MongoEngine&quot;&gt;&lt;a href=&quot;#Flask-MongoEngine&quot; class=&quot;headerlink&quot; title=&quot;Flask-MongoEngine&quot;&gt;&lt;/a&gt;Flask-MongoEngine&lt;/h2&gt;&lt;p&gt;Flask-MongoEngine集成了&lt;a href=&quot;http://mongoengine.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MongoEngine&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;通过它能够方便的在Flask中使用MongoDB。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-MongoEngine&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-Login&quot;&gt;&lt;a href=&quot;#Flask-Login&quot; class=&quot;headerlink&quot; title=&quot;Flask-Login&quot;&gt;&lt;/a&gt;Flask-Login&lt;/h2&gt;&lt;p&gt;Flask-Login为Flask提供了用户会话管理。它能够处理如登陆、登出、持久记住用户会话等常见任务。&lt;/p&gt;
&lt;p&gt;它将：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将活动的用户ID储存在session中，让你能够方便的对他们进行登入登出操作。&lt;/li&gt;
&lt;li&gt;让你能够限制视图只允许登入（或登出）用户访问。&lt;/li&gt;
&lt;li&gt;处理常见的“记住我”功能。&lt;/li&gt;
&lt;li&gt;保护你的用户会话以防被cookie小偷窃取。&lt;/li&gt;
&lt;li&gt;之后可能会与Flask-Principal或其它验证扩展集成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然而，它不会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将特定的数据库或其它储存方法强加给你。用户如何载入，决定权完全在你的手中。&lt;/li&gt;
&lt;li&gt;限制你使用如用户名和密码，OpenIDs，或其它验证方法。&lt;/li&gt;
&lt;li&gt;处理超出“登入登出”之外的权限。&lt;/li&gt;
&lt;li&gt;处理用户注册或账户重置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flask-login.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Login&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-Migrate&quot;&gt;&lt;a href=&quot;#Flask-Migrate&quot; class=&quot;headerlink&quot; title=&quot;Flask-Migrate&quot;&gt;&lt;/a&gt;Flask-Migrate&lt;/h2&gt;&lt;p&gt;Flask-Migrate是一个使用&lt;a href=&quot;https://pypi.python.org/pypi/alembic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alembic&lt;/a&gt;处理Flask应用程序中SQLAlchemy数据库迁移的扩展。数据库操作由Flask命令行接口或通过&lt;a href=&quot;grate.readthedocs.io/en/latest/&quot;&gt;Flask-Script&lt;/a&gt;扩展而得到支持。&lt;/p&gt;
&lt;p&gt;Flask中的SQLAlchemy只有在不存在这个表时才会按照程序中的定义新建一个表。然而，在开发过程中不免要更改表结构，此时就可以借助这个扩展来方便的更新数据库。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flask-migrate.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Migrate&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-RESTful&quot;&gt;&lt;a href=&quot;#Flask-RESTful&quot; class=&quot;headerlink&quot; title=&quot;Flask-RESTful&quot;&gt;&lt;/a&gt;Flask-RESTful&lt;/h2&gt;&lt;p&gt;Flask-RESTful是一个为Flask增加了快速绑定REST风格API功能的扩展。它是一个与你已经存在的ORM/库之间协同工作的轻量级抽象。Flask-RESTful鼓励使用最少设置的最佳实践。&lt;/p&gt;
&lt;p&gt;文档:&lt;a href=&quot;https://flask-restful.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-RESTful&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-Admin&quot;&gt;&lt;a href=&quot;#Flask-Admin&quot; class=&quot;headerlink&quot; title=&quot;Flask-Admin&quot;&gt;&lt;/a&gt;Flask-Admin&lt;/h2&gt;&lt;p&gt;Flask-Admin解决了在现有数据模型上构建管理界面的无聊问题。通过一定的努力，它能让你使用一个用户友好的界面管理web服务器数据。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flask-admin.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Admin&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Flask-Bcrypt&quot;&gt;&lt;a href=&quot;#Flask-Bcrypt&quot; class=&quot;headerlink&quot; title=&quot;Flask-Bcrypt&quot;&gt;&lt;/a&gt;Flask-Bcrypt&lt;/h2&gt;&lt;p&gt;Flask-Bcrypt是一个为Flask应用程序提供了Bcrypt散列工具的Flask扩展。&lt;/p&gt;
&lt;p&gt;Bcrypt是一种比MD5或SHA1稍慢，但更加安全、不易碰撞的散列算法。&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flask-bcrypt.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask-Bcrypt&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://arianx.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="https://arianx.me/tags/python/"/>
    
      <category term="Flask" scheme="https://arianx.me/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>扔鸡蛋问题</title>
    <link href="https://arianx.me/2018/03/05/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/"/>
    <id>https://arianx.me/2018/03/05/扔鸡蛋问题/</id>
    <published>2018-03-05T14:34:51.000Z</published>
    <updated>2018-04-13T11:46:30.268Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-6/16293116.jpg" alt="sister"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逛知乎的时候偶然看到的一道算法问题，看了回答里大牛给的题解以后感觉解法十分巧妙，所以写一篇博客记载下来。<br>这个问题应该属于动态规划，但本人还没有怎么接触过算法这方面的知识，全属个人理解，所以文中可能有一些不标准的地方，还请见谅啦~，也欢迎指出来。</p><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>有一栋200层高的大楼，给你两个质地相同但软硬未知的鸡蛋。如果在第n层扔下鸡蛋，鸡蛋不碎，那么，从第n-1层以下扔鸡蛋都不碎。如果要想测试出最高从第几层扔下时鸡蛋不会碎，问，在最坏情况下，所扔次数最少为多少？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目要求测试的是最高第几层扔下时不会碎，也就是说，在这一层下，鸡蛋都不会碎，在这一层上，鸡蛋都会碎。并且注意到，题目并没有规定这个层数，而是说在<strong>最坏</strong>的情况下所扔次数<strong>最少</strong>的策略。这也意味着，对于每个策略，鸡蛋可能在不同层数碎，并且总是使当前策略所需测试次数最多的那个层数。而我们所求的，就是在所有策略的最坏情况中，最少的那个次数。</p><h2 id="解题策略"><a href="#解题策略" class="headerlink" title="解题策略"></a>解题策略</h2><p>考虑如果只有一颗鸡蛋，那么就需要从第一层开始，逐一往上测试，直到找到破碎的那一层，这种策略最坏情况下所需次数为100.</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>现在有两颗鸡蛋，那么就可以有一颗用来划定区间，另一颗用来测试鸡蛋将在这个区间的哪一层碎。比如，使用二分法，第一颗鸡蛋扔在50层。如果碎了，就用第二颗鸡蛋从第一层扔到第49层，直到在第49层破碎，那么一共测试了50次；如果鸡蛋不碎，就将第一颗鸡蛋扔在第75层，在根据碎不碎判断接下来的情况。</p><p>可以看出，使用二分法的情况下，最坏的次数需要50次。</p><h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p>不妨假设在这种情况下用两颗鸡蛋测试z层，最少需要x次，考虑选择怎样的策略，才能在最坏的情况下，用这x次测试出最多的层数。</p><p>考虑第一次尝试应该选择扔在哪层楼。假设扔在第y层楼。如果第一颗鸡蛋在第y层楼破碎，那么，接下来需要用剩下来的那颗鸡蛋，最多需要用<code>y-1</code>次尝试测试最终鸡蛋在哪层楼破碎。在这种情况下，根据总是考虑最坏情况这个条件，如果<code>y&gt;x</code>，那最终就无法测试出鸡蛋是哪一层楼（因为最坏情况下鸡蛋在第<code>y-1</code>层楼，而只剩下<code>x-1</code>次尝试的次数）。所以第一次应该扔在<strong>小于等于</strong>x的楼层数。</p><p>考虑<code>y&lt;x</code>的情况。如果鸡蛋在第y层破碎，那么就可以用不到<code>x-1</code>的尝试次数测试出最终楼层；如果鸡蛋在第y层不破碎，那么，问题就转换为怎样用两颗鸡蛋，在<code>x-1</code>次的步骤内测试出<code>z-y</code>层楼里鸡蛋破碎位置的<strong>子问题</strong>。而这个子问题也和先前测试第一次尝试一样，第一颗扔出的鸡蛋不能大于<code>x-1</code>层，如果大于，次数就不够，必需扔在小于<code>x-1</code>次的楼层数。</p><p>这样，每一次不破碎，都生成一个新的独立的子问题。直到最终一颗鸡蛋在某一次测试中破碎，就用剩下的一颗鸡蛋逐一测试最近一次扔鸡蛋和破碎层之间的区间，找出正确答案。因为每一次不破碎都生成的都是<strong>独立</strong>的子问题（当前第一颗鸡蛋选择扔的层数不影响下一个子问题的决策），所以将每一次能测试出的最大的不破碎区间组合起来，就是最终能测试的最多层数。</p><p>因为每一次扔鸡蛋的最远距离就是当前次数的剩余数，所以需要每次测试，都扔在比当前层数大剩余次数的楼层。那么，如果有两颗鸡蛋，用x次尝试次数能确定的鸡蛋不破碎的最多层数就为<code>x+(x-1)+(x-2)...+1</code>。</p><p>回到原题来。原题要求求出用两颗鸡蛋测试200层楼所需的最少次数，也就是说需要<code>x+(x-1)+(x-2)...+1&gt;200</code>，也就是<code>x(x+1)/2&gt;200</code>，解出来就是x取整最少需要20次。</p><h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>以上是从推理方面来考察，现在从程序逻辑的方面考虑。</p><p>有200层楼，用两颗鸡蛋去测试使鸡蛋不碎的最高层数，要求求出最坏情况下的最小尝试次数。也就是，设初始选择扔在第y层，f(y)为在这种策略下的所需要的最多的次数，我们所求的为所有策略中最小的次数。如果第一颗鸡蛋在y层就破碎，那么所需要的次数就为y次，如果第一颗鸡蛋在y层不破碎，那么问题就转换为一个求用两颗鸡蛋测试200-y层所需要的最坏情况下的最少次数的子问题。</p><p>所以，状态转移方程就为：f(x)=min(max(i, f(i-1)+1))，(0&lt; i&lt;= x)。退出条件为i==0时，需要0次。</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>使用了python实现，并且使用了functools库里面的lru_cache，这个装饰器会缓存函数结果，如果给函数传入了相同的参数，就直接返回缓存的结果。</p><p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    res = min([max(i, test(m-i)+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">200</span>))</span><br><span class="line"><span class="comment">#结果：14</span></span><br></pre></td></tr></table></figure></p><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>同理，如果推广到更一般的情况下，用n颗鸡蛋取测试m层的大楼，求最坏情况下的最少次数。首先选定一个楼层y，扔出第一颗鸡蛋。如果这颗鸡蛋破碎了，问题就转化为用n-1颗鸡蛋去测试m-1层楼的子问题；如果没碎，问题就转化为用n颗鸡蛋去测试m-y的子问题。</p><p>于是，在这种情况下的状态转移方程就为：f(m,n)=min(max(f(m-1,n-1), f(m-y,n)))+1，(0&lt; y&lt; m+1)。退出条件为当m==0时，需要0次；当n==1时，需要m次。</p><h3 id="推广情况程序实现"><a href="#推广情况程序实现" class="headerlink" title="推广情况程序实现"></a>推广情况程序实现</h3><p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    res = min([max(test(n<span class="number">-1</span>, i<span class="number">-1</span>), test(n, m-i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">2</span>,<span class="number">36</span>))</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">https://www.zhihu.com/question/19690210/answer/18079633</a><br><a href="">http://www.raychase.net/1374</a><br><a href="">http://blog.csdn.net/baolinq/article/details/53047288</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-6/16293116.jpg&quot; alt=&quot;sister&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="算法" scheme="https://arianx.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://arianx.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>新学期开始</title>
    <link href="https://arianx.me/2018/03/03/%E6%96%B0%E5%AD%A6%E6%9C%9F/"/>
    <id>https://arianx.me/2018/03/03/新学期/</id>
    <published>2018-03-03T05:17:24.000Z</published>
    <updated>2018-05-14T14:07:14.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你永远不会知道，为了对生活感兴趣，我们究竟付出了多少努力。</p></blockquote><p>寒假偶然遇到一首很喜欢的音乐——雨降りお月さん（雨中的月亮），歌手为堀江由衣，是在补番过程中遇到的一首插曲。这首优美、朦胧，具有淡淡哀愁意境的歌在当时带给我十分深刻的印象。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29091584&auto=0&height=66"></iframe><blockquote><p>雨降りお月さん （雨中的月亮，1925年）<br>作詞：野口雨情 作曲：中山晋平<br>歌词整理编译：九日旭（Guanxu）<br><br>雨降あめふりお月つきさん　雲くもの蔭かげ          雨中的月亮 躲在云背后<br>お嫁よめにゆくときゃ　誰だれとゆく      出嫁的时候 要和谁一起去<br>一人ひとりで傘からかさ　さして行ゆく          独自一人 撑伞前行<br>からかさないときゃ　誰だれとゆく    没有伞的话 又和谁一起呢<br>シャラシャラ　シャンシャン      叮叮当当<br>鈴すずつけた          铃声响   <br><br>お馬うまにゆられて　濡ぬれてゆく      在马上摇摇晃晃，冒雨前行<br>急いそがにゃお馬うまよ　夜よが明あけよう    马儿啊快些走 就要天亮了<br>手綱たづなの下したから ちょいと見みたりゃ   马儿从缰绳下面 瞄一下我<br>お袖そででお顔かほを　隠かくしてる          我用衣袖轻遮颜面<br>お袖そでは濡ぬれても　干ほしゃ乾かわく      衣袖湿了 晾晾就干<br>雨降あめふりお月つきさん　雲くもの蔭かげ          雨中的月亮 躲在云背后<br>お馬うまにゆられて　濡ぬれてゆく      在马上摇摇晃晃，冒雨前行<br><br>歌曲由两段原独立的两段歌词组成。第一段由野口雨情创作于大正14年（1925年）的儿童绘画杂志《コドモノクニ》一月号，并且刊登有相应杂志。后由作曲家中山晋平的建议改为歌曲，并受到大人孩子们的欢迎。为此，野口雨情以同一主题创作了一个续篇，以标题”雲の蔭“刊登在同年儿童绘画杂志《コドモノクニ》三月号上，同样配有装帧画并附带乐谱。在发售唱片时，因为原曲太短，两段词合起来作为一首歌。<br><br>歌曲描述了一位新娘子在骑马到婆家的雨路上的历程。配词充满童趣，同时引人幻想。然而，就如这隐隐约约透漏着哀愁、彷徨的旋律一样，这首歌具有这样的“黑色”背景：野口雨情的两个女儿都在年幼时夭折，而根据当地有这样的传说，如果新娘子是已经死去的女儿，那么她就会一个人独自启程去天国，而云背后（雲の蔭)的月亮正是隐喻中的天国。也许，这首歌正是野口雨情对其女儿亡灵的祝福。<br><br>参考自<a href="">http://blog.sina.com.cn/s/blog_4a4b274c0102wjwf.html</a></p></blockquote><p>除此之外，回过头来，整个寒假实在没有什么值得大肆回忆的内容。除了断断续续完成假期伊始订下的一些计划的日常（尽管到最后这些计划也没有来得及全部完成），就是一些琐碎的，在各种彷徨之中逝去的时间。旧的自己已经看起来渐渐消失，然而，新的自己尚没有来临，就是在这样的迷茫之中逝去的时间。</p><p>而新学期又要来临了。大学的第一个学期就这样完整的过去。到这里，也不再是可以以“新手”、“不适应”这样的话语来为自己找借口的时候了吧。</p><p>“给我振作起来啊，混蛋!”。希望新学期能够努力一点。</p><p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-3/20421160.jpg" alt="miku"><br>最后，为有miku的世界献上祝福。:p</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你永远不会知道，为了对生活感兴趣，我们究竟付出了多少努力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;寒假偶然遇到一首很喜欢的音乐——雨降りお月さん（雨中的月亮），歌手为堀江由衣，是在补番过程中遇到的一首插曲。这首优美、朦胧，具有淡淡哀愁意境的歌在
      
    
    </summary>
    
      <category term="随笔" scheme="https://arianx.me/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="https://arianx.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="https://arianx.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>南邮ctf训练平台Vigenere writeup</title>
    <link href="https://arianx.me/2018/02/04/%E5%8D%97%E9%82%AEctf%E8%AE%AD%E7%BB%83%E5%B9%B3%E5%8F%B0Vigenere%20writeup/"/>
    <id>https://arianx.me/2018/02/04/南邮ctf训练平台Vigenere writeup/</id>
    <published>2018-02-04T11:10:44.000Z</published>
    <updated>2018-05-14T14:06:07.497Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原题链接：<a href="">http://ctf.nuptsast.com/challenges#Vigenere</a></p></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目原文：</p><blockquote><p>It is said that Vigenere cipher does not achieve the perfect secrecy actually :-)<br>Tips:<br>1.The encode pragram is given;<br>2.Do u no index of coincidence ？<br>3.The key is last 6 words of the plain text(with “nctf{}” when submitted, also without any interpunction)</p></blockquote><p>加密代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> KEY_LENGTH 2 <span class="comment">// Can be anything from 1 to 13</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> ch;</span><br><span class="line">  FILE *fpIn, *fpOut;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> key[KEY_LENGTH] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  <span class="comment">/* of course, I did not use the all-0s key to encrypt */</span></span><br><span class="line"></span><br><span class="line">  fpIn = fopen(<span class="string">"ptext.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  fpOut = fopen(<span class="string">"ctext.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fpIn, <span class="string">"%c"</span>, &amp;ch) != EOF) &#123;</span><br><span class="line">    <span class="comment">/* avoid encrypting newline characters */</span>  </span><br><span class="line">    <span class="comment">/* In a "real-world" implementation of the Vigenere cipher, </span></span><br><span class="line"><span class="comment">       every ASCII character in the plaintext would be encrypted.</span></span><br><span class="line"><span class="comment">       However, I want to avoid encrypting newlines here because </span></span><br><span class="line"><span class="comment">       it makes recovering the plaintext slightly more difficult... */</span></span><br><span class="line">    <span class="comment">/* ...and my goal is not to create "production-quality" code =) */</span></span><br><span class="line">    <span class="keyword">if</span> (ch!=<span class="string">'\n'</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(fpOut, <span class="string">"%02X"</span>, ch ^ key[i % KEY_LENGTH]); <span class="comment">// ^ is logical XOR    </span></span><br><span class="line">      i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fclose(fpIn);</span><br><span class="line">  fclose(fpOut);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>密文：<a href="">http://ctf.nuptsast.com/static/uploads/9a27a6c8b9fb7b8d2a07ad94924c02e5/code.txt</a></p><hr><p>可以看出，这道题的加密方式是维吉尼亚密码的变体。</p><p>原先的维吉尼亚加密，是指定一个密钥，然后将密钥循环与原文中每一个字母对应，这个字母偏移密钥在字母表中的序号后的新字母即为最终结果。如图：<br><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-2-4/56426864.jpg" alt="维吉尼亚加密"></p><p>而这道题是用1到14个长度范围内，未知的密钥，一一，并且循环与明文异或，跳过换行符，将每一位异或的结果输出为两位16位数作为密文。与传统维吉尼亚偏移的加密方式相比，使用了异或的形式来加密原文。</p><h2 id="维吉尼亚密码回顾"><a href="#维吉尼亚密码回顾" class="headerlink" title="维吉尼亚密码回顾"></a>维吉尼亚密码回顾</h2><p>要解这道题，先回顾传统维吉尼亚密码的解密形式。</p><p>我们知道，与凯撒密码不同之处在于，维吉尼亚密码中，一个字母可能生成几个不同的密文，因此，不能像凯撒密码那样用轮转密文的方法来破解维吉尼亚密码。要破解维吉尼亚密码，首先要理解到，虽然维吉尼亚密码打乱了字母与密文一一对应的关系，但同一位密钥所对应的不同密文，却有着相同的偏移量。也就是说，如果知道了密钥的长度，那每一位密钥所加密的那一组密文就像是凯撒密码那样有<strong>相同的偏移量</strong>。</p><p>所以如果能找出密钥的长度，那我们就能将密文分隔成几组由不同偏移量凯撒加密所形成的密文。</p><p>又有，在自然英语中，各个字母的<strong>使用频率</strong>不同，即一些字母使用频率高些，另一些字母使用频率低些。比如说，字母e的使用频率最高，约0.12，字母z的使用频率最低，为0.00074。据此，就可以分别统计出前述几组密文中各字母的出现频率，在对比自然英语字母的使用频率，然后就能猜测每一位密文所对应的原文。根据一组密文拥有相同的偏移量这一点，就可猜测出最终的密钥。</p><p>因而，解密维吉尼亚密码的第一步在于找出密钥的长度。只要找出了密钥的长度，就可以统计字频猜测具体密钥。</p><p>怎样才能求出密钥的长度？这里引入十分重要的一点，也是求解维吉尼亚密码的关键，即<strong>重合指数</strong>（index of coincidence）。重合指数是指，在一串字母中，任意取出两个字母，这两个字母相同的概率。例如，随机给出一串混乱的字母，它的重合指数总会在0.45附近，而一串有意义的英语段落，因为字母使用频率的影响，重合指数总是会在0.65附近，并且段落越长越接近这两个值。</p><p>易见的是，给一串字母相同的偏移量，并不会改变这串字母的重合指数。因此，通过同一位密钥加密而成的那一组维吉尼亚密文，因为它是有意义的段落，它的重合指数应该接近于自然英语的重合指数0.68。根据这一点，就可以猜测密钥的长度，再计算各个长度下密钥的重合指数（每个长度下的几组可以取均值），结果最接近0.68的那个结果，就可以大胆猜测是密钥的长度。</p><p>求出了密钥的长度，就可以如上述那样通过字频统计求出每一位密钥进而解密出原文了。</p><h2 id="本题解法"><a href="#本题解法" class="headerlink" title="本题解法"></a>本题解法</h2><p>知道了传统维吉尼亚密码的解法，再看本题，也就不难了。虽然本题最终采用了异或的方式来加密原文，而不是传统维吉尼亚密码的偏移，但最终，只要能够求出密钥的长度，都可以使用字频分析的方法来计算出密钥来解密。</p><p>所以说，求解本题，主要也是首先确定密钥长度。</p><p>这里第一个思路就可以像以上求传统维吉尼亚密码那样通过计算重合指数来确定。然而有一点不可忽视的是，重合指数法只适合于给出的密文全部由字母加密而成的情况。传统维吉尼亚密码只能加密字母（偏移），这道题则通过异或的方法来加密，使得任意字符都可以生成对应的密文。因此，由于其它非字母字符的干扰，就无法求出准确的重合指数，也就难以通过重合指数法寻找出密钥长度。</p><p>注意到，本题使用的是异或形式来加密。是否还记得异或有几个独特性质：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a^a = 0         //一个数异或本身等于零</span><br><span class="line">a^0 = a         //一个数异或零等于本身</span><br><span class="line">(a^b)^c = a^(b^c)       //异或满足结合律</span><br><span class="line">a^b^b = a       //因此，一个数两次异或同一个数等于本身</span><br></pre></td></tr></table></figure></p><p>本题的密文是由明文与密钥异或而来的，因此 <code>明文^密钥 = 密文</code>，也就是<code>明文 = 密文^密钥</code>。关键点是，<strong>明文一定是由ascii字符组成的，并且密钥一定存在</strong>。如果假定出密钥的长度，那么可以将密文划分成相应的几组，密钥的取值范围又在一定的范围之内（unsigned char ，0~255）。因此，如果在假定的长度下，某一组密文在这个范围内找不到合理的密钥（使得与密文异或为ascii字符的密钥），那就说明密钥不可能是这个长度。</p><p>通过这种方式，就可以求得密钥可能的长度范围的取值，并且还可以求出这个长度下，各组密文对应密钥的可能值（使得这组密文全部能求得ascii范围内的明文的所有可能取值）。</p><p>求出了密钥的长度，以及每一位密钥的可能取值，再测试出每一位密钥可能取值解出原文对应的字频，取其中最符合自然英语的那一个，就可以猜测这是最终的密钥了。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先，求出1~14范围内密钥的取值，如果有空集就证明不能为这个长度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controlFlow</span><span class="params">()</span>:</span></span><br><span class="line">    keyLengthRange = range(<span class="number">1</span>,<span class="number">15</span>)</span><br><span class="line">    cipher = readCipher(<span class="string">'c.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> keyLengthRange:</span><br><span class="line">        keyGroup = getKeyRange(i, cipher)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> keyGroup:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == len(a):</span><br><span class="line">                <span class="keyword">break</span>;          <span class="comment">#密钥每一位一定有值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#没有空集就通过字频求具体值</span></span><br><span class="line">            ......      <span class="comment">#省略的代码</span></span><br></pre></td></tr></table></figure></p><p>其中，getKeyRange求出每一位密钥的可能值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyRange</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    测试每一位密钥可能的取值，若生成范围之外的明文，就抛弃这个值</span></span><br><span class="line"><span class="string">    否则，就将这个值加入结果集之中</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    cipherGroup = getCipherGroup(keyLength, cipher)</span><br><span class="line">    keyGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perCipherGroup <span class="keyword">in</span> cipherGroup:</span><br><span class="line">        <span class="keyword">for</span> keyTest <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">            <span class="keyword">for</span> perCipher <span class="keyword">in</span> perCipherGroup:</span><br><span class="line">                plainChar = perCipher^keyTest</span><br><span class="line">                <span class="keyword">if</span> plainChar <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyGroup[count].append(keyTest)</span><br><span class="line">        count+=<span class="number">1</span>        <span class="comment">#下一组密文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyGroup</span><br></pre></td></tr></table></figure></p><p>求出密钥范围，就通过字频统计求出具体值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLetterFrequency</span><span class="params">(key, perCipher)</span>:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">求出综合字频</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">    frequencies = &#123;<span class="string">"e"</span>: <span class="number">0.12702</span>, <span class="string">"t"</span>: <span class="number">0.09056</span>, <span class="string">"a"</span>: <span class="number">0.08167</span>, <span class="string">"o"</span>: <span class="number">0.07507</span>, <span class="string">"i"</span>: <span class="number">0.06966</span>,</span><br><span class="line">                   <span class="string">"n"</span>: <span class="number">0.06749</span>, <span class="string">"s"</span>: <span class="number">0.06327</span>, <span class="string">"h"</span>: <span class="number">0.06094</span>, <span class="string">"r"</span>: <span class="number">0.05987</span>, <span class="string">"d"</span>: <span class="number">0.04253</span>,</span><br><span class="line">                   <span class="string">"l"</span>: <span class="number">0.04025</span>, <span class="string">"c"</span>: <span class="number">0.02782</span>, <span class="string">"u"</span>: <span class="number">0.02758</span>, <span class="string">"m"</span>: <span class="number">0.02406</span>, <span class="string">"w"</span>: <span class="number">0.02360</span>,</span><br><span class="line">                   <span class="string">"f"</span>: <span class="number">0.02228</span>, <span class="string">"g"</span>: <span class="number">0.02015</span>, <span class="string">"y"</span>: <span class="number">0.01974</span>, <span class="string">"p"</span>: <span class="number">0.01929</span>, <span class="string">"b"</span>: <span class="number">0.01492</span>,</span><br><span class="line">                   <span class="string">"v"</span>: <span class="number">0.00978</span>, <span class="string">"k"</span>: <span class="number">0.00772</span>, <span class="string">"j"</span>: <span class="number">0.00153</span>, <span class="string">"x"</span>: <span class="number">0.00150</span>, <span class="string">"q"</span>: <span class="number">0.00095</span>,</span><br><span class="line">                   <span class="string">"z"</span>: <span class="number">0.00074</span>&#125;        <span class="comment">#各个字母的出现频率</span></span><br><span class="line"></span><br><span class="line">    count=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> perCipher:</span><br><span class="line">        plainChar = key^ch</span><br><span class="line">        <span class="keyword">if</span> plainChar <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>) <span class="keyword">or</span> plainChar <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>):         <span class="comment">#要排除非字母字符</span></span><br><span class="line">            char = chr(plainChar).lower()</span><br><span class="line">            count[char] = count.setdefault(char, <span class="number">0</span>)+<span class="number">1</span>         <span class="comment">#这个字母出现的次数</span></span><br><span class="line"></span><br><span class="line">    freq = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> count:</span><br><span class="line">        freq += frequencies[a]*count[a]/len(perCipher)          <span class="comment">#除以密文长度，以尽可能减小非字母字符对字频的影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyConfirmValue</span><span class="params">(keyGroup,cipher)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算假定某一位上的密钥是正确的情况下，用这个密钥解密密文所出来的明文段落中字母的综合使用频率，正确的密钥这个频率应该尽可能高</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    cipherGroup = getCipherGroup(len(keyGroup), cipher)</span><br><span class="line">    key = []</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perKey <span class="keyword">in</span> keyGroup:</span><br><span class="line">        maxFreq = <span class="number">0</span></span><br><span class="line">        tempKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> perKey:</span><br><span class="line">            freq = getLetterFrequency(a, cipherGroup[count])</span><br><span class="line">            <span class="keyword">if</span> freq&gt;maxFreq:            <span class="comment">#正确的密钥，算出来的综合字频应该尽可能大</span></span><br><span class="line">                maxFreq = freq</span><br><span class="line">                tempKey = a</span><br><span class="line">        key.append(tempKey)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure></p><p>最后解密出原文：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cipherDecrypt</span><span class="params">(key, cipher)</span>:</span></span><br><span class="line">    plainText = <span class="string">''</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> cipher:</span><br><span class="line">        plainText += chr(key[index%len(key)]^a)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> plainText</span><br></pre></td></tr></table></figure></p><p>最终得出的结果为：</p><blockquote><p>A possible key is: [186, 31, 145, 178, 83, 205, 62] </p><p>A possible plainText is: Cryptography is the practice and study of techniques for, among other things, secure communication in the presence of attackers. Cryptography has been used for hundreds, if not thousands, of years, but traditional cryptosystems were designed and evaluated in a fairly ad hoc manner. For example, the Vigenere encryption scheme was thought to be secure for decades after it was invented, but we now know, and this exercise demonstrates, that it can be broken very easily. </p></blockquote><p>题目中说falg是原文最后六个字母，没有标点，因此最终得到的falg为：</p><blockquote><p>nctf{it can be broken very easily}          </p></blockquote><p>对我一点也不简单就是了…</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>觉得很有意义的一道题，通过这道题学习了许多知识点，所以写成了博客。希望文中不对的地方能够被大家指正:)。</p><hr><p><em><del>看了两篇writeup才能做出来什么的…。</del></em></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="">https://findneo.github.io/2017/10/nupt-vigenere/</a><br><a href="">http://blog.csdn.net/qq_31344951/article/details/77934717</a><br><a href="">https://zh.wikipedia.org/wiki/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81</a><br><a href="">https://www.zhihu.com/question/29515338</a><br><a href="">http://blog.csdn.net/limisky/article/details/16885959</a></p><!--read more--><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readCipher</span><span class="params">(filename)</span>:</span></span><br><span class="line">    file = open(filename, <span class="string">'r'</span>)</span><br><span class="line">    strCipher = file.read()</span><br><span class="line">    cipher = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; len(strCipher):</span><br><span class="line">        cipher.append(int(strCipher[index:index+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">        index += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCipherGroup</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    cipherGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; len(cipher):</span><br><span class="line">        cipherGroup[(count) % keyLength] += [cipher[count]]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cipherGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyRange</span><span class="params">(keyLength, cipher)</span>:</span></span><br><span class="line">    cipherGroup = getCipherGroup(keyLength, cipher)</span><br><span class="line">    keyGroup = [[] <span class="keyword">for</span> a <span class="keyword">in</span> range(keyLength)]</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perCipherGroup <span class="keyword">in</span> cipherGroup:</span><br><span class="line">        <span class="keyword">for</span> keyTest <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">255</span>):</span><br><span class="line">            <span class="keyword">for</span> perCipher <span class="keyword">in</span> perCipherGroup:</span><br><span class="line">                plainChar = perCipher^keyTest</span><br><span class="line">                <span class="keyword">if</span> plainChar <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyGroup[count].append(keyTest)</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLetterFrequency</span><span class="params">(key, perCipher)</span>:</span></span><br><span class="line">    frequencies = &#123;<span class="string">"e"</span>: <span class="number">0.12702</span>, <span class="string">"t"</span>: <span class="number">0.09056</span>, <span class="string">"a"</span>: <span class="number">0.08167</span>, <span class="string">"o"</span>: <span class="number">0.07507</span>, <span class="string">"i"</span>: <span class="number">0.06966</span>,</span><br><span class="line">                   <span class="string">"n"</span>: <span class="number">0.06749</span>, <span class="string">"s"</span>: <span class="number">0.06327</span>, <span class="string">"h"</span>: <span class="number">0.06094</span>, <span class="string">"r"</span>: <span class="number">0.05987</span>, <span class="string">"d"</span>: <span class="number">0.04253</span>,</span><br><span class="line">                   <span class="string">"l"</span>: <span class="number">0.04025</span>, <span class="string">"c"</span>: <span class="number">0.02782</span>, <span class="string">"u"</span>: <span class="number">0.02758</span>, <span class="string">"m"</span>: <span class="number">0.02406</span>, <span class="string">"w"</span>: <span class="number">0.02360</span>,</span><br><span class="line">                   <span class="string">"f"</span>: <span class="number">0.02228</span>, <span class="string">"g"</span>: <span class="number">0.02015</span>, <span class="string">"y"</span>: <span class="number">0.01974</span>, <span class="string">"p"</span>: <span class="number">0.01929</span>, <span class="string">"b"</span>: <span class="number">0.01492</span>,</span><br><span class="line">                   <span class="string">"v"</span>: <span class="number">0.00978</span>, <span class="string">"k"</span>: <span class="number">0.00772</span>, <span class="string">"j"</span>: <span class="number">0.00153</span>, <span class="string">"x"</span>: <span class="number">0.00150</span>, <span class="string">"q"</span>: <span class="number">0.00095</span>,</span><br><span class="line">                   <span class="string">"z"</span>: <span class="number">0.00074</span>&#125;</span><br><span class="line"></span><br><span class="line">    count=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> perCipher:</span><br><span class="line">        plainChar = key^ch</span><br><span class="line">        <span class="keyword">if</span> plainChar <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>) <span class="keyword">or</span> plainChar <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>):</span><br><span class="line">            char = chr(plainChar).lower()</span><br><span class="line">            count[char] = count.setdefault(char, <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    freq = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> count:</span><br><span class="line">        freq += frequencies[a]*count[a]/len(perCipher)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> freq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKeyConfirmValue</span><span class="params">(keyGroup,cipher)</span>:</span></span><br><span class="line">    cipherGroup = getCipherGroup(len(keyGroup), cipher)</span><br><span class="line">    key = []</span><br><span class="line"></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> perKey <span class="keyword">in</span> keyGroup:</span><br><span class="line">        maxFreq = <span class="number">0</span></span><br><span class="line">        tempKey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> perKey:</span><br><span class="line">            freq = getLetterFrequency(a, cipherGroup[count])</span><br><span class="line">            <span class="keyword">if</span> freq&gt;maxFreq:</span><br><span class="line">                maxFreq = freq</span><br><span class="line">                tempKey = a</span><br><span class="line">        key.append(tempKey)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cipherDecrypt</span><span class="params">(key, cipher)</span>:</span></span><br><span class="line">    plainText = <span class="string">''</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> cipher:</span><br><span class="line">        plainText += chr(key[index%len(key)]^a)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> plainText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">controlFlow</span><span class="params">()</span>:</span></span><br><span class="line">    keyLengthRange = range(<span class="number">1</span>,<span class="number">15</span>)</span><br><span class="line">    cipher = readCipher(<span class="string">'c.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> keyLengthRange:</span><br><span class="line">        keyGroup = getKeyRange(i, cipher)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> keyGroup:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> == len(a):</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">        <span class="keyword">else</span>:               </span><br><span class="line">            <span class="comment">#print('A possible key group is:', keyGroup,'\n')</span></span><br><span class="line">            key = getKeyConfirmValue(keyGroup, cipher)</span><br><span class="line">            print(<span class="string">'A possible key is:'</span>, key,<span class="string">'\n'</span>)</span><br><span class="line">            plainText = cipherDecrypt(key, cipher)</span><br><span class="line">            print(<span class="string">'A possible plainText is:'</span>, plainText,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    controlFlow()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原题链接：&lt;a href=&quot;&quot;&gt;http://ctf.nuptsast.com/challenges#Vigenere&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="ctf" scheme="https://arianx.me/categories/ctf/"/>
    
    
      <category term="python" scheme="https://arianx.me/tags/python/"/>
    
      <category term="ctf" scheme="https://arianx.me/tags/ctf/"/>
    
      <category term="writeup" scheme="https://arianx.me/tags/writeup/"/>
    
      <category term="密码学" scheme="https://arianx.me/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>
