<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="记录自己的学习与生活"/><link rel="alternate" href="/atom.xml" title="Arian's Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://arianx.me/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7da15ed69b10673f5e71fb736eca6373";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Arian's Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Arian's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>

    <div class="container" id="mobile-panel" style="z-index:0">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Arian's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about">
            关于
            </a>
        </li>
      </ul></nav>

<div class="waifu" style="z-index:9999">
    <div class="waifu-tips" style="z-index:9999"></div>
    <canvas id="live2d" width="240" height="220" class="live2d" style="z-index:9999"></canvas>
</div>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/note-of-gfs/">GFS 面面观</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span><span class="post-category">
            <a href="/categories/分布式/">分布式</a>
            <a href="/categories/分布式/算法/">算法</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>paper: <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf</a></p>
</blockquote>
<p>GFS 是 Google 设计的一个用于大规模数据密集型应用的、可扩展的分布式文件系统，部署在普通硬件设备上，并且能够为用户提供出色的性能和灾难冗余能力。虽然 Google 并没有将 GFS 开源，但是却在 2004 年发布了一篇论文公布了其一些技术细节，影响了以后的诸多分布式文件系统。</p>
<p>本文是对原论文要点的记录。</p>
<h2 id="设计假设"><a href="#设计假设" class="headerlink" title="设计假设"></a>设计假设</h2><p>GFS 与传统文件系统共享某些相同的设计目标，如性能、可伸缩性、可靠性以及可用性。然而，GFS 的设计人员审视了他们的应用环境以及使用场景，并基于此给为 GFS 提供了某些不同的设计假设：</p>
<ol>
<li>组件失效是常态事件，而不是意外事件。<ul>
<li>GFS 部署在几百甚至几千台普通的廉价商业设备上。因此在任何时刻都有可能有某些硬件无法访问或工作异常。因此 GFS 从设计初期考虑到这一点，以将持续监控、错误检测、灾难冗余和自动恢复集成到 GFS 中为目标。</li>
</ul>
</li>
<li>巨大的文件。<ul>
<li>存储在 GFS 中文件通常是巨大的，数 GB 的文件很普遍。因此，需要重新审视分布式文件系统中的某些设计决策，如 I/O 操作和 block 的大小等。</li>
</ul>
</li>
<li>大部分修改的文件操作以追加写入而不是随机写入的方式。<ul>
<li>用户通常对文件进行追加写入，然后大量的顺序读。而不是频繁的随机读写。因此，GFS 特别为追加写入而优化，并保证其是原子性的。</li>
</ul>
</li>
<li>应用程序和 GFS 协同设计。<ul>
<li>通过放宽对一致性的要求，采用弱一致性模型，大大简化了 GFS 的设计。引入了原子性的追加写入操作，不需要额外的同步设计。</li>
</ul>
</li>
</ol>
<h2 id="设计概述"><a href="#设计概述" class="headerlink" title="设计概述"></a>设计概述</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>虽然 GFS 提供了一套与传统文件系统类似的 API 接口，但并非完全符合 POSIX 标准。GFS 支持如创建新文件、删除文件、打开文件、关闭文件、读写文件、快照等操作。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>GFS 包含一个单独的 master 节点，以及多个 Chunk 服务器节点。整体架构如图:</p>
<p><img src="https://arian-blogs.oss-cn-beijing.aliyuncs.com/compressed-03k7.jpg" alt="figure"></p>
<p>具体上来说：</p>
<ul>
<li>GFS 储存的文件都被分成固定大小的 Chunk，并且被复制在多个 Chunk 服务器上。在一个 Chunk 被创建的时候，master 会分给 chunk 一个全局唯一的标识。默认情况下，一个 Chunk 拥有三个储存复制节点。</li>
<li>master 节点拥有所有的元数据，如：名字空间、访问控制信息、文件和 Chunk 的映射，Chunk 和位置的映射等。master 还管理系统范围内的活动，如 Chunk lease 管理、垃圾回收、Chunk 迁移等。master 会发送心跳包定期和 Chunk 服务器交互以知晓其状态。</li>
<li>客户端只和 master 交互获得元数据，然后再根据元数据和 Chunk 服务器直接交互。</li>
</ul>
<h3 id="单一-master"><a href="#单一-master" class="headerlink" title="单一 master"></a>单一 master</h3><p>单一 master 简化了整个系统的设计，但在另一种意义上，也很容易成为整个系统的瓶颈。因此必须尽量减少对 master 节点的读写。因此，客户端不从 master 节点获取数据。而是告诉 master 要读取的文件和区域，然后 master 返回这个区域所在的 chunk 服务器的位置。由客户端自己联系 Chunk 服务器获取数据。</p>
<h3 id="Chunk-尺寸"><a href="#Chunk-尺寸" class="headerlink" title="Chunk 尺寸"></a>Chunk 尺寸</h3><p>Chunk 的大小是设计要素之一。 GFS 选择一个 Chunk 为 64 MB，远大于常规文件系统的 block size。选取一个大的 Chunk 大小有如下优点：</p>
<ol>
<li>减少了客户端和 master 的通信需求。从而降低 master 的工作负载。</li>
<li>采用较大的尺寸，可以对一个块进行更多的操作。通过与 Chunk 服务器保持长时间 tcp 链接，从而降低网络负载。</li>
<li>减少了 master 需要保存在内存中的元数据信息。</li>
</ol>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>master 储存三种类型元数据：</p>
<ol>
<li>文件和 Chunk 的命名空间。</li>
<li>文件和 Chunk 的映射关系。</li>
<li>每个 Chunk 副本的存放地点。</li>
</ol>
<p>前两种数据会定期被写入日志文件中，并被同步到远程服务器。当 master 发生崩溃时，就可以借助这些备份以恢复服务。第三种数据由 master 启动或运行时，向每个 Chunk 服务器轮询获取信息。</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>定义：</p>
<ul>
<li>一致：如果所有客户端无论从哪个副本读，读到的数据都是一样的，那么就认为这个数据是一致的。</li>
<li>已定义：修改文件之后，相关数据是一致的，并且客户端能够读取到它刚才修改的内容，那么相关数据是已定义的。已定义暗含了一致。</li>
</ul>
<p>GFS 提供一个弱一致性模型。对于并发随机写入操作来说，数据是一致的，但是未定义的。对于追加写入操作来说，客户端总是可以读取到一致并且已定义的数据，但是实际储存在各个 Chunk 服务器上的数据可能有部分是不一致的。</p>
<p>GFS 通过以下几点保证数据一致性：</p>
<ul>
<li>对 Chunk 的所有副本修改操作顺序一致。</li>
<li>使用 Chunk 版本号来检测副本因为服务器宕机而失效。</li>
<li>与服务器定期握手来找到失效的 Chunk 服务器。</li>
<li>使用 Checksum 来校验数据是否损坏。</li>
</ul>
<h2 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h2><h3 id="lease"><a href="#lease" class="headerlink" title="lease"></a>lease</h3><p>GFS 使用 lease 来保证写入写入操作的一致性。master 会选出 chunk 的一个副本来发放 lease，称为副本的主 Chunk 服务器。这个 lease 有效期为 60s。当过了有效期之后，master 可能会选出一个新副本发放 lease。当有写入请求时，master 返回给客户端所有副本的位置以及哪一个副本持有 lease。客户端发送数据给最近的副本，然后数据沿拓扑向流向所有副本。当所有的副本都受到了数据后，客户端发送消息给主 Chunk 服务器。主 Chunk 服务器为收到的所有请求分配连续的序号，这些请求可能来自不同的客户端。它按照这个顺序将改变应用于自己的本地磁盘中，然后将顺序推送给所有从服务器。</p>
<p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/compressed-yay3.jpg" alt="figure"></p>
<p>所有从 Chunk 服务器返回成功的消息给主 Chunk 服务器之后，主 Chunk 服务器才向客户端返回成功的消息。</p>
<p>如果有任何从 Chunk 服务器执行失败，主 Chunk 服务器会将这个错误报告给客户端，由客户端来重新发起请求。</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>数据流与写入操作的控制流程是分离的。在客户端收到 master 发送的位置信息后，它从这些位置中选出一个最近的 Chunk 服务器发送数据。然后数据沿着 Chunk 服务器顺序链发送给所有需要的 Chunk 服务器。</p>
<h3 id="原子追加记录"><a href="#原子追加记录" class="headerlink" title="原子追加记录"></a>原子追加记录</h3><p>GFS 保证追加记录的原子性。当存在多个并发的追加记录时，GFS 对于每个追加记录至少有一次是写入成功的。GFS 指定写入的偏移量并且在之后返回。</p>
<p>追加记录在之前描述的控制流程之上加了一些额外的步骤。对于一次指定的追加记录来说，主 Chunk 服务器会检查给定 Chunk 的大小。如果追加记录使得这个 Chunk 的大小超过限制，服务器会填充这个 Chunk 到最大大小然后指示客户端发起请求写入下一个 Chunk。</p>
<p>如果追加记录在任意一个 Chunk 服务器失败了，客户端需要进行重新操作。重新操作的结果是，同一个 Chunk 的副本可能拥有不一致的记录。GFS 不保证所有副本在字节序上是完全一致的，但至少保证有一次成功的写入。</p>
<p>因此，追加记录将使数据是一致的，但可能包含部分不一致的局部数据，如填充和错误。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>写时复制。master 维持一个对所有 chunk 服务器的引用计数。当客户端发起一次快照请求时，并不实际进行复制，而是将相应服务器的引用计数加一。当对相应服务器发起写入请求时，master 注意到它的引用计数大于一，然后才复制一个新的 chunk，并指示客户端写入这个新 chunk。引用计数减一。</p>
<h2 id="master-节点操作"><a href="#master-节点操作" class="headerlink" title="master 节点操作"></a>master 节点操作</h2><h3 id="名称空间管理和锁"><a href="#名称空间管理和锁" class="headerlink" title="名称空间管理和锁"></a>名称空间管理和锁</h3><p>GFS 的名称空间是一个全局路径和元数据映射关系的查找表。这个表使用前缀压缩储存在内存中。在名称空间的属性结构上，每个节点都是都有一个关联的读写锁。</p>
<p>每个 master 节点的操作开始之前，都需要获得其路径上所有节点的读锁，以及最终节点的读写锁。</p>
<h3 id="重新复制、负载均衡"><a href="#重新复制、负载均衡" class="headerlink" title="重新复制、负载均衡"></a>重新复制、负载均衡</h3><p>当 master 节点创建一个新的 chunk 时，它会选择放置初始空间的位置，会考虑几个因素：</p>
<ul>
<li>在低于平均硬盘使用率的 Chunk 服务器上创建副本以平衡硬盘使用率。</li>
<li>限制每个 Chunk 服务器最近的 Chunk 创建次数。因为创建操作通常意味着之后又大量的写入操作。</li>
<li>为了容错性，使 Chunk 分布在多个机架。</li>
</ul>
<p>当 Chunk 的有效副本数少于用户指定的复制数量时，master 节点会重新复制它。<br>同时，master 节点会周期性地进行负载均衡，检查当前副本的分布情况，然后移动副本以获得更好的空间利用率。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>GFS 在文件删除之后并不会立刻回收可用的物理空间。而是采用惰性回收的策略。<br>当删除一个文件时，只是把文件重命名为一个特殊的文件名以使其不可见，在实际删除之前，仍然可以恢复。</p>
<h3 id="失效检测"><a href="#失效检测" class="headerlink" title="失效检测"></a>失效检测</h3><p>master 节点维持有所有 Chunk 的版本号。客户机或 Chunk 服务器在执行操作时都会验证版本号。<br>master 在例行的垃圾回收工作中移除所有失效的副本。</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="master-节点的复制"><a href="#master-节点的复制" class="headerlink" title="master 节点的复制"></a>master 节点的复制</h3><p>为了保证 master 节点的可靠性，master 服务器的状态也要复制。master 服务器的所有操作日志和 checkpoint 会被复制到多台远程机器上。<br>此外，GFS 中还有”影子” master 服务器，这些影子服务器在 master 宕机时提供只读访问。它们的数据通常比 master 更新得慢一点。</p>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>每个 Chunk 服务器使用 Checksum 来检查保存的数据是否损坏。对于读操作来说，在把数据返回给客户端或者其它的 Chunk 服务器之前，Chunk 服务器会校验读取操作涉及的范围内的块的 Checksum，因此 Chunk 服务器不会把错误数据传递到其它机器上。如果某个 Checksum 不正确，Chunk 服务器返回给请求者错误信息并通知 master，master 会重新复制副本以替代错误版本。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/21/Notes-on-Reading-the-MapPapers/">MapReduce 阅读纪要</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-21
        </span><span class="post-category">
            <a href="/categories/分布式/">分布式</a>
            <a href="/categories/分布式/算法/">算法</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>paper： <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf</a></p>
</blockquote>
<p>MapReduce 指一个由 Google 提出的，用于在集群上使用并行、分布式算法处理大规模数据的编程模型，以及一系列相关实现。本文是我阅读 Google 原论文之后的一些纪要。</p>
<h2 id="MapReduce-模型"><a href="#MapReduce-模型" class="headerlink" title="MapReduce 模型"></a>MapReduce 模型</h2><p>在 lisp 以及许多其它函数式语言中，常常存在用于处理顺序表数据结构的 <a href="https://en.wikipedia.org/wiki/Map_\(higher-order_function" target="_blank" rel="noopener">map</a>、<a href="https://en.wikipedia.org/wiki/Fold_\(higher-order_function" target="_blank" rel="noopener">reduce</a> 等原语。在本质上，它们是能够以一个顺序表及处理函数为参数的<a href="https://en.wikipedia.org/wiki/Higher-order_function" target="_blank" rel="noopener">高阶函数</a>。 </p>
<p>map 将一一以顺序表中的元素为参数调用这个处理函数，并以这些调用返回的结果作为元素形成一个新的顺序表。也就是说，这个处理函数将作用于原顺序表中的每一个元素。以 python 为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># square</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(result)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure></p>
<p>reduce 同样将遍历顺序表，但它以前一次处理函数返回的结果，以及当前元素为参数递归的调用处理函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sum</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> a, b: a + b, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>Google 受这些原语所启发，发现大多数现实世界的分布式作业拥有与其相似的特征。例如，我们可以以这样的方式来统计一大堆文档集合里的词频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(key: string, value: string)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> value:</span><br><span class="line">        emit(word, <span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(key: string, values: Iterator)</span>:</span></span><br><span class="line">    emit(string(len(values)))</span><br></pre></td></tr></table></figure></p>
<p>在这里，map 常常接受文件名和内容作为参数，返回一系列键值对。reduce 以键名和其相关的一系列值为参数，返回最终的结果。在上面的例子中，map 将读取文档内容，然后返回形位 <code>word: &quot;1&quot;</code> 形式的键值对。MapReduce 实现会将键名相同的值集合在一起，传递给 reduce 函数。而 reduce 函数则简单统计了键对应值的数量。</p>
<p>在单处理器环境中以这种模型运行，不一定会获得比通常方式更高的效率。然而，正如文章开始所说的那样，MapReduce 应用于分布式计算。在实践中，这种受限的模型，能够让框架方便地将任务分布式化，并自动处理诸如数据划分、容错、负载均衡等任务。</p>
<p>MapReduce 模型中的 Map，是由用户指定的函数。Map 接收一个 key/value pair 值，并且产生一系列中间 key/value pair 值。MapReduce 库将拥有相同 key 值的 pair 聚合在一起并传给 Reduce 函数。</p>
<p>Reduce 同样由用户定义。它接受一个 key 以及一系列相关的 value，形成更小的 value 集合。典型地一个 Reduce 调用产生零个或一个 value 值。</p>
<p>通过将输入数据自动划分为 M 个片段，Map 在多台机器上被分布式地调用。通过将 Map 产生的结果划分为 R 份，Reduce 也能在多台机器上调用。R 的数量和划分函数通常是由用户指定的。</p>
<p>MapReduce 模型的典型执行流程如下：</p>
<ol>
<li>一开始，用户程序中的 MapReduce 库将输入文件划分为 M 段。段的大小可配置，通常为 64M。然后，用户程序在集群机器中创建程序的副本。</li>
<li>其中一个副本被指定为 master。其余的都是由 master 分配任务的 workers。这里有 M 个 Map 任务，以及 R 个 Reduce 任务可以分配。 master 将选择一个空闲的 worker 分配任务。</li>
<li>被指定了 map 任务的 worker 将读取响应的输入的划分。它从输入中解析出 key/value pair，然后传递给用户定义的 Map 函数，将产生的中间 key/value pair 缓存在内存中。</li>
<li>缓存的数据周期性地写入本地磁盘，由划分函数划分为 R 个区域。这些区域地位置将发送给 master，以被 master 转发给 reduce work。</li>
<li>所有的 map 任务完成后，master 开始分配 reduce 任务。master 将对应的地址传送给 reduce worker。reduce worker 通过远程过程调用读取这些区域的内容。读取完之后，reduce work 通过键将这些内容排序。然后将拥有相同的 key 的 values 传递给用户定义的 Reduce 函数。Reduce 函数的输出将会被追加到分区对应的文件中。</li>
<li>reduce 任务完成后，返回用户调用 MapReduce 过程的地方，继续执行用户接下来的程序。</li>
</ol>
<h2 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h2><h3 id="Worker-错误"><a href="#Worker-错误" class="headerlink" title="Worker 错误"></a>Worker 错误</h3><p>master 会周期性地 ping 每一个 worker，如果在一段时间之内，一个 worker 都没有响应，那么 master 会认为这个 worker 发生了错误。如果这个 worker 执行的是 map 任务，那么这个 worker 执行过的所有任务都将被 master 安排在其它 worker 上重新执行。如果执行的是 reduce 任务，那么当前执行的任务会被安排在其它 worker 上重新执行。</p>
<p>之所以要重新执行失败 map worker 上的所有任务，是因为 map worker 产生的输出是保存在本地磁盘上的，一旦失败则无法读取。而 reduce worder 的输出保存在全局文件系统上，失败只需要重新执行当前任务即可。</p>
<h3 id="Master-错误"><a href="#Master-错误" class="headerlink" title="Master 错误"></a>Master 错误</h3><p>周期地将 master 保存地数据结构保存为 checkpoint 存入磁盘。一旦 master 发生错误，就从最近保存的 checkpoint 中恢复。</p>
<h3 id="失效处理机制"><a href="#失效处理机制" class="headerlink" title="失效处理机制"></a>失效处理机制</h3><p>当用户定义的 Map 和 Reduce 是确定性的时，MapReduce 的输入输出和在程序串行、没有出现错误的情况下执行的输入输出是一致的。MapReduce 通过自身文件系统的原子性操作保证这一点成立。<br>值得注意的是，MapReduce 的错误处理都假设在 fail-stop 上，由于硬件或软件原因的结果错误无法处理。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h3><p>网络容易成为整个系统的限制。因此，MapReduce 可以构建于一个分布式文件系统（例如： gfs）之上。在分配任务时，MapReduce 从文件系统之中读取各个文件储存的位置，然后让 map worker 读取最近的输入，从而降低对网络的要求。</p>
<h3 id="任务细度"><a href="#任务细度" class="headerlink" title="任务细度"></a>任务细度</h3><p>为了更好的负载均衡和容错策略，通常使 M 和 R 为 worker 数量的几倍。</p>
<h3 id="备份任务"><a href="#备份任务" class="headerlink" title="备份任务"></a>备份任务</h3><p>实践表明，大部分 worker 都执行完毕的情况下，仍然在执行的几个 worker 可能由于机器的软硬件因素仍然要执行很长时间。因此，MapReduce 会自动将最后几个任务备份到多个 worker 上执行。以先完成的为结果。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="划分函数"><a href="#划分函数" class="headerlink" title="划分函数"></a>划分函数</h3><p>默认情况下，通常通过哈希来划分输入。然而，如果用户有某些特别需求可以自定义划分函数。</p>
<h3 id="保证排序"><a href="#保证排序" class="headerlink" title="保证排序"></a>保证排序</h3><p>传递给 Reduce 函数的 values 是经过排序的。</p>
<h3 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h3><p>可以给 Map 提供一个合并函数。这个合并函数通常和 Reduce 函数一样，在 Map 完成之后本地调用，以减少最终需要网络传输的数据数量。</p>
<h3 id="跳过坏任务"><a href="#跳过坏任务" class="headerlink" title="跳过坏任务"></a>跳过坏任务</h3><p>可能由于用户代码或某些第三方库的原因，一些任务的执行将始终失败。worker 在失败时会发送一条消息给 master。master 会记住任务失败的次数。如果次数太多，会跳过这个任务的执行。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/01/25/flask-source-code-read/">Flask 源码的二三事</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-25
        </span><span class="post-category">
            <a href="/categories/python/">python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>本文将基于 Flask 1.1.dev ( <a href="https://github.com/pallets/flask/commit/a74864ec229141784374f1998324d2cbac837295" target="_blank" rel="noopener">a74864</a> )，分析 Flask 源码之中一些有趣并且值得关注的部分，包括 路由机制、请求流程、上下文管理 等等。</p>
<h2 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h2><p>本节关注 Flask 的路由机制。首先还是先看下 Flask 的 hello world：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure></p>
<p>跟进 route 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        endpoint = options.pop(<span class="string">'endpoint'</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></p>
<p>可见 route 方法实际上根据给定的参数另外调用了 add_url_rule：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint=None, view_func=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 provide_automatic_options=None, **options)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> endpoint <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        endpoint = view_func.__name__</span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    methods = options.pop(<span class="string">'methods'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rule = self.url_rule_class(rule, methods=methods, **options)</span><br><span class="line"></span><br><span class="line">    self.url_map.add(rule)</span><br><span class="line">    <span class="comment"># self.view_functions = &#123;&#125;</span></span><br><span class="line">    self.view_functions[endpoint] = view_func</span><br></pre></td></tr></table></figure></p>
<p>添加路由的逻辑最终由 add_url_rule 这个方法实现。它的参数里 rule 就是要匹配 url 的模式，endpoint 是这个视图的端点名，view_func 是我们定义的函数。默认情况下，endpoint 为函数的名字。我们根据这些信息调用了 self.url_rule_class 方法，并用其返回值作为参数调用了 self.url_map.add。最后，将 endpoint 作为键，我们定义的函数作为值，添加进了 self.view_functions 字典。</p>
<p>这里 self.url_rule_class 和 self.url_map 是什么呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    url_rule_class = Rule</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(...)</span>:</span></span><br><span class="line">        self.url_map = Map()</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>可见，Flask 路由机制的核心是 Map 和 Rule 类，而这两个类都来自 Flask 高度依赖的 werkzeug 包。因此，想要明白 Flask 路由的原理，首先我们必须对 werkzeug 有一定了解。这里我们先看下 Map 和 Rule 的简单用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自 werkzeug docs</span></span><br><span class="line">url_map = Map()</span><br><span class="line">url_map.add(</span><br><span class="line">    Rule(<span class="string">'/&lt;id&gt;'</span>, endpoint=<span class="string">'user'</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">   adapter = self.url_map.bind_to_environ(request.environ)</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       endpoint, values = adapter.match()</span><br><span class="line">       <span class="keyword">return</span> getattr(self, <span class="string">'on_'</span> + endpoint)(request, **values)</span><br><span class="line">   <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">       <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure></p>
<p>这里的 request.environ 中的 evniron 是 wsgi 应用中传入 __call__ 方法的一个参数。</p>
<p>调用 Map.bind_to_environ，根据给定请求的 environ 字典，生成了一个 URLAdapter。然后，调用 adapter 上的 match 方法，就能够得到此次请求对应的端点名和对应 url 的参数。比如说，如果此次请求是 <code>http://localhost:5000/foo</code>，那么返回的 endpoint 和 values 就为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoint == <span class="string">'user'</span></span><br><span class="line">values == &#123;<span class="string">"id"</span>: <span class="string">"foo"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，这里 Rule 对应的是每一条之后需要匹配的 url 规则，Map 将这些规则收集起来，对应这些规则的映射。之后，当有请求来的时候，就绑定 environ 生成 adapter，并调用 match 得到匹配的端点和参数。</p>
<p>现在我们返回 Flask。前面我们在 Flask 应用的初始化过程中生成了 Map 的一个实例。之后的每一次使用 route，在默认情况下把函数名作为 endpoint，生成一个新的 Rule 对象。并将它添加进 Map 实例中。最后将 endpoint 和函数本身作为键值添加进字典。</p>
<p>Map 是通过遍历 Rule，并一一匹配正则表达式来匹配路由的。这点目前不详细叙述，日后在另一篇文章中讲下吧。</p>
<p>用户方面添加路由的流程大致是这样了。下面我们从处理请求的流程中看路由机制的另一个方面。</p>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>本节关注 Flask wsgi 应用的实现。我们查看 Flask 类的 __call__ 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 生成请求上下文</span></span><br><span class="line">        ctx = self.request_context(environ)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 推入上下文栈</span></span><br><span class="line">                ctx.push()</span><br><span class="line">                <span class="comment"># 分发路由</span></span><br><span class="line">                response = self.full_dispatch_request()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                error = e</span><br><span class="line">                <span class="comment"># 处理异常</span></span><br><span class="line">                response = self.handle_exception(e)</span><br><span class="line">                <span class="comment"># 最终得到包含了返回信息的 werkzeug Response 实例，调用它完成请求。</span></span><br><span class="line">            <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 这里 finally 语句会在 return 之前执行</span></span><br><span class="line">            <span class="comment"># 弹出请求上下文对象</span></span><br><span class="line">            ctx.auto_pop(error)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>这里 __call__ 方法仅仅将逻辑交给了 wsig_app 方法。这样做的一个好处在于，如果之后要为整个应用添加中间件，就不用处理整个 Flask 实例，直接替换 wsgi_app 方法即可，不用担心实例中的大量配置被丢失或覆盖：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> middleware, app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以这样用：</span></span><br><span class="line">app.wsgi_app = middleware(app.wsgi_app)</span><br><span class="line"><span class="comment"># 而不是:</span></span><br><span class="line">app = middleware(app)</span><br></pre></td></tr></table></figure></p>
<p>回到 wsgi_app 方法，可以看到 response 由 self.full_dispatch_request 生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rv = self.dispatch_request()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        rv = self.handle_user_exception(e)</span><br><span class="line">    <span class="comment"># 将视图函数返回的值转换为合法的 response</span></span><br><span class="line">    <span class="keyword">return</span> self.finalize_request(rv)</span><br></pre></td></tr></table></figure></p>
<p>跟进 slef.dispatch_request:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 得到请求上下文栈顶的 request 对象</span></span><br><span class="line">    req = _request_ctx_stack.top.request</span><br><span class="line">    rule = req.url_rule</span><br><span class="line">    <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br></pre></td></tr></table></figure></p>
<p>注意到这里出现了上一节里面的 self.view_functions，它的键是视图的端点名，值是视图对应的函数。这里我们通过 rule.endpoint 和 req.view_args 调用了视图函数，说明此时我们已经通过请求相关的信息(environ)，匹配到了对应的 url 和参数。</p>
<p>调用我们储存在 self.view_functions 里的视图函数得到请求的返回值以后，就将它传给了 self.finalize_request，将之转化为一个合法的响应对象后返回。</p>
<p>然而，这里的问题是，我们明明没有显示调用 self.url_map.bind_to_environ 与 adapter.match，是怎样从 _request_ctx_stack.top.request 里得到正确信息的呢？实际上，奥秘隐藏在 Flask 的请求上下文机制里。</p>
<h2 id="请求上下文Ⅰ"><a href="#请求上下文Ⅰ" class="headerlink" title="请求上下文Ⅰ"></a>请求上下文Ⅰ</h2><p>用过 Flask 的同学一定对其 request 对象映像深刻。不像 django 等框架，在每个视图函数里，都需要传入一个 request 参数，在 Flask 中，可以直接使用从全局导入的 request 对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/show')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(request.environ)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br></pre></td></tr></table></figure></p>
<p>request 自动适配每一个来到的请求。我们看看 request 的真面目：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> getattr(top, name)</span><br><span class="line"></span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">'request'</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里一时间让我们不明所以。我们看到 _request_ctx_stack 原来是 werkzeug 中 LocalStack 的实例（注意 _request_ctx_stack 在上一节 dispatch_request 中出现过），request 是 LocalProxy 的实例。</p>
<h4 id="LocalStack"><a href="#LocalStack" class="headerlink" title="LocalStack"></a>LocalStack</h4><p>为了理解这一段代码，我们需要先了解 LocalStack 的用法。简单来说，这里的 LocalStack 类似于 <a href="https://stackoverflow.com/questions/104983/what-is-thread-local-storage-in-python-and-why-do-i-need-it" target="_blank" rel="noopener">线程本地变量</a>，在一个的线程中修改它的值，对于其它线程来说是透明的。更具体的说，这里的 LocalStack 是一个 线程本地栈，在一个线程中给这个栈推入或弹出值，并不会影响其它线程中的 LocalStack。</p>
<p>LocalStack 的实现依赖于 werkzeug 中的 Local 类，我们先查看 Local 类的源码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实例中只能修改 __storage__ 和 __ident_func__ 这两个属性</span></span><br><span class="line">    <span class="comment"># 节省内存空间</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 因为本类已经有了 __setattr__ 方法，为了避免循环调用</span></span><br><span class="line">        <span class="comment"># 直接从 object.__setattr__ 给它的属性设置值</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        <span class="comment"># get_ident 得到每个线程的唯一 id</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 释放线程本地变量</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># self.__ident__func 获取线程 id</span></span><br><span class="line">            <span class="comment"># 得到 __storage__ 字典里对应本线程字典中键为 name 的值</span></span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在这个实例上设置属性，会将它储存在本线程对应的字典里</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 线程 id</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除一个属性，删除本线程对应字典里的值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure></p>
<p>Local 类的实例是一个线程本地变量。它在内部维护了一个 __storage__ 字典，这个字典的键为各线程的 id，值为字典，储存对应线程上设置的值。它通过 __setattr__ 等特殊方法，将属性访问转发给内部的 __storage__ 字典。这样，对于不同的线程，Local 的实例上储存的值是不同的。</p>
<p>注意到 Local 类中有一个 __slots__ 属性。这是一个特殊属性，拥有它的类的实例上不会有 __dict__ 字典，从而节省了内存空间。文档中说：</p>
<blockquote>
<p>The __slots__ declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because __dict__ is not created for each instance.</p>
</blockquote>
<p>相应的，拥有 __slots__ 的类，其实例也不被允许赋予 __slots__ 中规定外的属性。</p>
<p>还是让我们继续看 LocalStack 的源码吧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 保存了上面 Local 的实例，一个线程本地变量。</span></span><br><span class="line">        self._local = Local()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 释放内部的线程本地变量</span></span><br><span class="line">        self._local.__release_local__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Pushes a new item to the stack"""</span></span><br><span class="line">        rv = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># self._local 是线程本地变量。储存在它上面的属性会储存在其内部的 __storage__ 字典中</span></span><br><span class="line">            <span class="comment"># 这样，对于不同的线程来说，self._local.stack 这个栈也是不同的</span></span><br><span class="line">            self._local.stack = rv = []</span><br><span class="line">        rv.append(obj)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Removes the topmost item from the stack, will return the</span></span><br><span class="line"><span class="string">        old value or `None` if the stack was already empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">elif</span> len(stack) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果 stack 只剩最后一个，为节省内存，将内部的字典释放</span></span><br><span class="line">            self.__release_local__()</span><br><span class="line">            <span class="keyword">return</span> stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则弹出栈顶</span></span><br><span class="line">            <span class="keyword">return</span> stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""The topmost item on the stack.  If the stack is empty,</span></span><br><span class="line"><span class="string">        `None` is returned.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._local.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</span><br><span class="line">            <span class="comment"># 如果栈中还没有元素，不报错而是返回 None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>结合前面的 LocalStack 看，Local 的用法就很明显了。它使用前面的线程本地变量，模仿了一个线程本地栈。与实际的栈不同的地方还在于，当栈为空时，不弹出异常，而是返回 None。同时，当弹出栈最后一个元素时，线程本地变量中维护的本地的字典将会被提前释放以节省内存空间。</p>
<p>现在我们了解 LocalStack 了，我们可以发现 _request_ctx_stack 实际上就是 LocalStack 的实例，一个线程本地栈。实际上，_request_ctx_stack 就是 Flask 中至关重要的<strong>请求上下文栈</strong>。当然，现在它仍然空空如也，只有当有也新的请求进入时，服务器会新建一个线程，然后使用上一节中的<code>ctx.push()</code>推入新的请求上下文。</p>
<h4 id="LocalProxy"><a href="#LocalProxy" class="headerlink" title="LocalProxy"></a>LocalProxy</h4><p>然而我们这里仍然没触及到我们最感兴趣的 request，它还与 LocalProxy 类相关：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 节省内存</span></span><br><span class="line">    __slots__ = (<span class="string">'__local'</span>, <span class="string">'__dict__'</span>, <span class="string">'__name__'</span>, <span class="string">'__wrapped__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, local, name=None)</span>:</span></span><br><span class="line">        <span class="comment"># 它本身有 __setattr__，避免循环调用</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'_LocalProxy__local'</span>, local)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__name__'</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self.__local, <span class="string">'__release_local__'</span>):</span><br><span class="line">            <span class="comment"># 如果不是线程本地变量，作为函数调用并返回。</span></span><br><span class="line">            <span class="comment"># 例如，前面的 request ，传入的参数就不是直接的线程本地变量，而是一个 </span></span><br><span class="line">            <span class="comment"># partial 了的函数</span></span><br><span class="line">            <span class="keyword">return</span> self.__local()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__local, self.__name__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'no object bound to %s'</span> % self.__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dict__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 转发给它代理的线程本地变量</span></span><br><span class="line">            <span class="keyword">return</span> self._get_current_object().__dict__</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">'__dict__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 转发给它代理的线程本地变量</span></span><br><span class="line">            <span class="keyword">return</span> bool(self._get_current_object())</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 它还有许多与上面两个方法相似的代理</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>LocalProxy 是一个有意思的类，结合前面我们给出的 <code>request = LocalProxy(partial(_lookup_req_object, &#39;request&#39;))</code> 语句就会更有意思。它接受一个线程本地变量，然后将对它的实例的几乎所有访问，都会转发给那个线程本地变量上的指定属性。并且在那个属性不存在时弹出 RuntimeError 异常。</p>
<p>注意到它的 __init__ 方法中的 <code>object.__setattr__(self, &#39;_LocalProxy__local&#39;, local)</code>语句。这里使用 object.__setattr__ 是为了避免循环调用，因为它自己也实现了 __setattr__ 方法（并将它转发给线程本地变量上的属性）。这里使用了 _LocalProxy__local 这个名称，然而在之后却直接以 __local 访问。这是因为 __local 是一个双下划线方法，在自身以外的类访问时，会被重命名。</p>
<p>前面我们提到过，__slots__ 特殊属性会删除实例的 __dict__ 字典，并以恒定空间储存实例属性，以节省内存。然而这里在 __slots__ 中，又加回了 __dict__ 方法。本来因为 __slots__ 的原因，将要删除的字典，这里又额外添加进来，这是不是有几分做无用功的意味？</p>
<p>实际上，这也是为了节省内存而做的努力。这里必须存在 __dict__ 原因，是因为 LocalProxy 也会将对自身的属性访问转发给其代理的对象，因此必须允许对 __dict__ 的访问。我们已经为了节省内存，在 __slots__ 中设定了 __local、__name__ 等属性，这样，这些属性将会被存放在固定的空间中而非 __dict__。然而，没有 __dict__，尝试对实例其它属性赋值时，就会直接引起 AttributeError，使得我们无法对其作转发。因此，我们为其添加 __dict__ 属性以重新允许对实例属性的赋值。当然，此时所有属性的赋值实际会被转发给其代理对象。</p>
<p>值得注意的是，即使重新规定了 __dict__，当对实例属性赋值时，规定在 __slots__ 中的其它属性，仍会被储存在固定空间而非 __dict__ 字典，从而 LocalProxy 实例上的 __dict__ 字典实际会一直为空。对线程本地变量的代理，以及 __slots__ 属性的优先级，两者一起使得实例虽然有 __dict__ 属性，却不会浪费使 __slots__ 失效的更多空间。</p>
<p>好，关于它的 __slots__ 的问题到此为止。我们需要知道这个类会将访问转发给线程本地变量上的一个属性。对于我们的 request 而言，我们传入了 <code>partial(_lookup_req_object, &#39;request&#39;)</code> 作为参数生成它。这里我们回顾一下 _lookup_req_object 的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> getattr(top, name)</span><br></pre></td></tr></table></figure></p>
<p>它会查看栈顶是否有请求上下文，如果有，就返回想要的属性，否则弹出异常。结合 LocalProxy ，可以看出，实际上，<strong>request一直是请求上下文栈顶的对象的”request”属性</strong>。并且这个 request 对于各个请求来说是独立的。当请求上下文为空时，会弹出 RuntimeError。</p>
<h2 id="请求上下文Ⅱ"><a href="#请求上下文Ⅱ" class="headerlink" title="请求上下文Ⅱ"></a>请求上下文Ⅱ</h2><p>现在我们了解到 request 是 _request_ctx_stack 这个请求上下文栈的栈顶对象里面的 “request” 属性，但实际上虽然我们知晓了请求上下文栈的存在，却还不了解具体在这个上下文栈中储存了什么对象，因而不能理解它的实质。为了了解 request 的实质，我们回顾前面的请求流程。</p>
<p>前面提到过，Flask 也以 wsgi 的应用呈现。最后，Flask 的 app 实例会暴露出一个 __call__ 方法，给应用服务器访问。应用服务器会给 __call__ 方法传入代表请求上下文信息的 environ 字典，以及一个设置 response header 和 status 的 start_response 回调函数。</p>
<p>Flask 将 __call__ 方法转发给 wsgi_app 方法。注意到 wsig_app 方法中的 <code>ctx = self.request_context(environ)</code> 语句，以及之后的 <code>ctx.push()</code> 和最后的 <code>ctx.auto_pop(error)</code> 语句。实际上，就是这些语句将我们需要的对象都推入到了请求上下文栈中。</p>
<p>我们查看 self.request_context 的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .ctx <span class="keyword">import</span> RequestContext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_context</span><span class="params">(self, environ)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> RequestContext(self, environ)</span><br></pre></td></tr></table></figure></p>
<p>跟进 RequestContext:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, environ, request=None, session=None)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line">        <span class="keyword">if</span> request <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            request = app.request_class(environ)</span><br><span class="line">        self.request = request</span><br><span class="line">        self.url_adapter = <span class="keyword">None</span></span><br><span class="line">        self.url_adapter = app.create_url_adapter(self.request)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.url_adapter <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.match_request()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，又回调了 app 实例中的 app.request_class 和 app.create_url_adapter 。先看 app.request_class:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .wrappers <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    request_class = Request</span><br></pre></td></tr></table></figure></p>
<p>这里的 Request 对象主要是 Flask 对于 werkzeug 里面 RequestBase 对象的封装。它接受一个 environ 字典，将储存在 environ 字典中的原始信息以各种方式封装后方便用户访问。</p>
<p>更重要的是 app.create_url_adapter:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_url_adapter</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> self.url_map.bind_to_environ(</span><br><span class="line">        request.environ)</span><br></pre></td></tr></table></figure></p>
<p>饶了一个大圈子之后这里我们终于又回到了第一节路由机制里面的 self.url_map 对象。它是 werkzeug 里 Map 类的实例。根据我们前面介绍过的用法，这里绑定 environ 信息后会返回一个 adapter，调用 adapter 的 match 方法就能够得到匹配的端点名和参数。我们将 adapter 储存在了 RequestContext 的 url_adapter 属性中。</p>
<p>接下来看 RequestContext.match_request:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    url_rule, self.request.view_args = \</span><br><span class="line">        self.url_adapter.match(return_rule=<span class="keyword">True</span>)</span><br><span class="line">    self.request.url_rule = url_rule</span><br></pre></td></tr></table></figure></p>
<p>这里终于调用了 self.url_adapter 的 match 函数。调用之后，我们就已经匹配到了分发这次请求需要的信息了。将它们储存在了 self.request.url_rule 和 self.request.view_args 中。</p>
<p>现在 RequestContext 已经初始化完毕了。之后在正式处理请求的 <code>response = self.full_dispatch_request()</code> 语句前，先调用了 <code>ctx.push()</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    _request_ctx_stack.push(self)</span><br></pre></td></tr></table></figure></p>
<p>这里再次出现了 _request_ctx_stack，前面分析过的线程本地栈。我们将 RequestContext 的实例推入了栈。在请求结束之后，我们又会调用 ctx.auto_pop 把这个实例弹出栈。</p>
<p>现在我们能够了解我们从全局导入的 reqeust 对象的实质了。它就是 Flask.wrappers 中 Request 类的实例，绑定在 RequestContext 的实例上。在每一次请求中，都会新建一个请求上下文对象 RequestContext，在它的初始化过程中，会调用绑定在 app 上的 werkzeug 里的 Map 实例 url_map 匹配 url，得到参数，将它们作为 request 的 url_rule 和 view_args 属性。然后将这个请求上下文推入请求上下文栈。我们访问到的 request 对象，就是对这个请求上下文栈顶的请求上下文里面的那个 request 的代理。这样，对于每个不同的线程而言，这个 request 对象也就自动包含了相应的请求信息。</p>
<p>比如说，前面的 dispatch_request 中出现过这样的语句 <code>return self.view_functions[rule.endpoint](**req.view_args)</code>，这里的 rule.endpoint 和 req.view_args 就是从绑定完毕后的 request 对象里面获取的。</p>
<p>关于请求上下文，还有一点值得琢磨。每一次请求都会新建一个线程，这样，在一次请求的整个流程中，明明只需要将这个线程对应的请求上下文推入一次即可，为什么要用栈来实现请求上下文呢？这一点 Flask 的源码中曾经提到过：</p>
<blockquote>
<p>Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together.</p>
</blockquote>
<p>这样做是为了能够在多个不同的应用之间做内部重定向。虽然如此，Flask 尚没有提供与此相关的 api，可能为了以后保留的。在绝大多数的开发中，实际上请求上下文栈一直只会有最多一个上下文对象。</p>
<h2 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h2><p>除了请求上下文之外，Flask 还存在应用上下文的概念。应用上下文随线程中第一次请求上下文的推入而创建，在前面的 <code>ctx.push</code> 方法中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    app_ctx = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> app_ctx.app != self.app:</span><br><span class="line">        app_ctx = self.app.app_context()</span><br><span class="line">        app_ctx.push()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>这里的 _app_ctx_stack，应用上下文栈，原理和请求上下文栈别无二致：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_app_ctx_stack = LocalStack()</span><br></pre></td></tr></table></figure></p>
<p>app_ctx.push 中，推入的是 AppContext 类的实例。这个类封装了应用的一些信息，不详细叙述了。</p>
<p>这里值得关注的是，为什么 Flask 除了请求上下文以外，还需要一个应用上下文的概念？在一次请求中，不是可以直接调用 RequestContext 上的 app 属性获得应用相关的信息吗？要理解这一点，需要先理解 Flask 多应用的存在。</p>
<p>我们可以通过 Flask 中的蓝图，将一个大的应用划分为几个子板块。但有时，这样还不够，我们需要几个子板块都拥有自己的配置信息与逻辑，成为几个单独的子系统。Flask 允许这一点，比如说，可以这样使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自 stackoverflow</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</span><br><span class="line"><span class="keyword">from</span> frontend_app <span class="keyword">import</span> application <span class="keyword">as</span> frontend</span><br><span class="line"><span class="keyword">from</span> backend_app <span class="keyword">import</span> application <span class="keyword">as</span> backend</span><br><span class="line"></span><br><span class="line">application = DispatcherMiddleware(frontend, &#123;</span><br><span class="line">    <span class="string">'/backend'</span>:     backend</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样，在一次请求对应的一个解释器线程中，可能会同时存在多个逻辑上分割的 Flask 应用。而 Flask 请求还恰恰赋予了我们使用 url_for 这样的全局函数直接获取一个应用中端点名对应的 url，这就需要保持每个应用的上下文，需要时从应用上下文栈中获取。</p>
<p>Flask 就借助于应用上下文实现了 current_app 这样的全局对象，帮助我们获取此次请求对应的应用信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span>:</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line"></span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br></pre></td></tr></table></figure></p>
<p>可以发现和 request 非常相似。</p>

        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links">
    
      
        
          <a href="mailto:ysnyyhs@163.com" class="iconfont icon-email" title="email" target="_blank"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Arianxx" class="iconfont icon-github" title="github" target="_blank"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.douban.com/people/131732783/" class="iconfont icon-douban" title="douban" target="_blank"></a>
        
      
    
      
    
      
    
      
    

    	<a href="https://music.163.com/#/user/home?id=101778288" class="myiconfont icon-163music" title="yun music" target="_blank">
    	</a>

      <a href="https://space.bilibili.com/3101019/#/" class="myiconfont icon-bilibili"
      title="bilibili" target="_blank">
      </a>

    
    <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Arian</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.11.0"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js" integrity="sha384-BnFYVbw3PHhz5qWXTCSL12MjPc3KxjdKPx7R4R5JjIzxFmYX267NDyJ9B/nZANdg" crossorigin="anonymous"></script>
<script src="/js/src/transition.min.js"></script>

<script async src="/js/src/message.js"></script>
<script src="/js/src/live2d.js"></script>

<script type="text/javascript">
	modelNames = ["default-costume.json", "pajamas-costume.json", "school-costume.json"]
	modelNum = modelNames.length
	randomName = modelNames[Math.floor(Math.random() * modelNum)]

    loadlive2d("live2d", "/model/Pio/" + randomName);
    $('.container').after("<canvas class='fireworks' style='position:fixed;left:0;top:0;pointer-events:none;z-index:999'></canvas>")
</script>

<script async type="text/javascript" src="/js/src/jquery.click-firewords.js"></script>


<script type="text/javascript">//樱花
 var system ={}; 
 var p = navigator.platform; 
 system.win = p.indexOf("Win") == 0; 
 system.mac = p.indexOf("Mac") == 0; 
 system.x11 = (p == "X11") || (p.indexOf("Linux") == 0); 
 if(system.win||system.mac||system.xll){//如果是电脑
 
 $.getScript("/js/src/yinghua.js");
 }else{ //如果是手机
 
 }
 </script></body>
</html>
