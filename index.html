<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="记录自己的学习与生活"/>













  <link rel="alternate" href="/atom.xml" title="Arian.X">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://arianx.me/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7da15ed69b10673f5e71fb736eca6373";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-113448663-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Arian.X </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Arian.X</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Arian.X</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/06/24/Python-Huffman-Tree/">实现霍夫曼编码</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-24
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>霍夫曼编码是一种使用变长编码表编码源符号的无损压缩算法。它的核心思想是计算各个符号的权重，出现次数较多的符号拥有较大的权重，出现次数较少的符号拥有较小的权重。然后对符号进行前缀编码，用较短的编码表示拥有较长权重的符号，用较长的编码表示拥有较短权重的符号。这样，总体来说，对于符号出现次数不均衡的序列，霍夫曼编码就能够拥有较好的表现。</p>
<h2 id="压缩过程"><a href="#压缩过程" class="headerlink" title="压缩过程"></a>压缩过程</h2><p>霍夫曼编码的压缩阶段主要有以下几个步骤：</p>
<ol>
<li>读入符号，计算各个符号的权重。</li>
<li>根据符号的权重建立霍夫曼树。</li>
<li>依据霍夫曼树建立编码表。</li>
<li>压缩</li>
</ol>
<h3 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h3><p>计算权重很容易理解。遍历符号，计算各个符号出现的次数。把出现的次数当作权重即可。实际实现中，如果以字节为单位压缩，考虑到一个字节有8位，最大能表示255。为了操作方便，可以将出现的次数除以最大的出现次数，再乘以256当作权重。这样，所有权重就刚分布在一个字节的表示范围以内。</p>
<p>同时，考虑到一个字节的编码刚好是0~255，可以建立一个数组，这个数组的下标表示对应的符号，这个数组的值表示符号的权重。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_minimize_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 缩小字频使其在一个字节范围以内</span></span><br><span class="line">        max_freq = max(self.freqs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> symbol, freq <span class="keyword">in</span> enumerate(self.freqs):</span><br><span class="line">            scale_freq = int(self.BYTE_MAX_NUM * (freq / max_freq))</span><br><span class="line">            scale_freq = <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> scale_freq <span class="keyword">and</span> freq <span class="keyword">else</span> scale_freq</span><br><span class="line"></span><br><span class="line">            self.freqs[symbol] = scale_freq</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_symbol_frequencies</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> self.origin:</span><br><span class="line">            self.freqs[symbol] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self._minimize_frequencies()</span><br></pre></td></tr></table></figure>
<p>计算了各个符号的权重之后，就可以根据这些权重建立霍夫曼树。从霍夫曼树中，我们可以得到符号的前缀码表。</p>
<h3 id="建立霍夫曼树"><a href="#建立霍夫曼树" class="headerlink" title="建立霍夫曼树"></a>建立霍夫曼树</h3><p>霍夫曼树是一颗二叉树，其每个节点至少有四个值——符号，权重，左树指针，右树指针。建立霍夫曼树主要有两种方式。第一种是使用一个优先队列（堆）。首先，为所有的符号创造一个节点，储存进这个符号本身和它的权重。然后将所有的节点压入优先队列，拥有最低权重的节点拥有最高的优先级（即，低权重的节点会先被弹出。）然后执行以下步骤：</p>
<ol>
<li>如果优先队列中的元素大于一，弹出两个节点。以这两个节点为左右指针创建一颗新的霍夫曼树，其权重为作为节点之和。将这个新树压入优先队列。重复本步骤。</li>
<li>否则，弹出剩下的元素作为最终的霍夫曼树。</li>
</ol>
<p>除了优先队列外，还可以使用两个队列来建立霍夫曼树。首先，像前面那样创建节点，按照权重排序所有节点。然后创建两个队列，将节点按照权重从低到高的顺序依次入其中一个队列1。然后执行以下步骤：</p>
<ol>
<li>如果一个队列为空，从另一个队列中弹出两个元素；否则，比较两个队列首元素的权重，弹出权重最小的两个元素。用这两个元素作为子树建立一个新的霍夫曼树，其权重为两元素权重之和。将这颗新树压入队列2。重复本步骤，直到队列只剩下一个元素。</li>
<li>弹出这个元素作为最终的霍夫曼树。</li>
</ol>
<p>使用优先队列的实现：<br>
          <div class="read-more">
            <a href="/2018/06/24/Python-Huffman-Tree/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/06/22/Common-sort-algorithm/">十种常见的排序方法</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-22
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍了十种常见简单排序算法的python实现。</p>
<p>将要介绍的这十种排序算法分别是——冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序、计数排序、基数排序、桶排序</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>一遍遍遍历元素，两两交换其中不符合顺序的元素，将最大（或最小的）那个元素提取到最边缘的位置，直到不再有需要交换的元素为止。冒泡排序时常是排序算法中比较简单，也比较低效的一种排序方式。其时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p>
<p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, length - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[j], data[j + <span class="number">1</span>]):</span><br><span class="line">                data[j], data[j + <span class="number">1</span>] = data[j + <span class="number">1</span>], data[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每一次遍历元素，都选择其余元素中最小或最大的那个元素，每一次都缩小遍历范围直到遍历完成。选择排序的时间复杂度仍然为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。即使如此，选择排序的性能要略优于冒泡排序。</p>
<p>实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[index], data[j]):</span><br><span class="line">                index = j</span><br><span class="line">        data[index], data[i] = data[i], data[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的基本思想是将一个数插入一个已经排好序的序列中，并且在插入后仍然保持有序。实现上将每个序列最开始的部分视为有序，然后依次将后面的元素插入前面的有序列表。直到遍历所有元素，即得到一个全部有序的列表。插入排序的时间复杂度仍为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。然而在数据量或数据基本有序时，插入排序将会拥有比冒泡和选择排序稍优异的性能。因此，经常将插入排序用作某些复合排序方法中的一部分。</p>
<p>实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ins_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(data):</span><br><span class="line">        <span class="keyword">while</span> index &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> compare(data[index - <span class="number">1</span>], data[index]):</span><br><span class="line">                data[index], data[index - <span class="number">1</span>] = data[index - <span class="number">1</span>], data[index]</span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序基于插入排序。与插入排序每次比较交换最近的元素，依次向后遍历不同，希尔排序将序列分成几组，对这几组分别进行插入排序。然后缩小分组的间隔后再次分组，执行插入排序，直到分组间隔为1。可以看出，每一次分组，序列都将越来越有序，从而执行插入排序比较、交换的次数就会越来越少。因此，希尔排序的速度要优于O(n^2)，平均为O(nlog^2n)，最好为O(nlogn)。</p>
<p>从另一个方面看，排序的实质实际上是消除序列中的逆序数。冒泡、选择、插入等一次交换仅消除一个逆序数，而希尔排序一次交换会消除多个逆序数。因此希尔排序比普通插入排序更快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    gap = length // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length, gap):</span><br><span class="line">            current = data[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> i &gt;= gap <span class="keyword">and</span> <span class="keyword">not</span> compare(data[i - gap], current):</span><br><span class="line">                data[i] = data[i - gap]</span><br><span class="line">                i -= gap</span><br><span class="line"></span><br><span class="line">            data[i] = current</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是分治法的体现。每次排序都选择一个基准元素，将序列分成独立的两部分，一部分中的所有元素始终小于基准元素，另一部分中的所有元素始终大于基准元素。对这两部分序列分别进行快速排序，直到序列不可再分。此时序列即是有序的。快速排序的平均时间复杂度为<code>O(nlogn)</code>，最坏情况为<code>O(n^2)</code>，空间复杂度为<code>O(logn)</code>（递归）。</p>
<p>两种实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(data, begin=None, end=None, compare=lambda x, y: x &lt;= y)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">    begin = begin <span class="keyword">if</span> begin <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    end = end <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> (len(data) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> begin &gt;= end:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    key = randint(begin, end)</span><br><span class="line">    data[begin], data[key] = data[key], data[begin]</span><br><span class="line">    left = begin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(begin + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> compare(data[index], data[begin]):</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            data[left], data[index] = data[index], data[left]</span><br><span class="line">    data[left], data[begin] = data[begin], data[left]</span><br><span class="line"></span><br><span class="line">    quick_sort1(data, begin, left - <span class="number">1</span>)</span><br><span class="line">    quick_sort1(data, left + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速排序2</span></span><br><span class="line">quick_sort2 = <span class="keyword">lambda</span> data, compare=<span class="keyword">lambda</span> x, y: x &lt; y: \</span><br><span class="line">    data <span class="keyword">if</span> len(data) &lt; <span class="number">2</span> <span class="keyword">else</span> \</span><br><span class="line">    quick_sort2([a <span class="keyword">for</span> a <span class="keyword">in</span> data <span class="keyword">if</span> compare(a, data[<span class="number">0</span>])]) + \</span><br><span class="line">    [data[<span class="number">0</span>] * data.count(data[<span class="number">0</span>])] + \</span><br><span class="line">    quick_sort2([b <span class="keyword">for</span> b <span class="keyword">in</span> data <span class="keyword">if</span> compare(data[<span class="number">0</span>], b)])</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序同运用了分治法的思想。归并排序将数据分为两部分，对每部分序列一次运用归并排序，直到不可再分，然后将各部分有序序列组合起来。最终返回的即为有序序列。归并排序的时间复杂度是<code>O(nlogn)</code>。</p>
<p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(data, i, j, k, compare)</span>:</span></span><br><span class="line">    new_data = []</span><br><span class="line">    data1, data2 = data[i:j + <span class="number">1</span>], data[j + <span class="number">1</span>:k + <span class="number">1</span>]</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; len(data1) <span class="keyword">and</span> b &lt; len(data2):</span><br><span class="line">        <span class="keyword">if</span> compare(data1[a], data2[b]):</span><br><span class="line">            new_data.append(data1[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_data.append(data2[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">    new_data.extend(data1[a:])</span><br><span class="line">    new_data.extend(data2[b:])</span><br><span class="line">    data[i:k + <span class="number">1</span>] = new_data</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(data, begin=None, end=None, compare=lambda x, y: x &lt; y)</span>:</span></span><br><span class="line">    begin = begin <span class="keyword">if</span> begin <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    end = end <span class="keyword">if</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> (len(data) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> begin &lt; end:</span><br><span class="line">        mid = (begin + end) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        merge_sort(data, begin, mid, compare)</span><br><span class="line"></span><br><span class="line">        merge_sort(data, mid + <span class="number">1</span>, end, compare)</span><br><span class="line"></span><br><span class="line">        merge(data, begin, mid, end, compare)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>参见上一篇文章</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非比较的，稳定的线性时间排序算法。它将序列中的元素与一个数组中的位置对应。这个数组的下标是元素的值，这个位置储存的值是元素在新序列里所处于的位置。由n个元素组成，最大值为k的序列，首先构建一个长度为k的数组，遍历序列将它映射到数组之中，最后根据数组生成新的有序序列。因此，计数排序的时间复杂度与空间复杂度均为<code>O(n + k)</code>。</p>
<p>计数排序适用于容易将序列的值映射为整数，且跨度不太大的情况下。并且，序列排序经常被用于更复杂的排序（如基数排序）的基本排序方法。</p>
<p>实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(data, max_value=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param data: 要排序的可迭代对象</span></span><br><span class="line"><span class="string">    @param max: data里的最大值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_value = max_value <span class="keyword">if</span> max_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> max(data)</span><br><span class="line"></span><br><span class="line">    result = [<span class="keyword">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(data))]</span><br><span class="line">    position = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        position[value] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, max_value + <span class="number">1</span>):</span><br><span class="line">        position[index] += position[index - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    n = len(data) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        value = data[n]</span><br><span class="line">        result[position[value] - <span class="number">1</span>] = value</span><br><span class="line">        position[value] -= <span class="number">1</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>
          <div class="read-more">
            <a href="/2018/06/22/Common-sort-algorithm/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/06/17/Heap-in-python/">堆排序python实现</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-17
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法/">算法</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一种基于树的数据结构，其父节点总是大于（最大堆）或小于（最小堆）其子节点，并且其根节点总是树中最小（或最大）的那个节点。</p>
<p>堆排序常被用来实现<code>优先队列</code>，用于按给定的因子排定元素的优先级。而其本身最常采用的实现方式是扁平储存的二叉树。在二叉树实现的堆中，一个节点的兄弟节点并无特定的关系。唯一的关系存在于父节点和子结点中。</p>
<p>由于堆的二叉树总会是一个完全二叉树，且是用列表的方式扁平储存二叉树以实现堆，所以，在堆的列表中，序号为 n 的节点有以下几个特征：</p>
<ol>
<li>其父节点为 <code>(n - 1) // 2</code> （取整）。</li>
<li>其左子节点为 <code>n * 2 + 1</code>。</li>
<li>其右子节点为 <code>n * 2 + 2</code>。</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对堆执行插入操作，只需将其推入列表尾部，然后逐一与其父节点进行比较，如果逆序就交换。直到不再交换，则节点已经在正确为止。</p>
<p>关键代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_up</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        parent = self.parent(index)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.compare(self._heap[parent], self._heap[index]):</span><br><span class="line">                self._heap[parent], self._heap[index] = \</span><br><span class="line">                    self._heap[index], self._heap[parent]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            index = parent</span><br><span class="line">            parent = self.parent(index)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index == parent:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._heap.append(node)</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        self.heap_up(self.size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><p>提取堆中最大的一个元素，只需提取第一个元素，然后用最后一个元素覆盖第一个元素。再逐一将这个元素与和这个元素差距最大的子元素比较，如果逆序就交换。直到不再交换为止，删除最后一个元素，返回提取出来的第一个元素。操作完毕。</p>
<p>关键代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">heap_down</span><span class="params">(self, index=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            child = self.max_child(index)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> child:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.compare(self._heap[child], self._heap[index]):</span><br><span class="line">                    self._heap[child], self._heap[index] = \</span><br><span class="line">                        self._heap[index], self._heap[child]</span><br><span class="line">                    index = child</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self)</span>:</span></span><br><span class="line">        top = self._heap[<span class="number">0</span>]</span><br><span class="line">        self._heap[<span class="number">0</span>] = self._heap[self.size - <span class="number">1</span>]</span><br><span class="line">        self.heap_down()</span><br><span class="line">        self._heap.pop()</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> top</span><br></pre></td></tr></table></figure></p>
          <div class="read-more">
            <a href="/2018/06/17/Heap-in-python/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/06/17/python-avl-binary-tree/">AVL树python实现</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-17
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法/">算法</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>今宵は雪月花</p>
</blockquote>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>将普通二叉树直接用于查找，平均情况下，仅需要查找一个分支，其时间复杂度为O(log n)。想要使查找时间尽可能短，就要使树的高度经可能短，使二叉树保持平衡状态。如果一个二叉树变得越来越不平衡，最后，其时间复杂度就变成了O(n)，相当于从头到尾遍历所有节点。</p>
<p>AVL是最先发明的一种自平衡二叉查找树，像普通二叉树一样组织数据。所不同的是，AVL的每一个节点都附带了一个<code>平衡因子</code>，其值代表了左子树和右子树的高度之差。对于每一次改变其平衡性的操作，AVL树都通过执行一次<code>旋转</code>操作来使其重新平衡。每一次插入和删除操作最多可能有<code>log n</code>个节点被旋转。因此，AVL树的插入、删除、查找操作的时间复杂度都在O(log n)。</p>
<p>下面使用python来实现AVL树。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>由普通二叉树的节点继承而来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvlNode</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The binary searching tree. Inherit from theo `Node` class.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        super().__init__(key)</span><br><span class="line">        self.height = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'AvlNode(key=&#123;key&#125;)'</span>.format(key=self.key)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_child_height</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The leaf node's height is 0. So the null node's height is -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> max(self.left.height <span class="keyword">if</span> self.left <span class="keyword">else</span> <span class="number">-1</span>,</span><br><span class="line">                   self.right.height <span class="keyword">if</span> self.right <span class="keyword">else</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_height</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Search from this node to its ancestor node</span></span><br><span class="line"><span class="string">        until the height doesn't change.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        old_height = self.height</span><br><span class="line">        self.height = self.max_child_height + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.height != old_height <span class="keyword">and</span> self.parent:</span><br><span class="line">            self.parent.adjust_height()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        The null node's height is deemed as -1.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.left.height <span class="keyword">if</span> self.left <span class="keyword">else</span> <span class="number">-1</span>) \</span><br><span class="line">            - (self.right.height <span class="keyword">if</span> self.right <span class="keyword">else</span> <span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<p>普通二叉树的节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Pure binary tree's node.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Build the node instance.</span></span><br><span class="line"><span class="string">        @param key: The object that implements the __lt__ and __gt__ method.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.count = <span class="number">1</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.parent = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;key&#125;)'</span>.format(key=self.key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is the root node.(have not parent node)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.parent)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_leaf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is a leaf node.(have not any left or right point)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.left) <span class="keyword">and</span> <span class="keyword">not</span> bool(self.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_branch</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this is a branch node.(have the left point or right point)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.left) ^ bool(self.right)</span><br></pre></td></tr></table></figure></p>
<p>与普通二叉树节点不同，AVL树的节点附带了树的高度信息，以此来判断这个节点是否处于平衡状态。如果这个节点的左子树与右子树高度差的绝对值大于1，就视这个节点为不平衡的，应该在稍后执行旋转操作。</p>
<p>并且AVL树的节点还又一个adjust_height方法，用于在进行一个会改变树高的操作后，重新计算这个节点所属的整个子树的高度，直到高度不再变化，代表调整完毕。</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>AVL树的插入操作和普通二叉树类似。只不过在每一次插入后，需要重新计算子树高度（调用插入节点的adjust_height方法）。如果这次插入操作改变了树的平衡性，就需要旋转节点以使树重新平衡。</p>
<p>插入操作的关键代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, key, node=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Insert the key to the tree.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        new_node = super().insert(key, node=node)</span><br><span class="line">        <span class="keyword">if</span> new_node:</span><br><span class="line">            parent = new_node.parent</span><br><span class="line">            <span class="keyword">while</span> parent:</span><br><span class="line">                <span class="comment"># It has no effect on the node itself</span></span><br><span class="line">                <span class="comment"># but may change its parents' blance.</span></span><br><span class="line">                <span class="keyword">assert</span>(<span class="keyword">not</span> parent.is_leaf())</span><br><span class="line">                parent.height = parent.max_child_height + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> parent.balance <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                    self.rebalance(parent)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                parent = parent.parent</span><br></pre></td></tr></table></figure>
<p>这是AvlBiTree类的一个方法，用于为AVL数插入节点。它继承自代表普通二叉树的BiTree类。因此，这里的插入方法覆盖了BiTree的插入方法。在其中调用了父类的insert方法来普通插入节点。之后，再调整树的高度。并且逐一遍历其父节点查看平衡性是否受到破坏。如果平衡新被破坏，就调用rebalance方法旋转节点，使树重新平衡。</p>
<p>如果进行了一次rebalance旋转操作，代表已经消除了这次插入操作的副作用使树重新平衡。那么，其上所有祖先节点的平衡性都不受这次插入操作的影响。因此，break结束对祖先节点的遍历。代表本次插入操作完成。</p>
<h2 id="旋转结点使树重新平衡"><a href="#旋转结点使树重新平衡" class="headerlink" title="旋转结点使树重新平衡"></a>旋转结点使树重新平衡</h2><p>关键代表如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebalance</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Rotate the appointed node if the balance had been breaked.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> node.balance == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> node.left.balance == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># LL rotate</span></span><br><span class="line">                self.__ll_rotate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(node.left.balance == <span class="number">-1</span>)</span><br><span class="line">                <span class="comment"># LR rotate</span></span><br><span class="line">                self.__lr_rotate(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span>(node.balance == <span class="number">-2</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right.balance == <span class="number">-1</span>:</span><br><span class="line">                <span class="comment"># RR rotate</span></span><br><span class="line">                self.__rr_rotate(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span>(node.right.balance == <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># RL rotate</span></span><br><span class="line">                self.__rl_rotate(node)</span><br></pre></td></tr></table></figure>
<p>可见，这实际上接近于一个调度方法，根据平衡性的情况，执行不同的旋转操作。</p>
<h2 id="具体旋转操作："><a href="#具体旋转操作：" class="headerlink" title="具体旋转操作："></a>具体旋转操作：</h2>
          <div class="read-more">
            <a href="/2018/06/17/python-avl-binary-tree/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/06/07/The-usage-of-the-raise-from-in-python/">python在异常捕获里抛出异常</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-07
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="python2异常对象"><a href="#python2异常对象" class="headerlink" title="python2异常对象"></a>python2异常对象</h2><p>有时，我们需要在捕获一个异常之后，在捕获的语句里面抛出另外一个异常。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError(e)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: division by zero</span><br></pre></td></tr></table></figure></p>
<p>上面在捕获除零异常后，重新在处理语句里抛出了ValueError，并将除零异常的信息传给了ValueError。同时，可以发现抛出的信息还附带了追踪信息，可以看到异常的抛出顺序。</p>
<p>然而，在python2里，从一个异常捕获中直接抛出另一个异常，并不会附带追踪信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p>
<p>python2异常抛出语句的语法是：raise exc, value, traceback。第一个参数是Exception的子类或子类的实例，第二个参数是初始化异常的信息，第三个参数是traceback对象。</p>
<p>python2中，可以通过这种方式看到traceback：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            foo()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            foo()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> RuntimeError(e), <span class="keyword">None</span>, sys.exc_info()[<span class="number">2</span>]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> bar</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> foo</span><br><span class="line">RuntimeError: integer division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure></p>
<p>python3简化了异常抛出语句的语法，不再支持python2抛出三元素元组的方式，而是简化为了一个exception参数。例如，在python2中原来有多个语句实现同一个异常抛出效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise RuntimeError, ValueError</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: &lt;type &apos;exceptions.ValueError&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; raise RuntimeError(ValueError)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">RuntimeError: &lt;type &apos;exceptions.ValueError&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>这显然违背了python之禅里”There should be one– and preferably only one –obvious way to do it”的理念。</p>
<h2 id="python3异常对象"><a href="#python3异常对象" class="headerlink" title="python3异常对象"></a>python3异常对象</h2><p>所以，在python3中，不再支持元组的形式的异常抛出，只支持抛出Exception的子类或实例。如果是子类，就无参数调用得到实例再抛出；如果是实例则直接抛出。并且，python3为异常对象新增加了几种特殊方法。例如，增加了<code>__context__</code>方法，用于在多重异常抛出中保留以前异常的抛出信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    print(e.__context__)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    a = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            a[<span class="number">1</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            print(e.__context__)</span><br><span class="line">...</span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure></p>
<p>python3的异常对象还增加了<code>__traceback__</code>信息，用于在多重异常抛出中记录以前的抛出信息，从而简化了多重异常抛出的操作。在python3中，可以通过使用raise…from…语法快速指定traceback对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError <span class="keyword">from</span> e</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p>
<p>可以看到不单附带了跟踪信息，还有“The above exception was the direct cause of the following exception”这句指明了异常之间的关系。</p>
<p>并且，在python3中，即使不使用raise … from …语法，默认也附带了追踪信息，保存在<code>__context__</code>中，以”during handling another exception happened”的形式展现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p>
<p>还可以通过异常对象的with_traceback方法指定traceback对象，这种方法的提示语句如上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError.with_traceback(e)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: division by zero</span><br></pre></td></tr></table></figure></p>
<h2 id="cause-属性"><a href="#cause-属性" class="headerlink" title="__cause__属性"></a><code>__cause__</code>属性</h2><p>实际上，在使用 raise … from … 语法时，一个名为 <code>__cause__</code>的属性就被赋给异常对象，这个属性直接指明了异常发生的原因。当<code>__cause__</code>被设置的时候，<code>__suppress_context__</code>方法也会被同时设置为True。如果<code>__suppress_context__</code>被设置为True，在打印traceback信息时，<code>__context__</code>就会被忽略。</p>
<p>所以，如果在某些时候，想要忽略多重异常抛出中的上层的异常信息，可以使用 raise … from None来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> ValueError <span class="keyword">from</span> <span class="keyword">None</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError</span><br></pre></td></tr></table></figure></p>
<p>可以发现上层的ZeroDivisionError被忽略了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有一种常见的python编程风格，叫做<code>EAFP(easier to ask for forgiveness than permissino，取得原谅比获得许可容易)</code>。先假定方法存在直接调用，如果不存在就捕获异常。这种方法简明轻快，体现出了python的鸭子类型和松散协议。</p>
<p>这种方法的特点就是代码块中有较多的try和except关键字。灵活运用异常，能够更得心应手的使用这种风格编程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/24752395/python-raise-from-usage" target="_blank" rel="noopener">https://stackoverflow.com/questions/24752395/python-raise-from-usage</a></p>
<p><a href="https://mozillazg.com/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html#hidid1" target="_blank" rel="noopener">https://mozillazg.com/2016/08/python-the-right-way-to-catch-exception-then-reraise-another-exception.html#hidid1</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/05/31/meta-programming-explore/">内省python元类执行流程</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-31
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一篇文章里面曾简短提到了在python中使用type类可以实现元编程。实际上，在python，存在几种类型的元编程，包括使用装饰器动态修改类或函数的功能、使用魔术方法重写python内置操作符的行为等，还有使用元类在运行时动态的创建和修改类。本文主要探讨python中使用元类进行元编程时，其中类方法的调用顺序和流程的问题。我想理解了这一点就会对使用元类有更深一点的认知。</p>
<h2 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h2><p>然而，究竟什么是<code>元类</code>？要理解这一点，就需要理解python独特的动态语言特性。在python中，一切都被视为对象。对象的一大特性就是可以在程序运行时，根据不同的上下文而创建。那么，依照这种思想，类也应该是一种对象。把类视为一种对象，在程序运行时，像对象那样动态创建或修改，这种行为就是元编程的一种。能够在程序运行时动态<code>创建或修改类的类</code>就被称为<code>元类</code>。</p>
<p>所有的对象都由某个类构造而来，那么对于元类，因该由哪种类构造而来呢？在python中，这个类就是type。所有的类都是type的实例，这实际上蕴含了一个思想，所有类都可以<code>看作</code>(只是看作)由type类创建而来的。type是一个类，这个类在运行时构造了另外的类。type类是python内置的一个元类。所以，藉继承type类，我们就可以创建出自己的元类。</p>
<p>一个简单的示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MetaClass</span><span class="params">(type)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 在声明中使用metaclass指定元类，就会用指定的元类来构建类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(metaclass=MetaClass)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SubClass.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MetaClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">MetaClass</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个简单的元类示例什么都没有做，但它体现出了python元编程的一些特性。SubClass的<code>__class__</code>属性变为了MetaClass，表明这个类是由MetaClass类，而不是通常的type类所构造的。同时，可以看到我们自定义的元类是type的子类。</p>
<h2 id="一些与元类编程相关的特殊方法"><a href="#一些与元类编程相关的特殊方法" class="headerlink" title="一些与元类编程相关的特殊方法"></a>一些与元类编程相关的特殊方法</h2><p>在了解真正使用元类编程的方法之前，需要预备一些知识——一些与构造类有关的特殊方法。</p>
<h3 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__方法"></a><code>__new__</code>方法</h3><p><code>__new__</code>方法是一个静态方法。当调用类构造一个实例时，这个实例就是由<code>__new__</code>方法产生。<code>__new__</code>方法的第一个参数是调用的类本身。</p>
<h3 id="init-方法："><a href="#init-方法：" class="headerlink" title="__init__方法："></a><code>__init__</code>方法：</h3><p><code>__init__</code>方法修饰将要构造的实例。在返回实例之前做一些初始化工作。</p>
<h3 id="call-方法："><a href="#call-方法：" class="headerlink" title="__call__方法："></a><code>__call__</code>方法：</h3><p>当调用一个实例时，会尝试调用它的构造类（及父类）的<code>__call__</code>方法。</p>
<h2 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">'Success'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetUp</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用超类中的__new__方法得到将要产生的子类对象。</span></span><br><span class="line">        sub_cls = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> sub_cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 根据外部信息修饰子类</span></span><br><span class="line">        self._info = info</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 调用子类产生实例，实际上是调用了元类中的__call__方法。这里使用这一点实现单例模式。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> getattr(cls, <span class="string">'_instance'</span>, <span class="keyword">None</span>):</span><br><span class="line">            cls._instance = cls.__new__(cls)</span><br><span class="line">            cls.__init__(cls._instance, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExcuteClass</span><span class="params">(metaclass=SetUp)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 只会被打印一次。</span></span><br><span class="line">        print(<span class="string">'Info is: '</span>, self._info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">excute1 = ExcuteClass()</span><br><span class="line">excute2 = ExcuteClass()</span><br><span class="line">print(excute1 == excute2)</span><br></pre></td></tr></table></figure>
<p>执行结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Info <span class="keyword">is</span>:  Success</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子展示了元类的一些动态特性。在这里第一个<code>info = &#39;Success&#39;</code>可以看作随上下文不同而变化的信息，元类SetUp根据这个信息的不同将会创建蕴含不同信息的子类。同时，元类本身通过<code>__call__</code>方法干涉了子类实例的创建，实际上实现了<code>单例模式</code>。在这里，子类只会被初始化一次，只会产生一个实例。</p>
<h2 id="内省执行流程"><a href="#内省执行流程" class="headerlink" title="内省执行流程"></a>内省执行流程</h2><p>那么，使用元类时，详细的顺序究竟是怎么样的呢？先后调用了哪些方法？刚接触元类时，或许许多人都会有这些疑惑。幸亏得益于python强大的动态性，我们可以在运行时方便的内省程序的状况。</p>
<p>可以藉由下面的程序观察到元类的执行流程：<br>
          <div class="read-more">
            <a href="/2018/05/31/meta-programming-explore/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/05/31/type-and-object-explore/">python中type和object</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-31
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>一生一代一双人</p>
</blockquote>
<h2 id="type和object"><a href="#type和object" class="headerlink" title="type和object"></a>type和object</h2><p>python中内置了两个类，type和object，用isinstance和issubclass测试这两个类会发现一些奇怪的特性，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object是自身的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object也是type的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(object, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type是自身的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type是object的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object是自身的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object不是type的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(object, type)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="comment"># type是自身的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, type)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># type也是object的子类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(type, object)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，在这里面，type和object互为实例和子类，只有一个例外。而平时，在我们编写程序的过程中，也时常会注意到我们自己的类会有一些属性指向type和object，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Foo</span>.<span class="title">__base__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">object</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>那么，type和object这两个类有怎样的区别和联系呢？本文将探讨一些这方面的内容。</p>
<h2 id="继承和实例化"><a href="#继承和实例化" class="headerlink" title="继承和实例化"></a>继承和实例化</h2><p>类的继承和实例化是编程语言的面向对象特性里面重要的两个方面，对于拥有一切皆是对象语言的python，自然也对其有良好的实现。并且得益于python动态语言的性质，我们可以在程序运行时方便的内省对象的各项属性，如上的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，对象的<code>__class__</code>属性实际上表明了这个对象有哪个类实例化而来。前面说到，在python中，一切皆是对象，类也是一种对象，那么，作为对象的类也拥有<code>__class__</code>属性。而作为对象的类，其<code>__class__</code>属性指向的 type，就表明，这些类是由 type这个元类构建而来。</p>
<p>而<code>__base__</code>属性的特性如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Bar.__base__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>__base__</code>属性实际上指向一个类的父类。如果一个类继承了另一个类，那么这个类的 <code>__base__</code>属性就指向它继承的那个类。（如果是多重继承，这些类就在<code>__bases__</code>属性里面）</p>
<h2 id="作为继承关系顶点的object"><a href="#作为继承关系顶点的object" class="headerlink" title="作为继承关系顶点的object"></a>作为继承关系顶点的object</h2><p>一个类可以继承自其它类，被继承的那个类称为父类。在python中，如果没有显示指定一个类继承自哪个父类，那么这个类就继承自object类。这意味着，在python中，<strong>object实际是所有类的父类，是继承树的根节点，其内蕴含了一些类基本的共有方法。</strong></p>
<p>python还规定，object类没有父类。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__base__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">object</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">issubclass</span><span class="params">(Foo, object)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line">&gt;&gt;&gt; f = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(f, object)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># object没有父类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>object.__base__</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="作为对象的顶点的type"><a href="#作为对象的顶点的type" class="headerlink" title="作为对象的顶点的type"></a>作为对象的顶点的type</h2><p>前面说过，在python中，一切皆是对象，类也是对象。是对象就应该有其对应的构造类型。一般的对象由它们的类实例而来。那么作为类本身，它们应该由哪个类实例而来呢？在python中，这个类就是type，<strong>一切的类都是type类型的实例，type的构造类是其自身，type是自身的实例。</strong></p>
<p>因此，type代表了一切实例关系的顶点。可以通过如下的属性观察到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure></p>
          <div class="read-more">
            <a href="/2018/05/31/type-and-object-explore/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/05/14/Explore-the-usage-of-super/">浅析python中super用法，兼及继承机制</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-14
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>远在天边，我们一无所见，即使近在眼前，也仅仅是连续不断而变幻不定的表象。 </p>
</blockquote>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在学习python的过程中，一直对super的用法感到稍许疑惑。虽然直到它的基本使用方法，却一直觉得模模糊糊。本文将根据实例简要探讨python3中super函数的行为，以加强对super函数的认知，兼及一些相关方面的内容。</p>
<p>本文将简要谈谈我对对象和继承机制的理解，最终探讨super的用法。</p>
<h2 id="Ⅰ-面向对象机制"><a href="#Ⅰ-面向对象机制" class="headerlink" title="Ⅰ.面向对象机制"></a>Ⅰ.面向对象机制</h2><p><code>面向对象(OOP, Object Oriented Programming）</code>是目前编程语言中一种主流的思想，python从设计初期就已经是一门面向对象的语言。python为面向对象编程提供了强大的语法支持。因此，在python中，使用面向对象的方式进行程序设计是十分自然并且容易的。</p>
<p>理所当然，一旦提到面向对象的编程思想，那么便会自然而然想到面向对象思想中的一些重要概念。比如说：<code>类（Class)</code>。类是一种数据结构，简单来说，可以理解为对某些拥有共同属性，或行为的对象的抽象。它可以视作这些拥有相同属性或行为的对象的蓝图，封装了这些对象的共同属性或行为，使得程序设计更模块化，提高了代码的可复用性——一个<code>对象（Object）</code>是它的类的实例，它能够访问它的构造类中的所有属性或方法。</p>
<p>可以将python中的类与对象类比到现实中。这样，对象就是现实世界中的客体，是一种具体的实体。现实世界中的所有事物都可以看作一个对象。例如，一个人。当我们谈到这个对象时，我们所想到的，是这个带有数量词的、具体的、实在的个体，是“这个人”而不是“那个人”。而现实世界里面存在许许多多的人。这些所有的人有某些共同的特征，我们将这些特征聚合起来，所形成的一个抽象的、宽泛的“人”的这个形式，就是所有作为人的对象的类。</p>
<p>每个具体的对象都有其独特的<code>标识</code>。例如，在现实中，每个人都会有一个名字。一般来说，在某个给定范围的命名空间中，这个标识是唯一的。我们可以说，某个具有独特标识符的对象属于什么类。例如，张三是人，就是说”张三”属于”人”这个类。这样，可以发现，一般情况下，凡是可以说成“某个东西是什么”这种句法的，都可以抽象出类与对象的关系。</p>
<p>类比到现实中，类与对象是一种所属关系，对象是一种客观存在的实体。而放到具体的程序设计中来说，类可以视作对某些具有共同特征或行为的数据的<code>抽象</code>。</p>
<h2 id="Ⅱ-类的继承机制"><a href="#Ⅱ-类的继承机制" class="headerlink" title="Ⅱ.类的继承机制"></a>Ⅱ.类的继承机制</h2><p>一个对象可以说成是某个类的实例，一般情况，就可以说成”对象是类”这种形式。然而，在许多情况下，在这样抽象之后，我们仍然可以发现，类也有其自身的所属。例如说，泰迪是一只熊，在这里，”泰迪”是具体的对象，”熊”是”泰迪”的类，而“熊”这个类，又由“哺乳动物”这个类细分而来。我们可以这样说，熊继承自哺乳动物，而泰迪既是一只熊，也是一只哺乳动物。这样，父类就可以理解为对类的基本属性的抽象，子类是对于父类的补充。</p>
<p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-5-15/85242660.jpg" alt="补充"></p>
<p>简单来说，对象之于类，是“某个东西是什么”，而子类之于父类，是子类补充了父类。</p>
<p>在python中，如果一个子类继承了父类，就称这个父类为子类的<code>base class</code>，并且，这个子类的所有base class，都可以在<code>__bases__</code>属性中访问。这个子类的实例，也可以同时访问子类所有父类、以及后续的父类内的属性或方法（此处不考虑带前置双下划线的私有方法）。</p>
<p>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm an animal."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I can fly."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird = Bird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.skill()</span><br><span class="line">I can fly.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.kind()</span><br><span class="line">I<span class="string">'m an animal.</span></span><br></pre></td></tr></table></figure></p>
<p>可见，实例可访问它的构造类以及之后的父类中的方法。</p>
<p>同时，子类可以<code>覆盖</code>父类的方法。这样，访问实例中的这个方法时，就访问它的构造方法内重写的那个方法，而不向后追溯。</p>
<p>如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm an animal."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(Animal)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"I'm a bird."</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird = Bird()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bird.kind()</span><br><span class="line">I<span class="string">'m a bird.</span></span><br></pre></td></tr></table></figure></p>
          <div class="read-more">
            <a href="/2018/05/14/Explore-the-usage-of-super/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/04/13/The-common-Flask-s-extensions/">Flask常见扩展总结</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/笔记/">笔记</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a>是一个用python编写的、基于<a href="http://werkzeug.pocoo.org/" target="_blank" rel="noopener">Werkzeug WSGI</a>和<a href="http://jinja.pocoo.org/docs/2.10/" target="_blank" rel="noopener">Jinja2</a>的轻量级Web应用框架。因为其相比于django等框架来说简洁的功能与架构，常常被称为”microframework”。然而，称Flask为微框架并不意味着它相比起其它框架来说功能更少——Flask拥有强大的可扩展性以及活跃的社区。开发者可以根据自身的需求，自由的选择扩展包来增强其功能。</p>
<p>合理的选择扩展包，将极大的减少开发时间，提高开发效率。下面，本文就将列举出Flask应用程序开发中的一些常用扩展，以便于参考和查询。</p>
<h2 id="Flask-WTF"><a href="#Flask-WTF" class="headerlink" title="Flask-WTF"></a>Flask-WTF</h2><p>Flask-WTF将Flask和<a href="https://wtforms.readthedocs.io/en/stable/" target="_blank" rel="noopener">WTForms</a>做了简单集成，包含<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">CSRF</a>，文件上传，验证码服务等。</p>
<p>特点：</p>
<ol>
<li>集成WTForms</li>
<li>使用CSRF token保证安全性</li>
<li>全局CSRF防御</li>
<li>支持验证码服务</li>
<li>配合<a href="https://pythonhosted.org/Flask-Uploads/" target="_blank" rel="noopener">Flask-Uploads</a>运作的文件上传服务</li>
<li>使用<a href="http://pythonhosted.org/Flask-Babel/" target="_blank" rel="noopener">Flask-Babel</a>支持国际化</li>
</ol>
<p>Flask-WTF集成了WTForms，使用它，可以以面向对象语言中类的形式构建表单，简化了处理、验证表单所需操作，使表单设计与Flask其它部分统一。</p>
<p>文档：<a href="https://flask-wtf.readthedocs.io/en/stable/" target="_blank" rel="noopener">Flask-WTF</a></p>
<h2 id="Flask-SQLAlchemy"><a href="#Flask-SQLAlchemy" class="headerlink" title="Flask-SQLAlchemy"></a>Flask-SQLAlchemy</h2><p>Flask-SQLAlchemy为使用Flask开发的应用程序提供了<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy</a>的支持。它支持0.8及以上版本的SQLAlchemy，旨在通过提供有用的默认值和额外的帮助来简化Flask中SQLAlchemy的使用，使完成常见的任务变得更简单。</p>
<p>SQLAlchemy为python提供了<a href="https://en.wikipedia.org/wiki/Orm" target="_blank" rel="noopener">ORM</a>(对象关系映射)。简单地说，ORM就是为操作不同数据库提供了一个用面向对象思想设计的统一上层接口，隐藏了在具体语言中真实操作、连接数据库的底层实现，从而解耦了应用和数据库，使得方便的更换数据库成为可能。（但同样，正因如此，ORM往往不能覆盖各数据库的特有功能）。通过Flask-SQLAlchemy，可以方便的在Flask使用SQLAlchemy。</p>
<p>文档：<a href="http://www.pythondoc.com/flask-sqlalchemy/" target="_blank" rel="noopener">Flask-SQLAlchemy</a></p>
<h2 id="Flask-MongoEngine"><a href="#Flask-MongoEngine" class="headerlink" title="Flask-MongoEngine"></a>Flask-MongoEngine</h2><p>Flask-MongoEngine集成了<a href="http://mongoengine.org/" target="_blank" rel="noopener">MongoEngine</a>。</p>
<p>通过它能够方便的在Flask中使用MongoDB。</p>
<p>文档：<a href="http://docs.mongoengine.org/projects/flask-mongoengine/en/latest/" target="_blank" rel="noopener">Flask-MongoEngine</a></p>
<h2 id="Flask-Login"><a href="#Flask-Login" class="headerlink" title="Flask-Login"></a>Flask-Login</h2><p>Flask-Login为Flask提供了用户会话管理。它能够处理如登陆、登出、持久记住用户会话等常见任务。</p>
<p>它将：</p>
<ol>
<li>将活动的用户ID储存在session中，让你能够方便的对他们进行登入登出操作。</li>
<li>让你能够限制视图只允许登入（或登出）用户访问。</li>
<li>处理常见的“记住我”功能。</li>
<li>保护你的用户会话以防被cookie小偷窃取。</li>
<li>之后可能会与Flask-Principal或其它验证扩展集成。</li>
</ol>
<p>然而，它不会：</p>
<ol>
<li>将特定的数据库或其它储存方法强加给你。用户如何载入，决定权完全在你的手中。</li>
<li>限制你使用如用户名和密码，OpenIDs，或其它验证方法。</li>
<li>处理超出“登入登出”之外的权限。</li>
<li>处理用户注册或账户重置。</li>
</ol>
<p>文档：<a href="https://flask-login.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Login</a></p>
<h2 id="Flask-Migrate"><a href="#Flask-Migrate" class="headerlink" title="Flask-Migrate"></a>Flask-Migrate</h2><p>Flask-Migrate是一个使用<a href="https://pypi.python.org/pypi/alembic" target="_blank" rel="noopener">Alembic</a>处理Flask应用程序中SQLAlchemy数据库迁移的扩展。数据库操作由Flask命令行接口或通过<a href="grate.readthedocs.io/en/latest/">Flask-Script</a>扩展而得到支持。</p>
<p>Flask中的SQLAlchemy只有在不存在这个表时才会按照程序中的定义新建一个表。然而，在开发过程中不免要更改表结构，此时就可以借助这个扩展来方便的更新数据库。</p>
<p>文档：<a href="https://flask-migrate.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Migrate</a></p>
<h2 id="Flask-RESTful"><a href="#Flask-RESTful" class="headerlink" title="Flask-RESTful"></a>Flask-RESTful</h2><p>Flask-RESTful是一个为Flask增加了快速绑定REST风格API功能的扩展。它是一个与你已经存在的ORM/库之间协同工作的轻量级抽象。Flask-RESTful鼓励使用最少设置的最佳实践。</p>
<p>文档:<a href="https://flask-restful.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-RESTful</a></p>
<h2 id="Flask-Admin"><a href="#Flask-Admin" class="headerlink" title="Flask-Admin"></a>Flask-Admin</h2><p>Flask-Admin解决了在现有数据模型上构建管理界面的无聊问题。通过一定的努力，它能让你使用一个用户友好的界面管理web服务器数据。</p>
<p>文档：<a href="https://flask-admin.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Admin</a></p>
<h2 id="Flask-Bcrypt"><a href="#Flask-Bcrypt" class="headerlink" title="Flask-Bcrypt"></a>Flask-Bcrypt</h2><p>Flask-Bcrypt是一个为Flask应用程序提供了Bcrypt散列工具的Flask扩展。</p>
<p>Bcrypt是一种比MD5或SHA1稍慢，但更加安全、不易碰撞的散列算法。</p>
<p>文档：<a href="https://flask-bcrypt.readthedocs.io/en/latest/" target="_blank" rel="noopener">Flask-Bcrypt</a></p>
          <div class="read-more">
            <a href="/2018/04/13/The-common-Flask-s-extensions/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/03/05/扔鸡蛋问题/">扔鸡蛋问题</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-05
        </span>
        
          <div class="post-category">
            
              <a href="/categories/算法/">算法</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><img src="http://arian-blogs.oss-cn-beijing.aliyuncs.com/18-3-6/16293116.jpg" alt="sister"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>逛知乎的时候偶然看到的一道算法问题，看了回答里大牛给的题解以后感觉解法十分巧妙，所以写一篇博客记载下来。<br>这个问题应该属于动态规划，但本人还没有怎么接触过算法这方面的知识，全属个人理解，所以文中可能有一些不标准的地方，还请见谅啦~，也欢迎指出来。</p>
<h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>有一栋200层高的大楼，给你两个质地相同但软硬未知的鸡蛋。如果在第n层扔下鸡蛋，鸡蛋不碎，那么，从第n-1层以下扔鸡蛋都不碎。如果要想测试出最高从第几层扔下时鸡蛋不会碎，问，在最坏情况下，所扔次数最少为多少？</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目要求测试的是最高第几层扔下时不会碎，也就是说，在这一层下，鸡蛋都不会碎，在这一层上，鸡蛋都会碎。并且注意到，题目并没有规定这个层数，而是说在<strong>最坏</strong>的情况下所扔次数<strong>最少</strong>的策略。这也意味着，对于每个策略，鸡蛋可能在不同层数碎，并且总是使当前策略所需测试次数最多的那个层数。而我们所求的，就是在所有策略的最坏情况中，最少的那个次数。</p>
<h2 id="解题策略"><a href="#解题策略" class="headerlink" title="解题策略"></a>解题策略</h2><p>考虑如果只有一颗鸡蛋，那么就需要从第一层开始，逐一往上测试，直到找到破碎的那一层，这种策略最坏情况下所需次数为100.</p>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>现在有两颗鸡蛋，那么就可以有一颗用来划定区间，另一颗用来测试鸡蛋将在这个区间的哪一层碎。比如，使用二分法，第一颗鸡蛋扔在50层。如果碎了，就用第二颗鸡蛋从第一层扔到第49层，直到在第49层破碎，那么一共测试了50次；如果鸡蛋不碎，就将第一颗鸡蛋扔在第75层，在根据碎不碎判断接下来的情况。</p>
<p>可以看出，使用二分法的情况下，最坏的次数需要50次。</p>
<h3 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h3><p>不妨假设在这种情况下用两颗鸡蛋测试z层，最少需要x次，考虑选择怎样的策略，才能在最坏的情况下，用这x次测试出最多的层数。</p>
<p>考虑第一次尝试应该选择扔在哪层楼。假设扔在第y层楼。如果第一颗鸡蛋在第y层楼破碎，那么，接下来需要用剩下来的那颗鸡蛋，最多需要用<code>y-1</code>次尝试测试最终鸡蛋在哪层楼破碎。在这种情况下，根据总是考虑最坏情况这个条件，如果<code>y&gt;x</code>，那最终就无法测试出鸡蛋是哪一层楼（因为最坏情况下鸡蛋在第<code>y-1</code>层楼，而只剩下<code>x-1</code>次尝试的次数）。所以第一次应该扔在<strong>小于等于</strong>x的楼层数。</p>
<p>考虑<code>y&lt;x</code>的情况。如果鸡蛋在第y层破碎，那么就可以用不到<code>x-1</code>的尝试次数测试出最终楼层；如果鸡蛋在第y层不破碎，那么，问题就转换为怎样用两颗鸡蛋，在<code>x-1</code>次的步骤内测试出<code>z-y</code>层楼里鸡蛋破碎位置的<strong>子问题</strong>。而这个子问题也和先前测试第一次尝试一样，第一颗扔出的鸡蛋不能大于<code>x-1</code>层，如果大于，次数就不够，必需扔在小于<code>x-1</code>次的楼层数。</p>
<p>这样，每一次不破碎，都生成一个新的独立的子问题。直到最终一颗鸡蛋在某一次测试中破碎，就用剩下的一颗鸡蛋逐一测试最近一次扔鸡蛋和破碎层之间的区间，找出正确答案。因为每一次不破碎都生成的都是<strong>独立</strong>的子问题（当前第一颗鸡蛋选择扔的层数不影响下一个子问题的决策），所以将每一次能测试出的最大的不破碎区间组合起来，就是最终能测试的最多层数。</p>
<p>因为每一次扔鸡蛋的最远距离就是当前次数的剩余数，所以需要每次测试，都扔在比当前层数大剩余次数的楼层。那么，如果有两颗鸡蛋，用x次尝试次数能确定的鸡蛋不破碎的最多层数就为<code>x+(x-1)+(x-2)...+1</code>。</p>
<p>回到原题来。原题要求求出用两颗鸡蛋测试200层楼所需的最少次数，也就是说需要<code>x+(x-1)+(x-2)...+1&gt;200</code>，也就是<code>x(x+1)/2&gt;200</code>，解出来就是x取整最少需要20次。</p>
<h2 id="程序语言"><a href="#程序语言" class="headerlink" title="程序语言"></a>程序语言</h2><p>以上是从推理方面来考察，现在从程序逻辑的方面考虑。</p>
<p>有200层楼，用两颗鸡蛋去测试使鸡蛋不碎的最高层数，要求求出最坏情况下的最小尝试次数。也就是，设初始选择扔在第y层，f(y)为在这种策略下的所需要的最多的次数，我们所求的为所有策略中最小的次数。如果第一颗鸡蛋在y层就破碎，那么所需要的次数就为y次，如果第一颗鸡蛋在y层不破碎，那么问题就转换为一个求用两颗鸡蛋测试200-y层所需要的最坏情况下的最少次数的子问题。</p>
<p>所以，状态转移方程就为：f(x)=min(max(i, f(i-1)+1))，(0&lt; i&lt;= x)。退出条件为i==0时，需要0次。</p>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><p>使用了python实现，并且使用了functools库里面的lru_cache，这个装饰器会缓存函数结果，如果给函数传入了相同的参数，就直接返回缓存的结果。</p>
<p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    res = min([max(i, test(m-i)+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">200</span>))</span><br><span class="line"><span class="comment">#结果：14</span></span><br></pre></td></tr></table></figure></p>
<h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>同理，如果推广到更一般的情况下，用n颗鸡蛋取测试m层的大楼，求最坏情况下的最少次数。首先选定一个楼层y，扔出第一颗鸡蛋。如果这颗鸡蛋破碎了，问题就转化为用n-1颗鸡蛋去测试m-1层楼的子问题；如果没碎，问题就转化为用n颗鸡蛋去测试m-y的子问题。</p>
<p>于是，在这种情况下的状态转移方程就为：f(m,n)=min(max(f(m-1,n-1), f(m-y,n)))+1，(0&lt; y&lt; m+1)。退出条件为当m==0时，需要0次；当n==1时，需要m次。</p>
<h3 id="推广情况程序实现"><a href="#推广情况程序实现" class="headerlink" title="推广情况程序实现"></a>推广情况程序实现</h3><p><em>以下这段代码参考自<a href="https://www.zhihu.com/question/19690210/answer/18079633" target="_blank" rel="noopener">吴育昕</a></em><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    res = min([max(test(n<span class="number">-1</span>, i<span class="number">-1</span>), test(n, m-i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>)])+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(test(<span class="number">2</span>,<span class="number">36</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="">https://www.zhihu.com/question/19690210/answer/18079633</a><br><a href="">http://www.raychase.net/1374</a><br><a href="">http://blog.csdn.net/baolinq/article/details/53047288</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ysnyyhs@163.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Arianxx" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.douban.com/people/131732783/" class="iconfont icon-douban" title="douban"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Arian</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/model.model.json"},"display":{"superSample":2,"width":120,"height":240,"position":"left","hOffset":0,"vOffset":-165},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":1,"opacityOnhover":1},"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/"});</script></body>
</html>
