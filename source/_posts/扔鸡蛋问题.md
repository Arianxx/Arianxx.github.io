---
title: 扔鸡蛋问题
date: 2018-03-05 22:34:51
tags: 
    - 算法
categories: 算法
---
## 前言
逛知乎的时候偶然看到的一道算法问题，据说是谷歌某年的面试题，看了回答里大牛给的题解以后感觉解法十分巧妙，所以写一篇博客记载下来。
这个问题应该属于动态规划，但本人还没有怎么接触过算法这方面的知识，全属个人理解，所以文中可能有一些不标准的地方，还请见谅啦~_~，也欢迎指出来。

## 题目简述
有一栋200层高的大楼，给你两个质地相同但软硬未知的鸡蛋。如果在第n层扔下鸡蛋，鸡蛋不碎，那么，从第n-1层以下扔鸡蛋都不碎。如果要想测试出最高从第几层扔下时鸡蛋不会碎，问，在最坏情况下，所扔次数最少为多少？

## 题目分析
题目要求测试的是最高第几层扔下时不会碎，也就是说，在这一层下，鸡蛋都不会碎，在这一层上，鸡蛋都会碎。并且注意到，题目并没有规定这个层数，而是说在**最坏**的情况下所扔次数**最少**的策略。这也意味着，对于每个策略，鸡蛋可能在不同层数碎，并且总是使当前策略所需测试次数最多的那个层数。而我们所求的，就是在所有策略的最坏情况中，最少的那个次数。

## 解题策略
考虑如果只有一颗鸡蛋，那么就需要从第一层开始，逐一往上测试，直到找到破碎的那一层，这种策略最坏情况下所需次数为100.

#### 二分法
现在有两颗鸡蛋，那么就可以有一颗用来划定区间，另一颗用来测试鸡蛋将在这个区间的哪一层碎。比如，使用二分法，第一颗鸡蛋扔在50层。如果碎了，就用第二颗鸡蛋从第一层扔到第49层，直到在第49层破碎，那么一共测试了50次；如果鸡蛋不碎，就将第一颗鸡蛋扔在第75层，在根据碎不碎判断接下来的情况。

可以看出，使用二分法的情况下，最坏的次数需要50次。

#### 最优解
不妨假设在这种情况下用两颗鸡蛋测试z层，最少需要x次，考虑选择怎样的策略，才能在最坏的情况下，用这x次测试出最多的层数。

考虑第一次尝试应该选择扔在哪层楼。假设扔在第y层楼。如果第一颗鸡蛋在第y层楼破碎，那么，接下来需要用剩下来的那颗鸡蛋，最多需要用`y-1`次尝试测试最终鸡蛋在哪层楼破碎。在这种情况下，根据总是考虑最坏情况这个条件，如果`y>x`，那最终就无法测试出鸡蛋是哪一层楼（因为最坏情况下鸡蛋在第`y-1`层楼，而只剩下`x-1`次尝试的次数）。所以第一次应该扔在**小于等于**x的楼层数。

考虑`y<x`的情况。如果鸡蛋在第y层破碎，那么就可以用不到`x-1`的尝试次数测试出最终楼层；如果鸡蛋在第y层不破碎，那么，问题就转换为怎样用两颗鸡蛋，在`x-1`次的步骤内测试出`z-y`层楼里鸡蛋破碎位置的**子问题**。而这个子问题也和先前测试第一次尝试一样，第一颗扔出的鸡蛋不能大于`x-1`层，如果大于，次数就不够，必需扔在小于`x-1`次的楼层数。

这样，每一次不破碎，都生成一个新的独立的子问题。直到最终一颗鸡蛋在某一次测试中破碎，就用剩下的一颗鸡蛋逐一测试最近一次扔鸡蛋和破碎层之间的区间，找出正确答案。因为每一次不破碎都生成的都是**独立**的子问题（当前第一颗鸡蛋选择扔的层数不影响下一个子问题的决策），所以将每一次能测试出的最大的不破碎区间组合起来，就是最终能测试的最多层数。

因为每一次扔鸡蛋的最远距离就是当前次数的剩余数，所以需要每次测试，都扔在比当前层数大剩余次数的楼层。那么，如果有两颗鸡蛋，用x次尝试次数能确定的鸡蛋不破碎的最多层数就为`x+(x-1)+(x-2)...+1`。

回到原题来。原题要求求出用两颗鸡蛋测试200层楼所需的最少次数，也就是说需要`x+(x-1)+(x-2)...+1>200`，也就是`x(x+1)/2>200`，解出来就是x取整最少需要20次。

## 程序语言
以上是从推理方面来考察，现在从程序逻辑的方面考虑。

有200层楼，用两颗鸡蛋去测试使鸡蛋不碎的最高层数，要求求出最坏情况下的最小尝试次数。也就是，设初始选择扔在第y层，f(y)为在这种策略下的所需要的最多的次数，我们所求的为所有策略中最小的次数。如果第一颗鸡蛋在y层就破碎，那么所需要的次数就为y次，如果第一颗鸡蛋在y层不破碎，那么问题就转换为一个求用两颗鸡蛋测试200-y层所需要的最坏情况下的最少次数的子问题。

所以，状态转移方程就为：f(x)=min(max(i, f(i-1)+1))，(0< i<= x)。退出条件为i==0时，需要0次。

## 程序实现
使用了python实现，并且使用了functools库里面的lru_cache，这个装饰器会缓存函数结果，如果给函数传入了相同的参数，就直接返回缓存的结果。

*以下这段代码参考自[吴育昕](https://www.zhihu.com/question/19690210/answer/18079633)*
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def test(m):
    if m==0:
        return 0

    res = min([max(i, test(m-i)+1) for i in range(1,m+1)])

    return res

print(test(200))
#结果：14
```

## 推广
同理，如果推广到更一般的情况下，用n颗鸡蛋取测试m层的大楼，求最坏情况下的最少次数。首先选定一个楼层y，扔出第一颗鸡蛋。如果这颗鸡蛋破碎了，问题就转化为用n-1颗鸡蛋去测试m-1层楼的子问题；如果没碎，问题就转化为用n颗鸡蛋去测试m-y的子问题。

于是，在这种情况下的状态转移方程就为：f(m,n)=min(max(f(m-1,n-1), f(m-y,n)))+1，(0< y< m+1)。退出条件为当m==0时，需要0次；当n==1时，需要m次。

#### 推广情况程序实现
*以下这段代码参考自[吴育昕](https://www.zhihu.com/question/19690210/answer/18079633)*
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def test(n, m):
    if m==0:
        return 0
    if n==1:
        return m

    res = min([max(test(n-1, i-1), test(n, m-i)) for i in range(1,m+1)])+1

    return res

print(test(2,36))
```

