<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Flask 源码的二三事"/>




  <meta name="keywords" content="python, 源码, Arian's Blog" />










  <link rel="alternate" href="/atom.xml" title="Arian's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.2" />



<link rel="canonical" href="https://arianx.me/2019/01/25/flask-source-code-read/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" />



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.2" />



  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7da15ed69b10673f5e71fb736eca6373";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> Flask 源码的二三事 - Arian's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Arian's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Arian's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

<div class="waifu" style="z-index:9999">
    <div class="waifu-tips" style="z-index:9999"></div>
    <canvas id="live2d" width="240" height="220" class="live2d" style="z-index:9999"></canvas>
</div>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Flask 源码的二三事
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-25
        </span>
        
          <span class="post-category">
            
              <a href="/categories/python/">python</a>
            
          </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#路由机制"><span class="toc-text">路由机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求流程"><span class="toc-text">请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求上下文Ⅰ"><span class="toc-text">请求上下文Ⅰ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalStack"><span class="toc-text">LocalStack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalProxy"><span class="toc-text">LocalProxy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求上下文Ⅱ"><span class="toc-text">请求上下文Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用上下文"><span class="toc-text">应用上下文</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>本文将基于 Flask 1.1.dev ( <a href="https://github.com/pallets/flask/commit/a74864ec229141784374f1998324d2cbac837295" target="_blank" rel="noopener">a74864</a> )，分析 Flask 源码之中一些有趣并且值得关注的部分，包括 路由机制、请求流程、上下文管理 等等。</p>
<a id="more"></a>
<h2 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h2><p>本节关注 Flask 的路由机制。首先还是先看下 Flask 的 hello world：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure></p>
<p>跟进 route 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        endpoint = options.pop(<span class="string">'endpoint'</span>, <span class="keyword">None</span>)</span><br><span class="line">        self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure></p>
<p>可见 route 方法实际上根据给定的参数另外调用了 add_url_rule：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint=None, view_func=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 provide_automatic_options=None, **options)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> endpoint <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        endpoint = view_func.__name__</span><br><span class="line">    options[<span class="string">'endpoint'</span>] = endpoint</span><br><span class="line">    methods = options.pop(<span class="string">'methods'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rule = self.url_rule_class(rule, methods=methods, **options)</span><br><span class="line"></span><br><span class="line">    self.url_map.add(rule)</span><br><span class="line">    <span class="comment"># self.view_functions = &#123;&#125;</span></span><br><span class="line">    self.view_functions[endpoint] = view_func</span><br></pre></td></tr></table></figure></p>
<p>添加路由的逻辑最终由 add_url_rule 这个方法实现。它的参数里 rule 就是要匹配 url 的模式，endpoint 是这个视图的端点名，view_func 是我们定义的函数。默认情况下，endpoint 为函数的名字。我们根据这些信息调用了 self.url_rule_class 方法，并用其返回值作为参数调用了 self.url_map.add。最后，将 endpoint 作为键，我们定义的函数作为值，添加进了 self.view_functions 字典。</p>
<p>这里 self.url_rule_class 和 self.url_map 是什么呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> Map, Rule</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    url_rule_class = Rule</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(...)</span>:</span></span><br><span class="line">        self.url_map = Map()</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>可见，Flask 路由机制的核心是 Map 和 Rule 类，而这两个类都来自 Flask 高度依赖的 werkzeug 包。因此，想要明白 Flask 路由的原理，首先我们必须对 werkzeug 有一定了解。这里我们先看下 Map 和 Rule 的简单用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自 werkzeug docs</span></span><br><span class="line">url_map = Map()</span><br><span class="line">url_map.add(</span><br><span class="line">    Rule(<span class="string">'/&lt;id&gt;'</span>, endpoint=<span class="string">'user'</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">   adapter = self.url_map.bind_to_environ(request.environ)</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       endpoint, values = adapter.match()</span><br><span class="line">       <span class="keyword">return</span> getattr(self, <span class="string">'on_'</span> + endpoint)(request, **values)</span><br><span class="line">   <span class="keyword">except</span> HTTPException, e:</span><br><span class="line">       <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure></p>
<p>这里的 request.environ 中的 evniron 是 wsgi 应用中传入 __call__ 方法的一个参数。</p>
<p>调用 Map.bind_to_environ，根据给定请求的 environ 字典，生成了一个 URLAdapter。然后，调用 adapter 上的 match 方法，就能够得到此次请求对应的端点名和对应 url 的参数。比如说，如果此次请求是 <code>http://localhost:5000/foo</code>，那么返回的 endpoint 和 values 就为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">endpoint == <span class="string">'user'</span></span><br><span class="line">values == &#123;<span class="string">"id"</span>: <span class="string">"foo"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，这里 Rule 对应的是每一条之后需要匹配的 url 规则，Map 将这些规则收集起来，对应这些规则的映射。之后，当有请求来的时候，就绑定 environ 生成 adapter，并调用 match 得到匹配的端点和参数。</p>
<p>现在我们返回 Flask。前面我们在 Flask 应用的初始化过程中生成了 Map 的一个实例。之后的每一次使用 route，在默认情况下把函数名作为 endpoint，生成一个新的 Rule 对象。并将它添加进 Map 实例中。最后将 endpoint 和函数本身作为键值添加进字典。</p>
<p>Map 是通过遍历 Rule，并一一匹配正则表达式来匹配路由的。这点目前不详细叙述，日后在另一篇文章中讲下吧。</p>
<p>用户方面添加路由的流程大致是这样了。下面我们从处理请求的流程中看路由机制的另一个方面。</p>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>本节关注 Flask wsgi 应用的实现。我们查看 Flask 类的 __call__ 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.wsgi_app(environ, start_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 生成请求上下文</span></span><br><span class="line">        ctx = self.request_context(environ)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 推入上下文栈</span></span><br><span class="line">                ctx.push()</span><br><span class="line">                <span class="comment"># 分发路由</span></span><br><span class="line">                response = self.full_dispatch_request()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                error = e</span><br><span class="line">                <span class="comment"># 处理异常</span></span><br><span class="line">                response = self.handle_exception(e)</span><br><span class="line">                <span class="comment"># 最终得到包含了返回信息的 werkzeug Response 实例，调用它完成请求。</span></span><br><span class="line">            <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 这里 finally 语句会在 return 之前执行</span></span><br><span class="line">            <span class="comment"># 弹出请求上下文对象</span></span><br><span class="line">            ctx.auto_pop(error)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>这里 __call__ 方法仅仅将逻辑交给了 wsig_app 方法。这样做的一个好处在于，如果之后要为整个应用添加中间件，就不用处理整个 Flask 实例，直接替换 wsgi_app 方法即可，不用担心实例中的大量配置被丢失或覆盖：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> middleware, app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以这样用：</span></span><br><span class="line">app.wsgi_app = middleware(app.wsgi_app)</span><br><span class="line"><span class="comment"># 而不是:</span></span><br><span class="line">app = middleware(app)</span><br></pre></td></tr></table></figure></p>
<p>回到 wsgi_app 方法，可以看到 response 由 self.full_dispatch_request 生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rv = self.dispatch_request()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        rv = self.handle_user_exception(e)</span><br><span class="line">    <span class="comment"># 将视图函数返回的值转换为合法的 response</span></span><br><span class="line">    <span class="keyword">return</span> self.finalize_request(rv)</span><br></pre></td></tr></table></figure></p>
<p>跟进 slef.dispatch_request:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 得到请求上下文栈顶的 request 对象</span></span><br><span class="line">    req = _request_ctx_stack.top.request</span><br><span class="line">    rule = req.url_rule</span><br><span class="line">    <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br></pre></td></tr></table></figure></p>
<p>注意到这里出现了上一节里面的 self.view_functions，它的键是视图的端点名，值是视图对应的函数。这里我们通过 rule.endpoint 和 req.view_args 调用了视图函数，说明此时我们已经通过请求相关的信息(environ)，匹配到了对应的 url 和参数。</p>
<p>调用我们储存在 self.view_functions 里的视图函数得到请求的返回值以后，就将它传给了 self.finalize_request，将之转化为一个合法的响应对象后返回。</p>
<p>然而，这里的问题是，我们明明没有显示调用 self.url_map.bind_to_environ 与 adapter.match，是怎样从 _request_ctx_stack.top.request 里得到正确信息的呢？实际上，奥秘隐藏在 Flask 的请求上下文机制里。</p>
<h2 id="请求上下文Ⅰ"><a href="#请求上下文Ⅰ" class="headerlink" title="请求上下文Ⅰ"></a>请求上下文Ⅰ</h2><p>用过 Flask 的同学一定对其 request 对象映像深刻。不像 django 等框架，在每个视图函数里，都需要传入一个 request 参数，在 Flask 中，可以直接使用从全局导入的 request 对象:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/show')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(request.environ)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br></pre></td></tr></table></figure></p>
<p>request 自动适配每一个来到的请求。我们看看 request 的真面目：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> getattr(top, name)</span><br><span class="line"></span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">'request'</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里一时间让我们不明所以。我们看到 _request_ctx_stack 原来是 werkzeug 中 LocalStack 的实例（注意 _request_ctx_stack 在上一节 dispatch_request 中出现过），request 是 LocalProxy 的实例。</p>
<h4 id="LocalStack"><a href="#LocalStack" class="headerlink" title="LocalStack"></a>LocalStack</h4><p>为了理解这一段代码，我们需要先了解 LocalStack 的用法。简单来说，这里的 LocalStack 类似于 <a href="https://stackoverflow.com/questions/104983/what-is-thread-local-storage-in-python-and-why-do-i-need-it" target="_blank" rel="noopener">线程本地变量</a>，在一个的线程中修改它的值，对于其它线程来说是透明的。更具体的说，这里的 LocalStack 是一个 线程本地栈，在一个线程中给这个栈推入或弹出值，并不会影响其它线程中的 LocalStack。</p>
<p>LocalStack 的实现依赖于 werkzeug 中的 Local 类，我们先查看 Local 类的源码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 实例中只能修改 __storage__ 和 __ident_func__ 这两个属性</span></span><br><span class="line">    <span class="comment"># 节省内存空间</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 因为本类已经有了 __setattr__ 方法，为了避免循环调用</span></span><br><span class="line">        <span class="comment"># 直接从 object.__setattr__ 给它的属性设置值</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        <span class="comment"># get_ident 得到每个线程的唯一 id</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 释放线程本地变量</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># self.__ident__func 获取线程 id</span></span><br><span class="line">            <span class="comment"># 得到 __storage__ 字典里对应本线程字典中键为 name 的值</span></span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在这个实例上设置属性，会将它储存在本线程对应的字典里</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 线程 id</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除一个属性，删除本线程对应字典里的值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure></p>
<p>Local 类的实例是一个线程本地变量。它在内部维护了一个 __storage<strong> 字典，这个字典的键为各线程的 id，值为字典，储存对应线程上设置的值。它通过 \</strong>setattr<strong> 等特殊方法，将属性访问转发给内部的 \</strong>storage__ 字典。这样，对于不同的线程，Local 的实例上储存的值是不同的。</p>
<p>注意到 Local 类中有一个 __slots<strong> 属性。这是一个特殊属性，拥有它的类的实例上不会有 \</strong>dict__ 字典，从而节省了内存空间。文档中说：</p>
<blockquote>
<p>The __slots<strong> declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable. Space is saved because \</strong>dict__ is not created for each instance.</p>
</blockquote>
<p>相应的，拥有 __slots<strong> 的类，其实例也不被允许赋予 \</strong>slots__ 中规定外的属性。</p>
<p>还是让我们继续看 LocalStack 的源码吧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 保存了上面 Local 的实例，一个线程本地变量。</span></span><br><span class="line">        self._local = Local()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 释放内部的线程本地变量</span></span><br><span class="line">        self._local.__release_local__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Pushes a new item to the stack"""</span></span><br><span class="line">        rv = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># self._local 是线程本地变量。储存在它上面的属性会储存在其内部的 __storage__ 字典中</span></span><br><span class="line">            <span class="comment"># 这样，对于不同的线程来说，self._local.stack 这个栈也是不同的</span></span><br><span class="line">            self._local.stack = rv = []</span><br><span class="line">        rv.append(obj)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Removes the topmost item from the stack, will return the</span></span><br><span class="line"><span class="string">        old value or `None` if the stack was already empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">elif</span> len(stack) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果 stack 只剩最后一个，为节省内存，将内部的字典释放</span></span><br><span class="line">            self.__release_local__()</span><br><span class="line">            <span class="keyword">return</span> stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则弹出栈顶</span></span><br><span class="line">            <span class="keyword">return</span> stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""The topmost item on the stack.  If the stack is empty,</span></span><br><span class="line"><span class="string">        `None` is returned.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._local.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</span><br><span class="line">            <span class="comment"># 如果栈中还没有元素，不报错而是返回 None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>结合前面的 LocalStack 看，Local 的用法就很明显了。它使用前面的线程本地变量，模仿了一个线程本地栈。与实际的栈不同的地方还在于，当栈为空时，不弹出异常，而是返回 None。同时，当弹出栈最后一个元素时，线程本地变量中维护的本地的字典将会被提前释放以节省内存空间。</p>
<p>现在我们了解 LocalStack 了，我们可以发现 _request_ctx_stack 实际上就是 LocalStack 的实例，一个线程本地栈。实际上，_request_ctx_stack 就是 Flask 中至关重要的<strong>请求上下文栈</strong>。当然，现在它仍然空空如也，只有当有也新的请求进入时，服务器会新建一个线程，然后使用上一节中的<code>ctx.push()</code>推入新的请求上下文。</p>
<h4 id="LocalProxy"><a href="#LocalProxy" class="headerlink" title="LocalProxy"></a>LocalProxy</h4><p>然而我们这里仍然没触及到我们最感兴趣的 request，它还与 LocalProxy 类相关：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 节省内存</span></span><br><span class="line">    __slots__ = (<span class="string">'__local'</span>, <span class="string">'__dict__'</span>, <span class="string">'__name__'</span>, <span class="string">'__wrapped__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, local, name=None)</span>:</span></span><br><span class="line">        <span class="comment"># 它本身有 __setattr__，避免循环调用</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'_LocalProxy__local'</span>, local)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__name__'</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self.__local, <span class="string">'__release_local__'</span>):</span><br><span class="line">            <span class="comment"># 如果不是线程本地变量，作为函数调用并返回。</span></span><br><span class="line">            <span class="comment"># 例如，前面的 request ，传入的参数就不是直接的线程本地变量，而是一个 </span></span><br><span class="line">            <span class="comment"># partial 了的函数</span></span><br><span class="line">            <span class="keyword">return</span> self.__local()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(self.__local, self.__name__)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'no object bound to %s'</span> % self.__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dict__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 转发给它代理的线程本地变量</span></span><br><span class="line">            <span class="keyword">return</span> self._get_current_object().__dict__</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">'__dict__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 转发给它代理的线程本地变量</span></span><br><span class="line">            <span class="keyword">return</span> bool(self._get_current_object())</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 它还有许多与上面两个方法相似的代理</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>LocalProxy 是一个有意思的类，结合前面我们给出的 <code>request = LocalProxy(partial(_lookup_req_object, &#39;request&#39;))</code> 语句就会更有意思。它接受一个线程本地变量，然后将对它的实例的几乎所有访问，都会转发给那个线程本地变量上的指定属性。并且在那个属性不存在时弹出 RuntimeError 异常。</p>
<p>注意到它的 __init<strong> 方法中的 `object.</strong>setattr<strong>(self, ‘_LocalProxy</strong>local’, local)`语句。这里使用 object.__setattr<strong> 是为了避免循环调用，因为它自己也实现了 \</strong>setattr<strong> 方法（并将它转发给线程本地变量上的属性）。这里使用了 _LocalProxy</strong>local 这个名称，然而在之后却直接以 __local 访问。这是因为 __local 是一个双下划线方法，在自身以外的类访问时，会被重命名。</p>
<p>前面我们提到过，__slots<strong> 特殊属性会删除实例的 \</strong>dict<strong> 字典，并以恒定空间储存实例属性，以节省内存。然而这里在 \</strong>slots<strong> 中，又加回了 \</strong>dict<strong> 方法。本来因为 \</strong>slots__ 的原因，将要删除的字典，这里又额外添加进来，这是不是有几分做无用功的意味？</p>
<p>实际上，这也是为了节省内存而做的努力。这里必须存在 __dict<strong> 原因，是因为 LocalProxy 也会将对自身的属性访问转发给其代理的对象，因此必须允许对 \</strong>dict<strong> 的访问。我们已经为了节省内存，在 \</strong>slots<strong> 中设定了 \</strong>local、__name<strong> 等属性，这样，这些属性将会被存放在固定的空间中而非 \</strong>dict<strong>。然而，没有 \</strong>dict<strong>，尝试对实例赋其它值时，就会直接引起 AttributeError，使得我们无法对其作转发。因此，我们为其添加 \</strong>dict__ 属性以重新允许对实例赋值。当然，此时所有赋值实际会被转发给其代理对象。</p>
<p>值得注意的是，即使重新规定了 __dict<strong>，当对实例赋值时，规定在 \</strong>slots<strong> 中的其它属性，仍会被储存在固定空间而非 \</strong>dict<strong> 字典，从而 LocalProxy 实例上的 \</strong>dict<strong> 字典实际会一直为空。对线程本地变量的代理，以及 \</strong>slots<strong> 属性的优先级，两者一起使得实例虽然有 \</strong>dict<strong> 属性，却不会浪费使 \</strong>slots__ 失效的更多空间。</p>
<p>好，关于它的 __slots__ 的问题到此为止。我们需要知道这个类会将访问转发给线程本地变量上的一个属性。对于我们的 request 而言，我们传入了 <code>partial(_lookup_req_object, &#39;request&#39;)</code> 作为参数生成它。这里我们回顾一下 _lookup_req_object 的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> getattr(top, name)</span><br></pre></td></tr></table></figure></p>
<p>它会查看栈顶是否有请求上下文，如果有，就返回想要的属性，否则弹出异常。结合 LocalProxy ，可以看出，实际上，<strong>request一直是请求上下文栈顶的对象的”request”属性</strong>。并且这个 request 对于各个请求来说是独立的。当请求上下文为空时，会弹出 RuntimeError。</p>
<h2 id="请求上下文Ⅱ"><a href="#请求上下文Ⅱ" class="headerlink" title="请求上下文Ⅱ"></a>请求上下文Ⅱ</h2><p>现在我们了解到 request 是 _request_ctx_stack 这个请求上下文栈的栈顶对象里面的 “request” 属性，但实际上虽然我们知晓了请求上下文栈的存在，却还不了解具体在这个上下文栈中储存了什么对象，因而不能理解它的实质。为了了解 request 的实质，我们回顾前面的请求流程。</p>
<p>前面提到过，Flask 也以 wsgi 的应用呈现。最后，Flask 的 app 实例会暴露出一个 __call<strong> 方法，给应用服务器访问。应用服务器会给 \</strong>call__ 方法传入代表请求上下文信息的 environ 字典，以及一个设置 response header 和 status 的 start_response 回调函数。</p>
<p>Flask 将 __call__ 方法转发给 wsgi_app 方法。注意到 wsig_app 方法中的 <code>ctx = self.request_context(environ)</code> 语句，以及之后的 <code>ctx.push()</code> 和最后的 <code>ctx.auto_pop(error)</code> 语句。实际上，就是这些语句将我们需要的对象都推入到了请求上下文栈中。</p>
<p>我们查看 self.request_context 的源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .ctx <span class="keyword">import</span> RequestContext</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_context</span><span class="params">(self, environ)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> RequestContext(self, environ)</span><br></pre></td></tr></table></figure></p>
<p>跟进 RequestContext:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, environ, request=None, session=None)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line">        <span class="keyword">if</span> request <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            request = app.request_class(environ)</span><br><span class="line">        self.request = request</span><br><span class="line">        self.url_adapter = <span class="keyword">None</span></span><br><span class="line">        self.url_adapter = app.create_url_adapter(self.request)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.url_adapter <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.match_request()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，又回调了 app 实例中的 app.request_class 和 app.create_url_adapter 。先看 app.request_class:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .wrappers <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    request_class = Request</span><br></pre></td></tr></table></figure></p>
<p>这里的 Request 对象主要是 Flask 对于 werkzeug 里面 RequestBase 对象的封装。它接受一个 environ 字典，将储存在 environ 字典中的原始信息以各种方式封装后方便用户访问。</p>
<p>更重要的是 app.create_url_adapter:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_url_adapter</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> self.url_map.bind_to_environ(</span><br><span class="line">        request.environ)</span><br></pre></td></tr></table></figure></p>
<p>饶了一个大圈子之后这里我们终于又回到了第一节路由机制里面的 self.url_map 对象。它是 werkzeug 里 Map 类的实例。根据我们前面介绍过的用法，这里绑定 environ 信息后会返回一个 adapter，调用 adapter 的 match 方法就能够得到匹配的端点名和参数。我们将 adapter 储存在了 RequestContext 的 url_adapter 属性中。</p>
<p>接下来看 RequestContext.match_request:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    url_rule, self.request.view_args = \</span><br><span class="line">        self.url_adapter.match(return_rule=<span class="keyword">True</span>)</span><br><span class="line">    self.request.url_rule = url_rule</span><br></pre></td></tr></table></figure></p>
<p>这里终于调用了 self.url_adapter 的 match 函数。调用之后，我们就已经匹配到了分发这次请求需要的信息了。将它们储存在了 self.request.url_rule 和 self.request.view_args 中。</p>
<p>现在 RequestContext 已经初始化完毕了。之后在正式处理请求的 <code>response = self.full_dispatch_request()</code> 语句前，先调用了 <code>ctx.push()</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    _request_ctx_stack.push(self)</span><br></pre></td></tr></table></figure></p>
<p>这里再次出现了 _request_ctx_stack，前面分析过的线程本地栈。我们将 RequestContext 的实例推入了栈。在请求结束之后，我们又会调用 ctx.auto_pop 把这个实例弹出栈。</p>
<p>现在我们能够了解我们从全局导入的 reqeust 对象的实质了。它就是 Flask.wrappers 中 Request 类的实例，绑定在 RequestContext 的实例上。在每一次请求中，都会新建一个请求上下文对象 RequestContext，在它的初始化过程中，会调用绑定在 app 上的 werkzeug 里的 Map 实例 url_map 匹配 url，得到参数，将它们作为 request 的 url_rule 和 view_args 属性。然后将这个请求上下文推入请求上下文栈。我们访问到的 request 对象，就是对这个请求上下文栈顶的请求上下文里面的那个 request 的代理。这样，对于每个不同的线程而言，这个 request 对象也就自动包含了相应的请求信息。</p>
<p>比如说，前面的 dispatch_request 中出现过这样的语句 <code>return self.view_functions[rule.endpoint](**req.view_args)</code>，这里的 rule.endpoint 和 req.view_args 就是从绑定完毕后的 request 对象里面获取的。</p>
<p>关于请求上下文，还有一点值得琢磨。每一次请求都会新建一个线程，这样，在一次请求的整个流程中，明明只需要将这个线程对应的请求上下文推入一次即可，为什么要用栈来实现请求上下文呢？这一点 Flask 的源码中曾经提到过：</p>
<blockquote>
<p>Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together.</p>
</blockquote>
<p>这样做是为了能够在多个不同的应用之间做内部重定向。虽然如此，Flask 尚没有提供与此相关的 api，可能为了以后保留的。在绝大多数的开发中，实际上请求上下文栈一直只会有最多一个上下文对象。</p>
<h2 id="应用上下文"><a href="#应用上下文" class="headerlink" title="应用上下文"></a>应用上下文</h2><p>除了请求上下文之外，Flask 还存在应用上下文的概念。应用上下文随线程中第一次请求上下文的推入而创建，在前面的 <code>ctx.push</code> 方法中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    app_ctx = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> app_ctx.app != self.app:</span><br><span class="line">        app_ctx = self.app.app_context()</span><br><span class="line">        app_ctx.push()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>这里的 _app_ctx_stack，应用上下文栈，原理和请求上下文栈别无二致：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_app_ctx_stack = LocalStack()</span><br></pre></td></tr></table></figure></p>
<p>app_ctx.push 中，推入的是 AppContext 类的实例。这个类封装了应用的一些信息，不详细叙述了。</p>
<p>这里值得关注的是，为什么 Flask 除了请求上下文以外，还需要一个应用上下文的概念？在一次请求中，不是可以直接调用 RequestContext 上的 app 属性获得应用相关的信息吗？要理解这一点，需要先理解 Flask 多应用的存在。</p>
<p>我们可以通过 Flask 中的蓝图，将一个大的应用划分为几个子板块。但有时，这样还不够，我们需要几个子板块都拥有自己的配置信息与逻辑，成为几个单独的子系统。Flask 允许这一点，比如说，可以这样使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自 stackoverflow</span></span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</span><br><span class="line"><span class="keyword">from</span> frontend_app <span class="keyword">import</span> application <span class="keyword">as</span> frontend</span><br><span class="line"><span class="keyword">from</span> backend_app <span class="keyword">import</span> application <span class="keyword">as</span> backend</span><br><span class="line"></span><br><span class="line">application = DispatcherMiddleware(frontend, &#123;</span><br><span class="line">    <span class="string">'/backend'</span>:     backend</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样，在一次请求对应的一个解释器线程中，可能会同时存在多个逻辑上分割的 Flask 应用。而 Flask 请求还恰恰赋予了我们使用 url_for 这样的全局函数直接获取一个应用中端点名对应的 url，这就需要保持每个应用的上下文，需要时从应用上下文栈中获取。</p>
<p>Flask 就借助于应用上下文实现了 current_app 这样的全局对象，帮助我们获取此次请求对应的应用信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span>:</span></span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line"></span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br></pre></td></tr></table></figure></p>
<p>可以发现和 request 非常相似。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://arianx.me">Arian</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://arianx.me/2019/01/25/flask-source-code-read/">https://arianx.me/2019/01/25/flask-source-code-read/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/python/">python</a>
            
              <a href="/tags/源码/">源码</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2018/12/30/walkthrough-cpython3.7-dict-source-code/">
        <span class="next-text nav-default">cpython3.7 dict 对象的内在原理</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ysnyyhs@163.com" class="iconfont icon-email" title="email" target="_blank"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Arianxx" class="iconfont icon-github" title="github" target="_blank"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.douban.com/people/131732783/" class="iconfont icon-douban" title="douban" target="_blank"></a>
        
      
    
      
    
      
    
      
    

    	<a href="https://music.163.com/#/user/home?id=101778288" class="myiconfont icon-163music" title="yun music" target="_blank">
    	</a>

      <a href="https://space.bilibili.com/3101019/#/" class="myiconfont icon-bilibili"
      title="bilibili" target="_blank">
      </a>

    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Arian</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://arianx.me/2019/01/25/flask-source-code-read/';
        this.page.identifier = '2019/01/25/flask-source-code-read/';
        this.page.title = 'Flask 源码的二三事';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//arianx.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.2"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.10.2"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js" integrity="sha384-BnFYVbw3PHhz5qWXTCSL12MjPc3KxjdKPx7R4R5JjIzxFmYX267NDyJ9B/nZANdg" crossorigin="anonymous"></script>
<script src="/js/src/transition.min.js"></script>

<script async src="/js/src/message.js"></script>
<script src="/js/src/live2d.js"></script>

<script type="text/javascript">
	modelNames = ["default-costume.json", "pajamas-costume.json", "school-costume.json"]
	modelNum = modelNames.length
	randomName = modelNames[Math.floor(Math.random() * modelNum)]

    loadlive2d("live2d", "/model/Pio/" + randomName);
    $('.container').after("<canvas class='fireworks' style='position:fixed;left:0;top:0;pointer-events:none;z-index:999'></canvas>")
</script>

<script async type="text/javascript" src="/js/src/jquery.click-firewords.js"></script>

  </body>
</html>
